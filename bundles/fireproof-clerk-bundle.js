var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from4, except, desc) => {
  if (from4 && typeof from4 === "object" || typeof from4 === "function") {
    for (let key of __getOwnPropNames(from4))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from4[key], enumerable: !(desc = __getOwnPropDesc(from4, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/file-service.js
var init_file_service = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/file-service.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var ALIAS, DOC, MAP, PAIR, SCALAR, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar, isSeq, hasAnchor;
var init_identity = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/identity.js"() {
    ALIAS = /* @__PURE__ */ Symbol.for("yaml.alias");
    DOC = /* @__PURE__ */ Symbol.for("yaml.document");
    MAP = /* @__PURE__ */ Symbol.for("yaml.map");
    PAIR = /* @__PURE__ */ Symbol.for("yaml.pair");
    SCALAR = /* @__PURE__ */ Symbol.for("yaml.scalar");
    SEQ = /* @__PURE__ */ Symbol.for("yaml.seq");
    NODE_TYPE = /* @__PURE__ */ Symbol.for("yaml.node.type");
    isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return visitor.Map?.(key, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path);
  if (isPair(node))
    return visitor.Pair?.(key, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var BREAK, SKIP, REMOVE;
var init_visit = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/visit.js"() {
    init_identity();
    BREAK = /* @__PURE__ */ Symbol("break visit");
    SKIP = /* @__PURE__ */ Symbol("skip children");
    REMOVE = /* @__PURE__ */ Symbol("remove node");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars, escapeTagName, Directives;
var init_directives = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/directives.js"() {
    init_identity();
    init_visit();
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error48) {
            onError(String(error48));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag2) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag2.startsWith(prefix))
            return handle + escapeTagName(tag2.substring(prefix.length));
        }
        return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
          const tags = {};
          visit(doc.contents, (_key, node) => {
            if (isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root2) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root2, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors ?? (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error48 = new Error("Failed to resolve repeated object (this should not happen)");
          error48.source = source;
          throw error48;
        }
      }
    },
    sourceObjects
  };
}
var init_anchors = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/anchors.js"() {
    init_identity();
    init_visit();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var init_applyReviver = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/applyReviver.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
var init_toJS = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/toJS.js"() {
    init_identity();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase;
var init_Node = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Node.js"() {
    init_applyReviver();
    init_identity();
    init_toJS();
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
var Alias;
var init_Alias = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Alias.js"() {
    init_anchors();
    init_visit();
    init_identity();
    init_Node();
    init_toJS();
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit(doc, {
            Node: (_key, node) => {
              if (isAlias(node) || hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (data?.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src2 = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src2} `;
        }
        return src2;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue, Scalar;
var init_Scalar = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Scalar.js"() {
    init_identity();
    init_Node();
    init_toJS();
    isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    Scalar = class extends NodeBase {
      constructor(value) {
        super(SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match2 = tags.filter((t) => t.tag === tagName);
    const tagObj = match2.find((t) => !t.format) ?? match2[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map3 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map3.items.push(value);
    return map3;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      ref.anchor ?? (ref.anchor = onAnchor(value));
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}
var defaultTagPrefix;
var init_createNode = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/createNode.js"() {
    init_Alias();
    init_identity();
    init_Scalar();
    defaultTagPrefix = "tag:yaml.org,2002:";
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath, Collection;
var init_Collection = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Collection.js"() {
    init_createNode();
    init_identity();
    init_Node();
    isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema4) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema4,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema4) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema4)
          copy.schema = schema4;
        copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar(node) ? node.value : node;
        else
          return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var stringifyComment, lineComment;
var init_stringifyComment = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
    stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text2, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text2[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text2[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text2, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text2[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text2;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text2[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text2[++i];
    } else {
      do {
        ch = text2[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text2[start];
    }
  }
  return end;
}
var FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED;
var init_foldFlowLines = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json2 = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
    if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str += json2.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start, i);
            const code4 = json2.substr(i + 2, 4);
            switch (code4) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code4.substr(0, 2) === "00")
                  str += "\\x" + code4.substr(2);
                else
                  str += json2.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json2.slice(start) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal2 ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal2) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
var getFoldOptions, containsDocumentMarker, blockEndNewlines;
var init_stringifyString = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
    init_Scalar();
    init_foldFlowLines();
    getFoldOptions = (ctx, isBlock2) => ({
      indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match2 = tags.filter((t) => t.tag === item.tag);
    if (match2.length > 0)
      return match2.find((t) => t.format === item.format) ?? match2[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match2 = tags.filter((t) => t.identify?.(obj));
    if (match2.length > 1) {
      const testMatch = match2.filter((t) => t.test);
      if (testMatch.length > 0)
        match2 = testMatch;
    }
    tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name2 = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag ?? (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
var init_stringify = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringify.js"() {
    init_anchors();
    init_identity();
    init_stringifyComment();
    init_stringifyString();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
var init_stringifyPair = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
    init_identity();
    init_Scalar();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}
var init_log = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/log.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
function addMergeToJSMap(ctx, map3, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map3, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map3, it);
  else
    mergeValue(ctx, map3, value);
}
function mergeValue(ctx, map3, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map3 instanceof Map) {
      if (!map3.has(key))
        map3.set(key, value2);
    } else if (map3 instanceof Set) {
      map3.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
      Object.defineProperty(map3, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map3;
}
var MERGE_KEY, merge, isMergeKey;
var init_merge = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js"() {
    init_identity();
    init_Scalar();
    MERGE_KEY = "<<";
    merge = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag2) => tag2.tag === merge.tag && tag2.default);
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map3, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map3, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map3, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map3 instanceof Map) {
      map3.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map3 instanceof Set) {
      map3.add(jsKey);
    } else {
      const stringKey2 = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey2, ctx);
      if (stringKey2 in map3)
        Object.defineProperty(map3, stringKey2, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map3[stringKey2] = jsValue;
    }
  }
  return map3;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
var init_addPairToJSMap = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
    init_log();
    init_merge();
    init_stringify();
    init_identity();
    init_toJS();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair;
var init_Pair = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/Pair.js"() {
    init_createNode();
    init_stringifyPair();
    init_addPairToJSMap();
    init_identity();
    Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema4) {
        let { key, value } = this;
        if (isNode(key))
          key = key.clone(schema4);
        if (isNode(value))
          value = value.clone(schema4);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
var init_stringifyCollection = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap;
var init_YAMLMap = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
    init_stringifyCollection();
    init_addPairToJSMap();
    init_Collection();
    init_identity();
    init_Pair();
    init_Scalar();
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema4) {
        super(MAP, schema4);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema4, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map3 = new this(schema4);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map3.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema4.sortMapEntries === "function") {
          map3.items.sort(schema4.sortMapEntries);
        }
        return map3;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del2 = this.items.splice(this.items.indexOf(it), 1);
        return del2.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type3) {
        const map3 = Type3 ? new Type3() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap(ctx, map3, item);
        return map3;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js
var map;
var init_map = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/map.js"() {
    init_identity();
    init_YAMLMap();
    map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map3, onError) {
        if (!isMap(map3))
          onError("Expected a mapping for this tag");
        return map3;
      },
      createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq;
var init_YAMLSeq = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
    init_createNode();
    init_stringifyCollection();
    init_Collection();
    init_identity();
    init_Scalar();
    init_toJS();
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema4) {
        super(SEQ, schema4);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del2 = this.items.splice(idx, 1);
        return del2.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema4, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema4);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js
var seq;
var init_seq = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/seq.js"() {
    init_identity();
    init_YAMLSeq();
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js
var string;
var init_string = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/string.js"() {
    init_stringifyString();
    string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag;
var init_null = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/common/null.js"() {
    init_Scalar();
    nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag;
var init_bool = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/bool.js"() {
    init_Scalar();
    boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format: format3, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format3 && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
var init_stringifyNumber = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN, floatExp, float;
var init_float = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intIdentify, intResolve, intOct, int, intHex;
var init_int = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/int.js"() {
    init_stringifyNumber();
    intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js
var schema;
var init_schema = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/core/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    schema = [
      map,
      seq,
      string,
      nullTag,
      boolTag,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float
    ];
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON, jsonScalars, jsonError, schema2;
var init_schema2 = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/json/schema.js"() {
    init_Scalar();
    init_map();
    init_seq();
    stringifyJSON = ({ value }) => JSON.stringify(value);
    jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify2,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    schema2 = [map, seq].concat(jsonScalars, jsonError);
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary;
var init_binary = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
    init_Scalar();
    init_stringifyString();
    binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src2, onError) {
        if (typeof atob === "function") {
          const str = atob(src2.replace(/[\n\r]/g, ""));
          const buffer3 = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer3[i] = str.charCodeAt(i);
          return buffer3;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src2;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf3 = value;
        let str;
        if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf3.length; ++i)
            s += String.fromCharCode(buf3[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.BLOCK_LITERAL);
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs;
var init_pairs = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLSeq();
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap, omap;
var init_omap = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
    init_identity();
    init_toJS();
    init_YAMLMap();
    init_YAMLSeq();
    init_pairs();
    YAMLOMap = class _YAMLOMap extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map3);
        for (const pair of this.items) {
          let key, value;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value);
        }
        return map3;
      }
      static from(schema4, iterable, ctx) {
        const pairs2 = createPairs(schema4, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError) {
        const pairs2 = resolvePairs(seq2, onError);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag, falseTag;
var init_bool2 = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
    init_Scalar();
    trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2, floatExp2, float2;
var init_float2 = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
      }
    };
    float2 = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intIdentify3, intBin, intOct2, int2, intHex2;
var init_int2 = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
    init_stringifyNumber();
    intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
    intBin = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
      stringify: (node) => intStringify2(node, 2, "0b")
    };
    intOct2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
      stringify: (node) => intStringify2(node, 8, "0")
    };
    int2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex2 = {
      identify: intIdentify3,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
      stringify: (node) => intStringify2(node, 16, "0x")
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet, set;
var init_set = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
    init_identity();
    init_Pair();
    init_YAMLMap();
    YAMLSet = class _YAMLSet extends YAMLMap {
      constructor(schema4) {
        super(schema4);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema4, iterable, ctx) {
        const { replacer } = ctx;
        const set3 = new this(schema4);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set3.items.push(createPair(value, null, ctx));
          }
        return set3;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
      resolve(map3, onError) {
        if (isMap(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime, floatTime, timestamp;
var init_timestamp = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
    init_stringifyNumber();
    intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match2 = str.match(timestamp.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month, day2, hour2, minute2, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date5 = Date.UTC(year2, month - 1, day2, hour2 || 0, minute2 || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date5 -= 6e4 * d;
        }
        return new Date(date5);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3;
var init_schema3 = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_binary();
    init_bool2();
    init_float2();
    init_int2();
    init_merge();
    init_omap();
    init_pairs();
    init_set();
    init_timestamp();
    schema3 = [
      map,
      seq,
      string,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct2,
      int2,
      intHex2,
      floatNaN2,
      floatExp2,
      float2,
      binary,
      merge,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp
    ];
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags = tags.concat(tag2);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag2) => {
    const tagObj = typeof tag2 === "string" ? tagsByName[tag2] : tag2;
    if (!tagObj) {
      const tagName = JSON.stringify(tag2);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}
var schemas, tagsByName, coreKnownTags;
var init_tags = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/tags.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    init_schema();
    init_schema2();
    init_binary();
    init_merge();
    init_omap();
    init_pairs();
    init_schema3();
    init_set();
    init_timestamp();
    schemas = /* @__PURE__ */ new Map([
      ["core", schema],
      ["failsafe", [map, seq, string]],
      ["json", schema2],
      ["yaml11", schema3],
      ["yaml-1.1", schema3]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float,
      floatExp,
      floatNaN,
      floatTime,
      int,
      intHex,
      intOct,
      intTime,
      map,
      merge,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:merge": merge,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey, Schema;
var init_Schema = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/schema/Schema.js"() {
    init_identity();
    init_map();
    init_seq();
    init_string();
    init_tags();
    sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    Schema = class _Schema {
      constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema4, sortMapEntries: sortMapEntries3, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.name = typeof schema4 === "string" && schema4 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name, merge3);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries3 === "function" ? sortMapEntries3 : sortMapEntries3 === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
var init_stringifyDocument = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
    init_identity();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document;
var init_Document = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/doc/Document.js"() {
    init_Alias();
    init_Collection();
    init_identity();
    init_Pair();
    init_toJS();
    init_Schema();
    init_stringifyDocument();
    init_anchors();
    init_applyReviver();
    init_createNode();
    init_directives();
    Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name2) {
        if (!node.anchor) {
          const prev = anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? findNewAnchor(name2 || "a", prev) : name2;
        }
        return new Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode(value, tag2, ctx);
        if (flow && isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (isEmptyPath(path))
          return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
        return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (isEmptyPath(path))
          return this.contents !== void 0;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new Directives({ version: version2 });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json2,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js
var YAMLError, YAMLParseError, YAMLWarning, prettifyError;
var init_errors = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/errors.js"() {
    YAMLError = class extends Error {
      constructor(name2, pos, code4, message2) {
        super();
        this.name = name2;
        this.code = code4;
        this.message = message2;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code4, message2) {
        super("YAMLParseError", pos, code4, message2);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code4, message2) {
        super("YAMLWarning", pos, code4, message2);
      }
    };
    prettifyError = (src2, lc) => (error48) => {
      if (error48.pos[0] === -1)
        return;
      error48.linePos = error48.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error48.linePos[0];
      error48.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src2.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src2.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error48.linePos[1];
        if (end?.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error48.message += `:

${lineStr}
${pointer}
`;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag2 = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag2)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag: tag2,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}
var init_resolve_props = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-props.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
var init_util_contains_newline = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
var init_util_flow_indent_check = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
    init_util_contains_newline();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}
var init_util_map_includes = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
    init_identity();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLMap;
  const map3 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map3.comment)
            map3.comment += "\n" + keyProps.comment;
          else
            map3.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map3.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map3.range = [bm.offset, offset, commentEnd ?? offset];
  return map3;
}
var startColMsg;
var init_resolve_block_map = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
    init_Pair();
    init_YAMLMap();
    init_resolve_props();
    init_util_contains_newline();
    init_util_flow_indent_check();
    init_util_map_includes();
    startColMsg = "All mapping items must start at the same column";
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value?.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
var init_resolve_block_seq = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
    init_YAMLSeq();
    init_resolve_props();
    init_util_flow_indent_check();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}
var init_resolve_end = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-end.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag2) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag2?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source?.[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map3 = coll;
        if (mapIncludes(ctx, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map3.items.push(pair);
      } else {
        const map3 = new YAMLMap(ctx.schema);
        map3.flow = true;
        map3.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map3.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map3);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce?.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
var blockMsg, isBlock;
var init_resolve_flow_collection = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
    init_identity();
    init_Pair();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_end();
    init_resolve_props();
    init_util_contains_newline();
    init_util_map_includes();
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag2) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag2) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag2) : resolveFlowCollection(CN2, ctx, token, onError, tag2);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message2 = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message2);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag2 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt?.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag2);
  const res = tag2.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2?.format)
    node.format = tag2.format;
  return node;
}
var init_compose_collection = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-collection.js"() {
    init_identity();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_block_map();
    init_resolve_block_seq();
    init_resolve_flow_collection();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message2);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message2 = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message2);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src2 = header.indent ? "explicit indentation indicator" : "first line";
      const message2 = `Block scalar lines must not be less indented than their ${src2}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error48 = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error48 === -1)
        error48 = offset + i;
    }
  }
  if (error48 !== -1)
    onError(error48, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length2 = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length2 += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message2 = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message2);
        }
        length2 += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length2 += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message2 = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message2);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length2 += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length: length2 };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
var init_resolve_block_scalar = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
    init_Scalar();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code4, msg) => onError(offset + rel, code4, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match2 = first.exec(source);
  if (!match2)
    return source;
  let res = match2[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match2 = line.exec(source)) {
    if (match2[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match2[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match2 = last.exec(source);
  return res + sep + (match2?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length2 = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length2, onError);
        i += length2;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length2, onError) {
  const cc = source.substr(offset, length2);
  const ok = cc.length === length2 && /^[0-9a-fA-F]+$/.test(cc);
  const code4 = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code4)) {
    const raw = source.substr(offset - 2, length2 + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code4);
}
var escapeCodes;
var init_resolve_flow_scalar = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
    init_Scalar();
    init_resolve_end();
    escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag2;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag2 = ctx.schema[SCALAR];
  } else if (tagName)
    tag2 = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag2 = findScalarTagByTest(ctx, value, token, onError);
  else
    tag2 = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error48) {
    const msg = error48 instanceof Error ? error48.message : String(error48);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag2 of schema4.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if (tag2.test?.test(value))
      return tag2;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  const tag2 = schema4.tags.find((tag3) => (tag3.default === true || atKey && tag3.default === "key") && tag3.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema4[SCALAR];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}
var init_compose_scalar = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
    init_identity();
    init_Scalar();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos ?? (pos = before.length);
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
var init_util_empty_scalar_position = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag: tag2 } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message2 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message2);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag2 ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag: tag2, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
var CN;
var init_compose_node = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-node.js"() {
    init_Alias();
    init_identity();
    init_compose_collection();
    init_compose_scalar();
    init_resolve_end();
    init_util_empty_scalar_position();
    CN = { composeNode, composeEmptyNode };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
var init_compose_doc = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/compose-doc.js"() {
    init_Document();
    init_compose_node();
    init_resolve_end();
    init_resolve_props();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src2) {
  if (typeof src2 === "number")
    return [src2, src2 + 1];
  if (Array.isArray(src2))
    return src2.length === 2 ? src2 : [src2[0], src2[1]];
  const { offset, source } = src2;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer;
var init_composer = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/compose/composer.js"() {
    init_directives();
    init_Document();
    init_errors();
    init_identity();
    init_compose_doc();
    init_resolve_end();
    Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code4, message2, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code4, message2));
          else
            this.errors.push(new YAMLParseError(pos, code4, message2));
        };
        this.directives = new Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message2, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message2, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error48 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error48);
            else
              this.doc.errors.push(error48);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code4, message2) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code4, message2);
      else
        throw new YAMLParseError([offset, offset + 1], code4, message2);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var init_cst_scalar = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
    init_errors();
    init_stringifyString();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-stringify.js
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}
var stringify2;
var init_cst_stringify = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
    stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}
var BREAK2, SKIP2, REMOVE2;
var init_cst_visit = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst-visit.js"() {
    BREAK2 = /* @__PURE__ */ Symbol("break visit");
    SKIP2 = /* @__PURE__ */ Symbol("skip children");
    REMOVE2 = /* @__PURE__ */ Symbol("remove item");
    visit2.BREAK = BREAK2;
    visit2.SKIP = SKIP2;
    visit2.REMOVE = REMOVE2;
    visit2.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index2] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index2];
        } else
          return void 0;
      }
      return item;
    };
    visit2.parentCollection = (cst, path) => {
      const parent = visit2.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var BOM, DOCUMENT, FLOW_END, SCALAR2, isCollection2, isScalar2;
var init_cst = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/cst.js"() {
    init_cst_scalar();
    init_cst_stringify();
    init_cst_visit();
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR2 = "";
    isCollection2 = (token) => !!token && "items" in token;
    isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits, tagChars, flowIndicatorChars, invalidAnchorChars, isNotAnchorChar, Lexer;
var init_lexer = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/lexer.js"() {
    init_cst();
    hexDigits = new Set("0123456789ABCDEFabcdef");
    tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    flowIndicatorChars = new Set(",[]{}");
    invalidAnchorChars = new Set(" ,[]{}\n\r	");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield SCALAR2;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR2;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter;
var init_line_counter = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/line-counter.js"() {
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser;
var init_parser = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/parse/parser.js"() {
    init_cst();
    init_lexer();
    Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message2 = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message2, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && top?.type !== "doc-end") {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error48) {
        const token = error48 ?? this.stack.pop();
        if (!token) {
          const message2 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message2 };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map3.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top?.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep)
                this.stack.push(fs);
              else
                Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src2, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src2, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options);
  return new Document(value, _replacer, options).toString(options);
}
var init_public_api = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/public-api.js"() {
    init_composer();
    init_Document();
    init_errors();
    init_log();
    init_identity();
    init_line_counter();
    init_parser();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});
var init_dist = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/dist/index.js"() {
    init_composer();
    init_Document();
    init_Schema();
    init_errors();
    init_Alias();
    init_identity();
    init_Pair();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_cst();
    init_lexer();
    init_line_counter();
    init_parser();
    init_public_api();
    init_visit();
  }
});

// node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/index.js
var browser_default;
var init_browser = __esm({
  "node_modules/.pnpm/yaml@2.8.2/node_modules/yaml/browser/index.js"() {
    init_dist();
    init_dist();
    browser_default = dist_exports;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/is-promise.js
function isPromise(a) {
  const mayBe = a;
  return mayBe instanceof Promise || !!(mayBe && mayBe !== null && typeof mayBe.then === "function" && typeof mayBe.catch === "function" && typeof mayBe.finally === "function");
}
var init_is_promise = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/is-promise.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/bin2text.js
function bin2text(hex3, lineFn, size = 0) {
  const arr = new Uint8Array(hex3.buffer, hex3.byteOffset, hex3.byteLength);
  let cutted = "  ";
  if (size == 0) {
    size = arr.length;
  }
  size = Math.min(size, arr.length);
  const cols = 16;
  for (let line = 0; line < size; line += cols) {
    if (line + cols <= size || arr.length == size) {
    } else {
      line = arr.length - arr.length % cols;
      size = arr.length;
      cutted = ">>";
    }
    const l = [line.toString(16).padStart(4, "0"), cutted];
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        l.push(arr[line + col].toString(16).padStart(2, "0"));
      } else {
        l.push("  ");
      }
      l.push(" ");
    }
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        const ch = arr[line + col];
        l.push(ch >= 32 && ch < 127 ? String.fromCharCode(ch) : ".");
      }
    }
    lineFn(l.join(""));
  }
}
function bin2string(hex3, size = 0) {
  const collector = [];
  bin2text(hex3, (line) => {
    collector.push(line);
  }, size);
  return collector.join("\n");
}
var init_bin2text = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/bin2text.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/future.js
var Future;
var init_future = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/future.js"() {
    init_resolve_once();
    Future = class {
      #promise;
      #resolveFn = () => {
        throw new Error("This Promise is not working as expected.");
      };
      #rejectFn = () => {
        throw new Error("This Promise is not working as expected.");
      };
      ctx;
      constructor(ctx) {
        this.ctx = ctx;
        this.#promise = new Promise((resolve, reject) => {
          this.#resolveFn = resolve;
          this.#rejectFn = reject;
        });
      }
      id = Lazy(() => Math.random().toString(36).substring(2) + Date.now().toString(36));
      asPromise() {
        return this.#promise;
      }
      resolve(value) {
        this.#resolveFn(value);
      }
      reject(reason) {
        this.#rejectFn(reason);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/result.js
function exception2Result(fn) {
  try {
    const res = fn();
    if (isPromise(res)) {
      return res.then((value) => {
        return Result.Is(value) ? value : Result.Ok(value);
      }).catch((e) => Result.Err(e));
    }
    return Result.Is(res) ? res : Result.Ok(res);
  } catch (e) {
    return Result.Err(e);
  }
}
var Result, ResultOK, ResultError;
var init_result = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/result.js"() {
    init_is_promise();
    Result = class _Result {
      static Ok(...args) {
        return args.length >= 1 ? new ResultOK(args[0]) : new ResultOK(void 0);
      }
      static Err(t) {
        if (typeof t === "string") {
          return new ResultError(new Error(t));
        }
        if (_Result.Is(t)) {
          if (t.is_ok()) {
            return new ResultError(new Error("Result Error is Ok"));
          }
          return t;
        }
        return new ResultError(t);
      }
      static Is(t) {
        if (!t) {
          return false;
        }
        if (t instanceof _Result) {
          return true;
        }
        const rt = t;
        if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === "function")) {
          return true;
        }
        return false;
      }
      static AsyncOk(...args) {
        return Promise.resolve(_Result.Ok(...args));
      }
      static AsyncErr(t) {
        return Promise.resolve(_Result.Err(t));
      }
      isOk() {
        return this.is_ok();
      }
      isErr() {
        return this.is_err();
      }
      Ok() {
        return this.unwrap();
      }
      Err() {
        return this.unwrap_err();
      }
    };
    ResultOK = class extends Result {
      _t;
      constructor(t) {
        super();
        this._t = t;
      }
      is_ok() {
        return true;
      }
      is_err() {
        return false;
      }
      unwrap_err() {
        throw new Error("Result is Ok");
      }
      unwrap() {
        return this._t;
      }
    };
    ResultError = class extends Result {
      _error;
      constructor(t) {
        super();
        this._error = t;
      }
      is_ok() {
        return false;
      }
      is_err() {
        return true;
      }
      unwrap() {
        throw new Error(`Result is Err: ${this._error}`);
      }
      unwrap_err() {
        return this._error;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/option.js
var Option, Some, None;
var init_option = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/option.js"() {
    Option = class _Option {
      static Some(...args) {
        return args.length >= 1 ? new Some(args[0]) : new Some(void 0);
      }
      static None() {
        return new None();
      }
      static Is(t) {
        return t instanceof _Option;
      }
      static From(...args) {
        const t = args.length >= 1 ? args[0] : void 0;
        switch (typeof t) {
          case "undefined":
            return new None();
          case "object":
            if (t === null) {
              return new None();
            }
            return new Some(t);
          default:
            return new Some(t);
        }
      }
      toValue() {
        return this.is_some() ? this.unwrap() : void 0;
      }
      IsNone() {
        return this.is_none();
      }
      IsSome() {
        return this.is_some();
      }
      Unwrap() {
        return this.unwrap();
      }
    };
    Some = class extends Option {
      _t;
      constructor(_t) {
        super();
        this._t = _t;
      }
      is_none() {
        return false;
      }
      is_some() {
        return true;
      }
      unwrap() {
        return this._t;
      }
    };
    None = class extends Option {
      is_none() {
        return true;
      }
      is_some() {
        return false;
      }
      unwrap() {
        throw new Error("None.unwrap");
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/lru-map-set.js
function defaultRefresh(param2, map3) {
  if (param2.maxEntries > 0 && map3.size > param2.maxEntries) {
    const toDelete = [];
    let cacheSize = map3.size;
    for (const key of map3.keys()) {
      if (cacheSize > param2.maxEntries) {
        toDelete.push(key);
        cacheSize--;
      } else {
        break;
      }
    }
    for (const key of toDelete) {
      map3.delete(key);
    }
  }
}
var LRUSet, LRUMap;
var init_lru_map_set = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/lru-map-set.js"() {
    LRUSet = class {
      #lruMap;
      constructor(param2 = {}) {
        this.#lruMap = new LRUMap(param2);
      }
      setParam(param2 = {}) {
        this.#lruMap.setParam(param2);
      }
      get size() {
        return this.#lruMap.size;
      }
      has(key) {
        return this.#lruMap.has(key);
      }
      add(key) {
        this.#lruMap.set(key, key);
      }
      delete(key) {
        this.#lruMap.delete(key);
      }
      clear() {
        this.#lruMap.clear();
      }
      forEach(callbackfn) {
        this.#lruMap.forEach((value) => callbackfn(value, value));
      }
      entries() {
        return this.#lruMap.entries();
      }
    };
    LRUMap = class {
      _map = /* @__PURE__ */ new Map();
      param;
      stats = {
        gets: 0,
        puts: 0,
        deletes: 0
      };
      constructor(c = {}) {
        this.param = {
          maxEntries: c.maxEntries || 100,
          maxAge: c.maxAge || 0,
          evict: c.evict || ((param2, _newItem, map3) => param2.maxEntries > 0 && map3.size >= param2.maxEntries),
          refresh: c.refresh || ((param2, map3) => defaultRefresh(param2, map3))
        };
      }
      _onSetFns = /* @__PURE__ */ new Map();
      onSet(fn) {
        const id = Math.random().toString(36);
        this._onSetFns.set(id, fn);
        return () => {
          this._onSetFns.delete(id);
        };
      }
      _onDeleteFns = /* @__PURE__ */ new Map();
      onDelete(fn) {
        const id = Math.random().toString(36);
        this._onDeleteFns.set(id, fn);
        return () => {
          this._onDeleteFns.delete(id);
        };
      }
      touch(key) {
        if (!this._map.has(key)) {
          throw new Error(`key not found in cache: ${key}`);
        }
        const value = this._map.get(key);
        this._map.delete(key);
        this._map.set(key, value);
        return value;
      }
      setParam(param2 = {}) {
        if (param2.evict) {
          this.param.evict = param2.evict;
        }
        if (param2.refresh) {
          this.param.refresh = param2.refresh;
        }
        if (typeof param2.maxEntries === "number") {
          this.param.maxEntries = param2.maxEntries;
        }
        if (typeof param2.maxAge === "number") {
          this.param.maxAge = param2.maxAge;
        }
        this.param.refresh(this.param, this);
      }
      keys() {
        return this._map.keys();
      }
      has(key) {
        return this._map.has(key);
      }
      get size() {
        return this._map.size;
      }
      async getSet(key, createFN) {
        const val = this.get(key);
        if (val) {
          return val;
        } else {
          const val2 = await createFN(key);
          this.set(key, val2);
          return val2;
        }
      }
      get(key) {
        return this.getItem(key)?.value;
      }
      getItem(key) {
        if (this._map.has(key)) {
          this.stats.gets++;
          return this.touch(key);
        }
        return void 0;
      }
      buildItem(item, value) {
        return {
          ...item,
          value
        };
      }
      set(key, value) {
        const update = this._map.has(key);
        let item = this._map.get(key);
        if (update) {
          if (item?.value === value) {
            return;
          }
          this._map.delete(key);
        }
        item = this.buildItem(item, value);
        if (this.param.evict(this.param, value, this)) {
          const k = this._map.keys().next();
          if (!k.done) {
            this._map.delete(k.value);
          }
        }
        this._map.set(key, item);
        this.stats.puts++;
        this._onSetFns.forEach((fn) => fn(key, item?.value, this.buildItemCtx(item, update)));
      }
      buildItemCtx(item, update) {
        return {
          update,
          ref: this,
          stats: this.stats,
          item
        };
      }
      delete(key) {
        if (this._map.has(key)) {
          const item = this._map.get(key);
          this._onDeleteFns.forEach((fn) => fn(key, item?.value, this.buildItemCtx(item, true)));
          this._map.delete(key);
          this.stats.deletes++;
        }
      }
      clear() {
        this._map.forEach((value, key) => {
          const item = this.buildItemCtx(value, true);
          this._onDeleteFns.forEach((fn) => fn(key, item.item.value, item));
          this.stats.deletes++;
        });
        this._map.clear();
      }
      forEach(fn) {
        let idx = 0;
        this._map.forEach((v, k) => {
          fn(v.value, k, { ...this.buildItemCtx(v, false), idx: idx++ });
        });
      }
      *entries() {
        for (const [key, value] of this._map.entries()) {
          yield [key, value.value, this.buildItemCtx(value, true)];
        }
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/to-sorted.js
function toSortedRecursive(arrayOrObject, touchFn, cycleReferences = /* @__PURE__ */ new Set()) {
  function ref() {
    if (cycleReferences.has(arrayOrObject)) {
      return void 0;
    }
    cycleReferences.add(arrayOrObject);
    return true;
  }
  switch (true) {
    case (arrayOrObject === null || arrayOrObject === void 0): {
      touchFn?.(arrayOrObject, "Null");
      return arrayOrObject;
    }
    case arrayOrObject instanceof Date: {
      touchFn?.(arrayOrObject, "Date");
      return arrayOrObject.toISOString();
    }
    case typeof arrayOrObject === "symbol": {
      touchFn?.(arrayOrObject, "Symbol");
      return arrayOrObject.toString();
    }
    case arrayOrObject instanceof Uint8Array:
      touchFn?.(arrayOrObject, "Uint8Array");
      return arrayOrObject;
    case Array.isArray(arrayOrObject):
      touchFn?.(arrayOrObject, "Array");
      return ref() && arrayOrObject.map((i) => toSortedRecursive(i, touchFn, cycleReferences));
    case typeof arrayOrObject === "function":
      touchFn?.(arrayOrObject, "Function");
      return void 0;
    case typeof arrayOrObject === "object":
      return ref() && Object.fromEntries(Object.entries(arrayOrObject).sort(([keyA], [keyB]) => keyA.localeCompare(keyB)).map(([key, value]) => {
        touchFn?.(key, "Key");
        return [key, toSortedRecursive(value, touchFn, cycleReferences)];
      }));
    default:
      switch (typeof arrayOrObject) {
        case "string":
          touchFn?.(arrayOrObject, "String");
          break;
        case "boolean":
          touchFn?.(arrayOrObject, "Boolean");
          break;
        case "bigint":
        case "number":
          touchFn?.(arrayOrObject, "Number");
          break;
      }
      return arrayOrObject;
  }
}
function toSorted(arrayOrObject, touchFn) {
  return toSortedRecursive(arrayOrObject, touchFn, /* @__PURE__ */ new Set());
}
var init_to_sorted = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/to-sorted.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/sorted-object.js
function toSortedArray(set3, touchFn) {
  if (!set3)
    return [];
  return Object.entries(toSorted(set3, touchFn));
}
function toSortedObject(set3, touchFn) {
  if (!set3)
    return set3;
  return Object.fromEntries(toSortedArray(set3, touchFn));
}
var init_sorted_object = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/sorted-object.js"() {
    init_to_sorted();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/keyed-ng.js
var KeyedNg;
var init_keyed_ng = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/keyed-ng.js"() {
    init_lru_map_set();
    init_sorted_object();
    KeyedNg = class {
      opts;
      #map;
      constructor(opts) {
        this.opts = {
          ...opts,
          key2string: opts.key2string ?? ((key) => {
            if (typeof key === "string") {
              return key;
            }
            if (typeof key === "number") {
              return key.toString();
            }
            if (typeof key === "boolean") {
              return key ? "true" : "false";
            }
            return JSON.stringify(toSortedObject(key));
          }),
          ctx: opts.ctx ?? {},
          resetAfter: opts.resetAfter ?? 0
        };
        this.#map = new LRUMap(opts.lru);
      }
      onSet(fn) {
        return this.#map.onSet((_keyStr, item) => {
          fn(item);
        });
      }
      onDelete(fn) {
        return this.#map.onDelete((_keyStr, item) => {
          fn(item);
        });
      }
      setParam(params) {
        this.#map.setParam(params.lru);
      }
      asyncGet(key) {
        return key().then((k) => this.get(k));
      }
      has(keyOfFnKey) {
        if (typeof keyOfFnKey === "function") {
          keyOfFnKey = keyOfFnKey();
        }
        return this.#map.has(this.opts.key2string(keyOfFnKey));
      }
      delete(key) {
        this.#map.delete(this.opts.key2string(key));
      }
      keys() {
        return Array.from(this.#map.entries()).map(([_, item]) => item.givenKey);
      }
      forEach(fn) {
        return this.#map.forEach((item, _, ctx) => {
          fn(item, ctx.idx);
        });
      }
      entries() {
        let idx = 0;
        return Array.from(this.#map.entries()).map(([_, item]) => [item, idx++]);
      }
      getItem(key, ctx) {
        const keyStr = this.opts.key2string(key);
        let item = this.#map.get(keyStr);
        if (!item) {
          item = {
            refKey: keyStr,
            givenKey: key,
            ctx: ctx ?? this.opts.ctx,
            value: void 0
          };
          item.value = this.opts.createValue(item);
          this.#map.set(keyStr, item);
        }
        return item;
      }
      get(key, ctx) {
        if (typeof key === "function") {
          key = key();
        }
        const item = this.getItem(key, ctx);
        return item.value;
      }
      values() {
        return Array.from(this.#map.entries()).map(([_, item]) => item);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/runtime.js
function isSet(value, ref = globalThis) {
  const [head, ...tail] = value.split(".");
  if (["object", "function"].includes(typeof ref) && ref && ["object", "function"].includes(typeof ref[head]) && ref[head]) {
    if (tail.length <= 1) {
      return true;
    }
    return isSet(tail.join("."), ref[head]);
  }
  return false;
}
function runtimeFn() {
  const gt = globalThis;
  let isReactNative = isSet("navigator.product") && typeof gt["navigator"] === "object" && gt["navigator"]["product"] === "ReactNative";
  let isNodeIsh = false;
  if (!isSet("Deno")) {
    isNodeIsh = isSet("process.versions.node") && !isReactNative;
  }
  let isDeno = isSet("Deno");
  const isCFWorker = isSet("caches.default") && isSet("WebSocketPair");
  if (isCFWorker) {
    isDeno = false;
    isNodeIsh = false;
    isReactNative = false;
  }
  return {
    isNodeIsh,
    isBrowser: !(isNodeIsh || isDeno || isCFWorker || isReactNative),
    isDeno,
    isReactNative,
    isCFWorker
  };
}
var init_runtime = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/runtime.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/resolve-once.js
function isAsyncResolveOnce(obj) {
  return obj.IsSome() && obj.Unwrap() instanceof AsyncResolveOnce;
}
function Lazy(fn, opts) {
  const lazy2 = new LazyContainer(opts);
  return lazy2.call(fn);
}
var ResolveSeq, SyncResolveOnce, AsyncResolveItem, AsyncResolveOnce, StateInstance, ResolveOnce, KeyedResolvOnce, LazyContainer;
var init_resolve_once = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/resolve-once.js"() {
    init_future();
    init_is_promise();
    init_result();
    init_option();
    init_keyed_ng();
    init_runtime();
    ResolveSeq = class {
      ctx;
      _seqFutures = [];
      constructor(ctx) {
        this.ctx = ctx;
      }
      reset() {
      }
      _flushWaiting = [];
      flush() {
        if (this._seqFutures.length > 0) {
          const waitForFlush = new Future();
          this._flushWaiting?.push(waitForFlush);
          return waitForFlush.asPromise();
        }
        return Promise.resolve();
      }
      async _step(item) {
        if (!item) {
          this._flushWaiting.forEach((f) => f.resolve());
          this._flushWaiting?.splice(0, this._flushWaiting.length);
          return Promise.resolve();
        }
        let value;
        try {
          const promiseOrValue = item.fn(this.ctx ?? {});
          if (isPromise(promiseOrValue)) {
            value = await promiseOrValue;
          } else {
            value = promiseOrValue;
          }
          item.future.resolve(value);
        } catch (e) {
          item.future.reject(e);
        } finally {
          this._seqFutures.shift();
        }
        return this._step(this._seqFutures[0]);
      }
      add(fn, id) {
        const future = new Future();
        this._seqFutures.push({ future, fn, id });
        if (this._seqFutures.length === 1) {
          void this._step(this._seqFutures[0]);
        }
        return future.asPromise();
      }
    };
    SyncResolveOnce = class {
      #value;
      #error;
      queueLength = 0;
      #state;
      #rOnce;
      constructor(rOnce, state) {
        this.#state = state;
        this.#rOnce = rOnce;
      }
      get value() {
        return this.#value;
      }
      get error() {
        return this.#error;
      }
      get ready() {
        return this.#state.isProcessed();
      }
      resolve(fn) {
        if (this.#state.isProcessing()) {
          try {
            this.#value = fn();
          } catch (e) {
            this.#error = e;
          } finally {
            this.#state.setProcessed();
            this.#rOnce.setProcessed(this.#state);
          }
          if (isPromise(this.#value)) {
            throw new Error("SyncResolveOnce.once fn returned a promise");
          }
        }
        if (this.#error) {
          throw this.#error;
        }
        return this.#value;
      }
    };
    AsyncResolveItem = class {
      id = Math.random();
      #toResolve;
      #value = Option.None();
      #error;
      #state;
      #rOnce;
      constructor(fn, rOnce, state) {
        this.#toResolve = fn;
        this.#state = state;
        this.#rOnce = rOnce;
      }
      get value() {
        return this.#value.IsSome() ? this.#value.unwrap() : void 0;
      }
      get error() {
        return this.#error;
      }
      #queue = [];
      get queuelength() {
        return this.#queue.length;
      }
      isDisposable() {
        return this.#state.isProcessed() && this.#queue.length === 0;
      }
      #resolveFuture(future) {
        if (!future) {
          return;
        }
        if (this.#error) {
          future.reject(this.#error);
          return;
        }
        if (this.#value.IsSome()) {
          future.resolve(this.#value.Unwrap());
        }
      }
      #promiseResult() {
        if (this.#error) {
          return Promise.reject(this.#error);
        }
        if (this.#value.IsSome()) {
          return Promise.resolve(this.#value.Unwrap());
        }
        throw new Error(`AsyncResolveItem.#promiseResult impossible: ${this.#state.getResolveState()}`);
      }
      resolve(_fn) {
        if (this.#state.isWaiting()) {
          const future = new Future();
          this.#queue.push(future);
          this.#toResolve.then((value) => {
            this.#value = Option.Some(value);
          }).catch((e) => {
            this.#error = e;
          }).finally(() => {
            this.#state.setProcessed();
            this.#rOnce.setProcessed(this.#state);
            while (this.#queue.length > 0) {
              this.#resolveFuture(this.#queue.shift());
            }
          });
          return future.asPromise();
        }
        if (this.#state.isProcessed()) {
          return this.#promiseResult();
        }
        throw new Error(`AsyncResolveItem.resolve impossible: ${this.#state.getResolveState()}`);
      }
    };
    AsyncResolveOnce = class {
      #state;
      #queue;
      #rOnce;
      constructor(rOnce, state, prev) {
        this.#state = state;
        this.#rOnce = rOnce;
        if (isAsyncResolveOnce(prev)) {
          this.#queue = [...prev.unwrap().#queue];
        } else {
          this.#queue = [];
        }
      }
      #active() {
        const r = this.#queue[this.#queue.length - 1];
        if (!r) {
          throw new Error("AsyncResolveOnce.#active impossible");
        }
        return r;
      }
      get queueLength() {
        return this.#queue.reduce((acc, r) => acc + r.queuelength, this.#queue.length);
      }
      get value() {
        if (this.#state.isInitial()) {
          return void 0;
        }
        return this.#active().value;
      }
      get error() {
        if (this.#state.isInitial()) {
          return void 0;
        }
        return this.#active().error;
      }
      resolve(fn) {
        if (this.#state.isProcessing()) {
          this.#state.setWaiting();
          let promiseResult;
          try {
            const couldBePromise = fn();
            if (!isPromise(couldBePromise)) {
              promiseResult = Promise.resolve(couldBePromise);
            } else {
              promiseResult = couldBePromise;
            }
          } catch (e) {
            promiseResult = Promise.reject(e);
          }
          this.#queue.push(new AsyncResolveItem(promiseResult, this.#rOnce, this.#state));
        }
        this.#queue.slice(0, -1).map((i, idx) => i.isDisposable() ? idx : void 0).filter((i) => i !== void 0).reverse().forEach((idx) => this.#queue.splice(idx, 1));
        return this.#active().resolve(fn);
      }
    };
    StateInstance = class {
      id = Math.random();
      #state = "initial";
      getResolveState() {
        return this.#state;
      }
      isInitial() {
        return this.#state === "initial";
      }
      isProcessed() {
        return this.#state === "processed";
      }
      setProcessed() {
        this.#state = "processed";
      }
      isProcessing() {
        return this.#state === "processing";
      }
      setProcessing() {
        this.#state = "processing";
      }
      isWaiting() {
        return this.#state === "waiting";
      }
      setWaiting() {
        this.#state = "waiting";
      }
      equals(other) {
        return this.id === other.id;
      }
    };
    ResolveOnce = class {
      #state = new StateInstance();
      #syncOrAsync = Option.None();
      #opts;
      resetAfterTimer;
      _onceArg;
      constructor(ctx, opts) {
        this.#opts = { ...opts ?? {} };
        this._onceArg = {
          ctx,
          self: this
        };
      }
      get state() {
        return this.#state.getResolveState();
      }
      setProcessed(state) {
        if (this.resetAfterTimer) {
          clearTimeout(this.resetAfterTimer);
        }
        if (this.#state.equals(state)) {
          this.#state.setProcessed();
          if (typeof this.#opts.resetAfter === "number" && this.#opts.resetAfter > 0) {
            this.resetAfterTimer = setTimeout(() => {
              void this.reset();
            }, this.#opts.resetAfter);
            if (!this.#opts.skipUnref && this.resetAfterTimer) {
              const runtime = runtimeFn();
              switch (true) {
                case runtime.isDeno:
                  {
                    let id = this.resetAfterTimer;
                    if (typeof Deno.unrefTimer === "function") {
                      if (typeof this.resetAfterTimer === "number") {
                        id = this.resetAfterTimer;
                      } else {
                        try {
                          const ret = Reflect.ownKeys(this.resetAfterTimer).find((key) => {
                            return key.toString().includes("timerId");
                          });
                          if (ret) {
                            id = this.resetAfterTimer[ret];
                            console.warn("Deno.unrefTimer timerId from struct:", id, "version:", globalThis.Deno?.version);
                          }
                        } catch (e) {
                          console.warn("Deno.unrefTimer failed to get timerId", e, "id:", this.resetAfterTimer, "version:", globalThis.Deno?.version);
                        }
                      }
                      Deno.unrefTimer(id);
                    }
                  }
                  break;
                case runtime.isNodeIsh:
                  this.resetAfterTimer.unref();
                  break;
              }
            }
          }
        }
      }
      get ready() {
        return !this.#state.isInitial();
      }
      get value() {
        if (this.#state.isInitial()) {
          return void 0;
        }
        return this.#syncOrAsync.Unwrap().value;
      }
      get queueLength() {
        if (this.#state.isInitial()) {
          return 0;
        }
        return this.#syncOrAsync.Unwrap().queueLength;
      }
      get error() {
        if (this.#state.isInitial()) {
          return void 0;
        }
        return this.#syncOrAsync.Unwrap().error;
      }
      once(fn) {
        let resultFn;
        if (this.#state.isInitial()) {
          const state = this.#state;
          try {
            state.setProcessing();
            const isSyncOrAsync = fn(this._onceArg);
            if (isPromise(isSyncOrAsync)) {
              this.#syncOrAsync = Option.Some(new AsyncResolveOnce(this, state, this.#syncOrAsync));
            } else {
              this.#syncOrAsync = Option.Some(new SyncResolveOnce(this, state));
            }
            resultFn = () => isSyncOrAsync;
          } catch (e) {
            this.#syncOrAsync = Option.Some(new SyncResolveOnce(this, state));
            resultFn = () => {
              throw e;
            };
          }
        } else {
          resultFn = () => fn(this._onceArg);
        }
        if (!this.#syncOrAsync) {
          throw new Error(`ResolveOnce.once impossible: state=${this.#state.getResolveState()}`);
        }
        return this.#syncOrAsync.Unwrap().resolve(resultFn);
      }
      reset(fn) {
        if (this.#state.isInitial()) {
          if (!fn) {
            return void 0;
          }
          return this.once(fn);
        }
        if (this.#state.isProcessing()) {
          console.warn("ResolveOnce.reset dropped was called while processing");
          return void 0;
        }
        let ret = void 0;
        this.#state = new StateInstance();
        if (fn) {
          ret = this.once(fn);
        }
        return ret;
      }
      setResetAfter(ms) {
        if (this.resetAfterTimer) {
          clearTimeout(this.resetAfterTimer);
        }
        if (typeof ms === "number" && ms > 0) {
          this.#opts.resetAfter = ms;
        } else {
          this.#opts.resetAfter = void 0;
        }
      }
    };
    KeyedResolvOnce = class {
      _keyed;
      constructor(kp = {}) {
        this._keyed = new KeyedNg({
          createValue: (item) => {
            return new ResolveOnce({
              ...item,
              ctx: kp.ctx ?? item.ctx
            }, {
              resetAfter: kp.resetAfter
            });
          },
          key2string: kp.key2string,
          ctx: kp.ctx,
          lru: kp.lru
        });
      }
      keys() {
        return this._keyed.keys();
      }
      values() {
        return this._keyed.values().filter((i) => i.value.ready).map((item) => ({
          key: item.givenKey,
          value: item.value.error ? Result.Err(item.value.error) : Result.Ok(item.value.value),
          item
        }));
      }
      onSet(fn) {
        return this._keyed.onSet((item) => {
          fn(item.givenKey, item.value);
        });
      }
      onDelete(fn) {
        return this._keyed.onDelete((item) => {
          fn(item.givenKey, item.value);
        });
      }
      setParam(params) {
        this._keyed.setParam({ lru: params.lru });
      }
      asyncGet(key) {
        return this._keyed.asyncGet(key);
      }
      get(key, ctx) {
        if (typeof key === "function") {
          key = key();
        }
        return this._keyed.getItem(key, ctx).value;
      }
      getItem(key, ctx) {
        return this._keyed.getItem(key, ctx);
      }
      has(key) {
        return this._keyed.has(key);
      }
      delete(key) {
        this._keyed.delete(key);
      }
      unget(key) {
        const item = this._keyed.getItem(key);
        void item.value.reset?.();
        return this._keyed.delete(item.givenKey);
      }
      reset() {
        for (const v of this._keyed.values()) {
          void v.value.reset?.();
        }
      }
      forEach(fn) {
        for (const [item, idx] of this._keyed.entries()) {
          const v = item.value;
          const k = item.givenKey;
          if (!v.ready) {
            continue;
          }
          if (v.error) {
            fn({ key: k, value: Result.Err(v.error) }, idx);
          } else {
            fn({ key: k, value: Result.Ok(v.value) }, idx);
          }
        }
      }
      *entries() {
        for (const [item] of this._keyed.entries()) {
          const v = item.value;
          const k = item.givenKey;
          if (!v.ready) {
            continue;
          }
          if (v.error) {
            yield { key: k, value: Result.Err(v.error) };
          } else {
            yield { key: k, value: Result.Ok(v.value) };
          }
        }
      }
    };
    LazyContainer = class {
      resolveOnce;
      constructor(opts) {
        this.resolveOnce = new ResolveOnce(void 0, opts);
      }
      call(fn) {
        return (...args) => this.resolveOnce.once(() => fn(...args));
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/coerce-uint8.js
function coerceIntoUint8(raw) {
  if (raw instanceof ArrayBuffer) {
    return Result.Ok(new Uint8Array(raw));
  }
  if (ArrayBuffer.isView(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Blob) {
    return Result.Err("Blob not supported");
  }
  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    if (raw.isErr()) {
      return Result.Err(raw);
    }
    return coerceIntoUint8(raw.unwrap());
  }
  return Result.Err("Not a Uint8Array");
}
var globalBuffer;
var init_coerce_uint8 = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/coerce-uint8.js"() {
    init_esm();
    globalBuffer = globalThis;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/txt-en-decoder.js
var TxtOps, TxtEnDecoderSingleton;
var init_txt_en_decoder = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/txt-en-decoder.js"() {
    init_resolve_once();
    init_result();
    init_coerce_uint8();
    TxtOps = class {
      encoder = new TextEncoder();
      decoder = new TextDecoder();
      encode(str) {
        return this.encoder.encode(str);
      }
      decode(data) {
        if (!data) {
          return "";
        }
        if (Result.Is(data)) {
          if (data.isErr()) {
            throw data.Err();
          }
          const unwrapped = data.unwrap();
          if (typeof unwrapped === "string") {
            return this.decode(unwrapped);
          }
        }
        if (typeof data === "string") {
          return data;
        }
        return this.decoder.decode(coerceIntoUint8(data).Ok());
      }
      async asyncDecode(data) {
        if (!data) {
          return "";
        }
        let resolved = await data;
        if (resolved instanceof Blob) {
          resolved = await resolved.arrayBuffer();
        }
        return this.decode(resolved);
      }
    };
    TxtEnDecoderSingleton = Lazy(() => new TxtOps());
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/is-json.js
function isJSON(str) {
  if (possibleJSONre.test(str)) {
    try {
      const parsed = JSON.parse(str);
      return { isJSON: true, parsed };
    } catch {
    }
  }
  return { isJSON: false };
}
var possibleJSONre;
var init_is_json = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/is-json.js"() {
    possibleJSONre = new RegExp('^\\s*(?:\\{.*\\}|\\[.*\\]|"(?:[^"\\\\]|\\\\.)*"|true|false|null|-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s*$');
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/types.js
var _Required, _Optional, param, hasHostPartProtocols, Level, LogValue;
var init_types = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/types.js"() {
    _Required = class {
      type = "REQUIRED";
    };
    _Optional = class {
      type = "OPTIONAL";
    };
    param = {
      REQUIRED: new _Required(),
      OPTIONAL: new _Optional()
    };
    hasHostPartProtocols = /* @__PURE__ */ new Set(["http", "https", "ws", "wss"]);
    Level = {
      WARN: "warn",
      DEBUG: "debug",
      INFO: "info",
      ERROR: "error"
    };
    LogValue = class {
      fn;
      constructor(fn) {
        this.fn = fn;
      }
      value() {
        try {
          return this.fn();
        } catch (e) {
          return `LogValue:${e.message}`;
        }
      }
      toJSON() {
        return this.value();
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/mutable-url.js
function* URLSearchParamsEntries(src2) {
  const entries4 = [];
  src2.forEach((v, k) => {
    entries4.push([k, v]);
  });
  for (const [key, value] of entries4) {
    yield [key, value];
  }
}
var customInspectSymbol, urlRegex, ReadonlyURL, WritableURL;
var init_mutable_url = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/mutable-url.js"() {
    init_result();
    init_types();
    customInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
    urlRegex = /^([a-z][a-z0-9_-]*):\/\/[^:]*$/i;
    ReadonlyURL = class _ReadonlyURL extends URL {
      _sysURL;
      _protocol;
      _pathname;
      _hasHostpart;
      static fromThrow = (urlStr) => {
        return new _ReadonlyURL(urlStr);
      };
      static from(urlStr) {
        if (urlRegex.test(urlStr)) {
          return exception2Result(() => new _ReadonlyURL(urlStr));
        }
        return Result.Err(`Invalid URL: ${urlStr}`);
      }
      constructor(urlStr) {
        super("defect://does.not.exist");
        const partedURL = urlStr.split(":");
        this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);
        let hostPartUrl = ["http", ...partedURL.slice(1)].join(":");
        if (!this._hasHostpart) {
          const pathname = hostPartUrl.replace(/http:\/\/[/]*/, "").replace(/[#?].*$/, "");
          hostPartUrl = hostPartUrl.replace(/http:\/\//, `http://localhost/${pathname}`);
        }
        try {
          this._sysURL = new URL(hostPartUrl);
        } catch (ie) {
          const e = ie;
          e.message = `${e.message} for URL: ${urlStr}`;
          throw e;
        }
        this._protocol = `${partedURL[0]}:`;
        if (this._hasHostpart) {
          this._pathname = this._sysURL.pathname;
        } else {
          this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), "").replace(/[#?].*$/, "");
        }
      }
      set origin(h) {
        throw new Error("origin is readonly");
      }
      get href() {
        return this.toString();
      }
      set href(h) {
        throw new Error("href is readonly");
      }
      get password() {
        return this._sysURL.password;
      }
      set password(h) {
        throw new Error("password is readonly");
      }
      get username() {
        return this._sysURL.username;
      }
      set username(h) {
        throw new Error("username is readonly");
      }
      toJSON() {
        return this.toString();
      }
      [customInspectSymbol]() {
        return this.toString();
      }
      clone() {
        return this;
      }
      get hash() {
        return this._sysURL.hash;
      }
      set hash(h) {
        throw new Error("hash is readonly");
      }
      get host() {
        if (!this._hasHostpart) {
          throw new Error(`you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.host;
      }
      set host(h) {
        throw new Error("host is readonly");
      }
      get hostname() {
        if (!this._hasHostpart) {
          throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.hostname;
      }
      set hostname(h) {
        throw new Error("hostname is readonly");
      }
      get pathname() {
        return this._pathname;
      }
      set pathname(h) {
        throw new Error("pathname is readonly");
      }
      get port() {
        if (!this._hasHostpart) {
          throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.port;
      }
      set port(h) {
        throw new Error("port is readonly");
      }
      get protocol() {
        return this._protocol;
      }
      set protocol(h) {
        throw new Error("protocol is readonly");
      }
      get search() {
        let search = "";
        if (this._sysURL.searchParams.size) {
          for (const [key, value] of Array.from(URLSearchParamsEntries(this._sysURL.searchParams)).sort((a, b) => a[0].localeCompare(b[0]))) {
            search += `${!search.length ? "?" : "&"}${key}=${encodeURIComponent(value)}`;
          }
        }
        return search;
      }
      set search(h) {
        throw new Error("search is readonly");
      }
      get searchParams() {
        return this._sysURL.searchParams;
      }
      set searchParams(h) {
        throw new Error("searchParams is readonly");
      }
      toString() {
        const search = this.search;
        let hostpart = "";
        if (this._hasHostpart) {
          hostpart = this._sysURL.hostname;
          if (this._sysURL.port) {
            hostpart += `:${this._sysURL.port}`;
          }
          if (!this._pathname.startsWith("/")) {
            hostpart += "/";
          }
        }
        if (this.username || this.password) {
          hostpart = `${this.username}:${this.password}@${hostpart}`;
        }
        return `${this._protocol}//${hostpart}${this._pathname}${search}${this.hash}`;
      }
    };
    WritableURL = class _WritableURL extends ReadonlyURL {
      static fromThrow = (urlStr) => {
        return new _WritableURL(urlStr);
      };
      static from(urlStr) {
        if (urlRegex.test(urlStr)) {
          return exception2Result(() => new _WritableURL(urlStr));
        }
        return Result.Err(`Invalid URL: ${urlStr}`);
      }
      constructor(urlStr) {
        super(urlStr);
      }
      toJSON() {
        return this.toString();
      }
      [customInspectSymbol]() {
        return this.toString();
      }
      clone() {
        return new _WritableURL(this.toString());
      }
      set origin(_h) {
        throw new Error("don't use origin");
      }
      get href() {
        return super.href;
      }
      set href(h) {
        throw new Error("don't use href");
      }
      get password() {
        return super.password;
      }
      set password(h) {
        this._sysURL.password = h;
      }
      get username() {
        return super.username;
      }
      set username(h) {
        this._sysURL.username = h;
      }
      get hash() {
        return super.hash;
      }
      set hash(h) {
        this._sysURL.hash = h;
      }
      get host() {
        return super.host;
      }
      set host(h) {
        this._sysURL.host = h;
      }
      get hostname() {
        return super.hostname;
      }
      set hostname(h) {
        if (!this._hasHostpart) {
          throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        this._sysURL.hostname = h;
      }
      get pathname() {
        return super.pathname;
      }
      set pathname(p) {
        this._pathname = p;
      }
      get port() {
        return super.port;
      }
      set port(p) {
        if (!this._hasHostpart) {
          throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        this._sysURL.port = p;
      }
      get protocol() {
        return super.protocol;
      }
      set protocol(p) {
        if (!p.endsWith(":")) {
          p = `${p}:`;
        }
        this._protocol = p;
      }
      get search() {
        return super.search;
      }
      set search(h) {
        this._sysURL.search = h;
      }
      get searchParams() {
        return super.searchParams;
      }
      set searchParams(h) {
        const toDel = /* @__PURE__ */ new Set();
        for (const [key] of URLSearchParamsEntries(this._sysURL.searchParams)) {
          toDel.add(key);
        }
        for (const [key, value] of URLSearchParamsEntries(h)) {
          this._sysURL.searchParams.set(key, value);
          toDel.delete(key);
        }
        for (const key of toDel) {
          this._sysURL.searchParams.delete(key);
        }
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/logger.js
function logValue(val, ctx) {
  return logValueInternal(val, {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  });
}
function logValueInternal(val, ctx) {
  ctx = {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  };
  switch (typeof val) {
    case "function":
      return new LogValue(val);
    case "string": {
      const resIsJson = isJSON(val);
      if (resIsJson.isJSON) {
        const ret = resIsJson.parsed;
        if (typeof ret === "object" && ret !== null) {
          return logValueInternal(ret, ctx);
        }
      }
      const resIsURI = ReadonlyURL.from(val);
      if (resIsURI.isOk()) {
        return new LogValue(() => resIsURI.Ok().toString());
      }
      if (val.match(/[\n\r]/)) {
        const lines = val.split(/[\n\r]+/).map((v) => v.trim());
        return new LogValue(() => lines);
      }
      return new LogValue(() => val.toString());
    }
    case "number":
      return new LogValue(() => val);
    case "boolean":
      return new LogValue(() => val);
    case "object": {
      if (val === null) {
        return new LogValue(() => "null");
      }
      if (ArrayBuffer.isView(val)) {
        try {
          const decoder2 = TxtEnDecoderSingleton();
          const asStr = decoder2.decode(val);
          const resIsJson = isJSON(asStr);
          if (resIsJson.isJSON) {
            const obj = JSON.parse(asStr);
            return logValueInternal(obj, ctx);
          }
        } catch (e) {
        }
        return logValueInternal(bin2string(val, 512), ctx);
      }
      if (Array.isArray(val)) {
        return new LogValue(() => val.map((v) => logValue(v, { ...ctx, state: void 0 }).value()));
      }
      if (val instanceof Headers) {
        const headers = {};
        val.forEach((v, k) => {
          headers[k] = v;
        });
        return new LogValue(() => headers);
      }
      if (val instanceof ReadableStream) {
        return new LogValue(() => ">Stream<");
      }
      if (isPromise(val)) {
        return new LogValue(() => ">Promise<");
      }
      if (ctx.state?.has(val)) {
        return new LogValue(() => "...");
      }
      ctx.state?.add(val);
      try {
        if (typeof val.toJSON === "function") {
          return new LogValue(() => val.toJSON());
        }
      } catch (e) {
      }
      const res = {};
      const typedVal = val;
      for (const key in typedVal) {
        if (ctx.ignoreAttr.IsSome() && ctx.ignoreAttr.unwrap().test(key)) {
          continue;
        }
        const element = typedVal[key];
        if (element instanceof LogValue) {
          res[key] = element;
        } else {
          if (typeof element !== "function") {
            res[key] = logValueInternal(element, ctx);
          }
        }
      }
      return new LogValue(() => res);
    }
    default:
      if (!val) {
        return new LogValue(() => "--Falsy--");
      }
      throw new Error(`Invalid type:${typeof val}`);
  }
}
function IsLogger(obj) {
  return typeof obj === "object" && [
    "Module",
    "EnableLevel",
    "DisableLevel",
    "SetDebug",
    "Str",
    "Error",
    "Warn",
    "Debug",
    "Log",
    "WithLevel",
    "Err",
    "Info",
    "Timestamp",
    "Any",
    "Dur",
    "Uint64"
  ].map((fn) => typeof obj[fn] === "function").reduce((a, b) => a && b, true);
}
var init_logger = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/logger.js"() {
    init_is_promise();
    init_bin2text();
    init_txt_en_decoder();
    init_is_json();
    init_mutable_url();
    init_types();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/relative-path.js
function splitPath(path) {
  const p = new Path();
  if (path === "") {
    return p;
  }
  for (let count = 0; path.length; count++) {
    if (path.match(/^\/+/)) {
      if (count === 0) {
        p.add(PartType.Root);
      } else {
        p.add(PartType.Slash);
      }
      path = path.replace(/^\/+/, "");
    } else {
      const part = path.replace(/\/.*$/, "");
      p.add(part);
      path = path.replace(/^[^/]+/, "");
    }
  }
  return p;
}
function pathJoin(...paths) {
  let prev = "";
  const res = [];
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path === "") {
      continue;
    }
    if (!(prev.endsWith("/") || path.startsWith("/"))) {
      if (prev !== "") {
        res.push("/");
      }
      res.push(path);
    } else {
      res.push(path);
    }
    prev = path;
  }
  return res.join("");
}
function relativePath(path, relative) {
  const relativeParts = splitPath(relative);
  let result;
  if (relativeParts.parts[0] === PartType.Root) {
    result = relative;
  } else {
    result = pathJoin(path, relative);
  }
  const unoptPath = splitPath(result);
  const out = [];
  let topUp = false;
  for (const part of unoptPath.parts) {
    switch (part) {
      case PartType.Root:
        out.push(PartType.Root);
        break;
      case PartType.Up:
        if (out.length && !topUp) {
          const last = out.length - 1;
          if (typeof out[last] === "string" && out[last - 1] == PartType.Root) {
            out.pop();
          } else {
            out.pop();
            out.pop();
          }
          if (out.length === 0) {
            topUp = !topUp ? true : topUp;
            out.push(PartType.Up);
          }
        } else {
          out.push(PartType.Up);
        }
        break;
      case PartType.Slash:
        if (!(out[out.length - 1] & PartType.Slash)) {
          out.push(PartType.Slash);
        }
        break;
      default:
        out.push(part);
        break;
    }
  }
  return new Path(out).toString();
}
var PartType, Path;
var init_relative_path = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/relative-path.js"() {
    PartType = {
      Slash: 1,
      Root: 3,
      Up: 4,
      Noop: 8
    };
    Path = class {
      parts;
      constructor(parts = []) {
        this.parts = parts;
      }
      toString() {
        return this.parts.map((part) => {
          if (typeof part === "string") {
            return part;
          } else {
            switch (part) {
              case PartType.Slash:
              case PartType.Root:
                return "/";
              case PartType.Up:
                return "..";
              default:
                return part;
            }
          }
        }).join("");
      }
      add(part) {
        if (this.parts.includes(PartType.Root) && part === PartType.Root) {
          throw new Error("Cannot add absolute part to absolute path");
        }
        const last = this.parts[this.parts.length - 1];
        if (last & PartType.Slash && part === PartType.Slash) {
          return;
        }
        switch (part) {
          case ".":
            this.parts.push(PartType.Noop);
            return;
          case "..":
            part = PartType.Up;
        }
        if (last === PartType.Noop && part === PartType.Slash) {
          if (last === PartType.Noop) {
            this.parts.pop();
          }
          return;
        }
        this.parts.push(part);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stripper.js
function stripper(strip, obj) {
  const strips = Array.isArray(strip) ? strip : [strip];
  const restrips = strips.map((s) => {
    if (typeof s === "string") {
      const escaped = s.replace(/[-\\[\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\^\\$\\|]/g, "\\$&");
      return new RegExp(`^${escaped}$`);
    }
    return s;
  });
  const selfRef = /* @__PURE__ */ new WeakSet();
  return localStripper(void 0, restrips, obj, selfRef);
}
function localStripper(path, restrips, obj, selfRef) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (selfRef.has(obj)) {
    return obj;
  }
  selfRef.add(obj);
  if (Array.isArray(obj)) {
    return obj.map((i) => localStripper(path, restrips, i, selfRef));
  }
  const ret = { ...obj };
  const matcher = (key, nextPath) => {
    for (const re of restrips) {
      if (re.test(key) || re.test(nextPath)) {
        return true;
      }
    }
    return false;
  };
  for (const key in ret) {
    if (Object.prototype.hasOwnProperty.call(ret, key)) {
      let nextPath;
      if (path) {
        nextPath = [path, key].join(".");
      } else {
        nextPath = key;
      }
      if (matcher(key, nextPath)) {
        delete ret[key];
        continue;
      }
      if (typeof ret[key] === "object") {
        if (Array.isArray(ret[key])) {
          ret[key] = ret[key].reduce((acc, v, i) => {
            const toDelete = matcher(key, `${nextPath}[${i}]`);
            if (!toDelete) {
              acc.push(localStripper(`${nextPath}[${i}]`, restrips, v, selfRef));
            }
            return acc;
          }, []);
        } else {
          ret[key] = localStripper(nextPath, restrips, ret[key], selfRef);
        }
      }
    }
  }
  return ret;
}
var init_stripper = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stripper.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/uri.js
function match(iref, ioth) {
  const mr = {
    score: 0,
    protocol: false,
    hostname: false,
    port: false,
    pathname: false,
    pathParts: [],
    params: {}
  };
  const ref = URI.from(iref);
  const oth = URI.from(ioth);
  if (ref.protocol === oth.protocol) {
    mr.score += 1;
    mr.protocol = true;
  }
  try {
    const refH = ref.hostname;
    const refP = ref.port;
    if (refH === oth.hostname) {
      mr.score += 1;
      mr.hostname = true;
    }
    if (refP.length && refP === oth.port) {
      mr.score += 1;
      mr.port = true;
    }
  } catch (_e) {
  }
  if (ref.pathname.length && ref.pathname !== "/") {
    const pref = ref.pathname.split("/").filter((p) => p.length);
    const poth = oth.pathname.split("/").filter((p) => p.length);
    for (let i = 0; i < pref.length && i < poth.length; i++) {
      if (poth[i] === pref[i]) {
        mr.score += 1;
        mr.pathname = true;
        mr.pathParts.push(pref[i]);
      }
    }
  }
  for (const [key, value] of ref.getParams) {
    if (oth.getParam(key) === value) {
      mr.score += 1;
      mr.params[key] = value;
    }
  }
  return mr;
}
function coerceKey(key, def) {
  if (typeof key === "object") {
    const keys = Object.keys(key);
    if (keys.length !== 1) {
      throw new Error(`Invalid key: ${JSON.stringify(key)}`);
    }
    return { key: keys[0], def: key[keys[0]] };
  }
  return { key, def };
}
function resolveHash(hash2) {
  const searchParams = new URLSearchParams(hash2.replace(/^#/, ""));
  return {
    getParam: (k) => {
      const ret = searchParams.get(k);
      return ret === null ? void 0 : ret;
    }
  };
}
function falsy2undef(value) {
  return value === void 0 || value === null ? void 0 : value;
}
function ensureURLWithDefaultProto(url2, defaultProtocol, action) {
  if (!url2) {
    return action.fromThrow(`${defaultProtocol}//`);
  }
  if (typeof url2 === "string") {
    try {
      return action.fromThrow(url2);
    } catch (_e) {
      return action.fromThrow(`${defaultProtocol}//${url2}`);
    }
  } else {
    return action.fromThrow(url2.toString());
  }
}
function isURL(value) {
  return value instanceof URL || !!value && typeof value.searchParams === "object" && typeof value.searchParams.sort === "function" && typeof value.hash === "string";
}
function from(fac, strURLUri, defaultProtocol, action) {
  switch (typeof falsy2undef(strURLUri)) {
    case "undefined":
      return fac(action.fromThrow(`${defaultProtocol}///`));
    case "string":
      return fac(ensureURLWithDefaultProto(strURLUri, defaultProtocol, action));
    case "object":
      if (BuildURI.is(strURLUri)) {
        return fac(action.fromThrow(strURLUri._url.toString()));
      } else if (URI.is(strURLUri)) {
        return fac(action.fromThrow(strURLUri._url.toString()));
      } else if (isURL(strURLUri)) {
        return fac(action.fromThrow(strURLUri.toString()));
      }
      throw new Error(`unknown object type: ${strURLUri}`);
    default:
      throw new Error(`Invalid argument: ${typeof strURLUri}`);
  }
}
function getParamResult(key, val, msgFn = (key2) => {
  return `missing parameter: ${key2}`;
}) {
  if (val === void 0) {
    return Result.Err(msgFn(key));
  }
  return Result.Ok(val);
}
function setParams(src2, val, mode = "reset", out = new URLSearchParams("")) {
  let preset;
  switch (mode) {
    case "reset":
      preset = {};
      break;
    case "merge":
    default:
      preset = Object.fromEntries(URLSearchParamsEntries(new URLSearchParams(src2)));
      break;
  }
  for (const [key, value] of Object.entries({ ...preset, ...val }).sort((a, b) => a[0].localeCompare(b[0]))) {
    switch (typeof value) {
      case "string":
        out.set(key, value);
        break;
      case "number":
        out.set(key, value.toString());
        break;
      case "boolean":
        out.set(key, value ? "true" : "false");
        break;
      default:
        if (value instanceof Date) {
          out.set(key, value.toISOString());
        } else {
          console.error(`unsupported type: ${typeof value} ignore key: ${key}`);
        }
        break;
    }
  }
  return out.toString();
}
function isCoerceURI(value) {
  if (!value) {
    return false;
  }
  if (isURL(value)) {
    return true;
  }
  if (URI.is(value)) {
    return true;
  }
  if (BuildURI.is(value)) {
    return true;
  }
  if (typeof value === "string") {
    return true;
  }
  return false;
}
var BuildURI, uriInstances, URI;
var init_uri = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/uri.js"() {
    init_result();
    init_mutable_url();
    init_resolve_once();
    init_esm();
    init_relative_path();
    init_stripper();
    BuildURI = class _BuildURI {
      _url;
      constructor(url2) {
        this._url = url2;
      }
      static is(value) {
        return value instanceof _BuildURI || !!value && typeof value.delParam === "function" && typeof value.setParam === "function";
      }
      static from(strURLUri, defaultProtocol = "file:") {
        return from((url2) => new _BuildURI(url2), strURLUri, defaultProtocol, { fromThrow: WritableURL.fromThrow });
      }
      match(other) {
        return match(this.URI(), URI.from(other));
      }
      port(p) {
        this._url.port = p;
        return this;
      }
      hostname(h) {
        this._url.hostname = h;
        return this;
      }
      protocol(p) {
        if (!p.endsWith(":")) {
          p = `${p}:`;
        }
        this._url.protocol = p;
        return this;
      }
      pathname(p) {
        this._url.pathname = p;
        return this;
      }
      hash(h) {
        this._url.hash = h;
        return this;
      }
      resolve(p) {
        if (!p) {
          return this;
        }
        if (typeof p === "string") {
          if (!p.match(/^[a-zA-Z0-9]+:/)) {
            if (p.startsWith("/")) {
              this.pathname(p);
              return this;
            }
            return this.appendRelative(p);
          }
        }
        this._url = WritableURL.fromThrow(p.toString());
        return this;
      }
      appendRelative(p) {
        const appendUrl = URI.from(p);
        const pathname = "./" + appendUrl.pathname;
        const basePath = this._url.pathname;
        this.pathname(relativePath(basePath, pathname));
        for (const [key, value] of appendUrl.getParams) {
          this.setParam(key, value);
        }
        return this;
      }
      cleanParams(...remove) {
        const keys = new Set(remove.flat());
        for (const [key] of Array.from(URLSearchParamsEntries(this._url.searchParams))) {
          if (keys.size === 0 || keys.has(key)) {
            this._url.searchParams.delete(key);
          }
        }
        return this;
      }
      searchParams(val, mode = "reset") {
        setParams(this._url.search, val, mode, this._url.searchParams);
        return this;
      }
      hashParams(val, mode = "reset") {
        this._url.hash = setParams(this._url.hash.replace(/^#/, ""), val, mode);
        return this;
      }
      delParam(key) {
        this._url.searchParams.delete(key);
        return this;
      }
      defParam(key, str) {
        if (!this._url.searchParams.has(key)) {
          this._url.searchParams.set(key, str);
        }
        return this;
      }
      setParam(key, str) {
        this._url.searchParams.set(key, str);
        return this;
      }
      hasParam(key) {
        return this._url.searchParams.has(key);
      }
      get getParams() {
        return URLSearchParamsEntries(this._url.searchParams);
      }
      getParam(key, def) {
        const { key: k, def: d } = coerceKey(key, def);
        let val = this._url.searchParams.get(k);
        if (!falsy2undef(val) && d) {
          val = d;
        }
        return falsy2undef(val);
      }
      getParamResult(key, msgFn) {
        return getParamResult(key, this.getParam(key), msgFn);
      }
      getParamsResult(...keys) {
        return getParamsResult(keys, this);
      }
      getHashParams(...keys) {
        return getParamsResult(keys, resolveHash(this._url.hash));
      }
      toString() {
        this._url.searchParams.sort();
        return this._url.toString();
      }
      toJSON() {
        return this.toString();
      }
      asURL() {
        return this.URI().asURL();
      }
      asObj(...strips) {
        return this.URI().asObj(...strips);
      }
      clone() {
        return _BuildURI.from(this.toString());
      }
      get onlyHostAndSchema() {
        return this.clone().pathname("").cleanParams().hash("").toString();
      }
      get withoutHostAndSchema() {
        return this._url.pathname + this._url.search + this._url.hash;
      }
      URI() {
        return URI.from(this._url);
      }
    };
    uriInstances = new KeyedResolvOnce({
      lru: { maxEntries: 1e3 }
    });
    URI = class _URI {
      static protocolHasHostpart(protocol) {
        protocol = protocol.replace(/:$/, "");
        hasHostPartProtocols.add(protocol);
        return () => {
          hasHostPartProtocols.delete(protocol);
        };
      }
      match(other) {
        return match(this, other);
      }
      static merge(into, from4, defaultProtocol = "file:") {
        const intoUrl = BuildURI.from(into, defaultProtocol);
        const fromUrl = _URI.from(from4, defaultProtocol);
        intoUrl.protocol(fromUrl.protocol);
        const fPath = fromUrl.pathname;
        if (!(fPath.length === 0 || fPath === "/" || fPath === "./")) {
          intoUrl.pathname(fromUrl.pathname);
        }
        for (const [key, value] of fromUrl.getParams) {
          intoUrl.setParam(key, value);
        }
        return intoUrl.URI();
      }
      static is(value) {
        return value instanceof _URI || !!value && typeof value.asURL === "function" && typeof value.getParam === "function" && typeof value.hasParam === "function";
      }
      static from(strURLUri, defaultProtocol = "file:") {
        return from((url2) => uriInstances.get(url2.toString()).once(() => new _URI(url2)), strURLUri, defaultProtocol, {
          fromThrow: ReadonlyURL.fromThrow
        });
      }
      static fromResult(strURLUri, defaultProtocol = "file:") {
        return exception2Result(() => from((url2) => uriInstances.get(url2.toString()).once(() => new _URI(url2)), strURLUri, defaultProtocol, {
          fromThrow: ReadonlyURL.fromThrow
        }));
      }
      _url;
      constructor(url2) {
        this._url = url2.clone();
      }
      build() {
        return BuildURI.from(this._url);
      }
      get hostname() {
        return this._url.hostname;
      }
      get onlyHostAndSchema() {
        return this.build().pathname("").cleanParams().hash("").toString();
      }
      get withoutHostAndSchema() {
        return this._url.pathname + this._url.search + this._url.hash;
      }
      get port() {
        return this._url.port;
      }
      get host() {
        return this._url.host;
      }
      get search() {
        return this._url.search;
      }
      get protocol() {
        return this._url.protocol;
      }
      get pathname() {
        return this._url.pathname;
      }
      get hash() {
        return this._url.hash;
      }
      get getParams() {
        return URLSearchParamsEntries(this._url.searchParams);
      }
      get getHashes() {
        return URLSearchParamsEntries(new URLSearchParams(this._url.hash.slice("#".length)));
      }
      hasParam(key) {
        return this._url.searchParams.has(key);
      }
      getParam(key, def) {
        const { key: k, def: d } = coerceKey(key, def);
        let val = this._url.searchParams.get(k);
        if (!falsy2undef(val) && d) {
          val = d;
        }
        return falsy2undef(val);
      }
      getParamResult(key, msgFn) {
        return getParamResult(key, this.getParam(key), msgFn);
      }
      getParamsResult(...keys) {
        return getParamsResult(keys, this);
      }
      getHashParams(...keys) {
        return getParamsResult(keys, resolveHash(this._url.hash));
      }
      clone() {
        return new _URI(this._url);
      }
      asURL() {
        return this._url.clone();
      }
      toString() {
        return this._url.toString();
      }
      toJSON() {
        return this.toString();
      }
      asObj(...strips) {
        const pathURI = {
          style: "path",
          protocol: this.protocol,
          pathname: this.pathname,
          searchParams: Object.fromEntries(this.getParams)
        };
        if (hasHostPartProtocols.has(this.protocol.replace(/:$/, ""))) {
          return stripper(strips, {
            ...pathURI,
            style: "host",
            hostname: this.hostname,
            port: this.port
          });
        }
        return stripper(strips, pathURI);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/log-level-impl.js
function LevelHandlerSingleton() {
  return levelSingleton;
}
var LevelHandlerImpl, levelSingleton;
var init_log_level_impl = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/log-level-impl.js"() {
    init_option();
    init_types();
    LevelHandlerImpl = class {
      _globalLevels = /* @__PURE__ */ new Set([Level.INFO, Level.ERROR, Level.WARN]);
      _modules = /* @__PURE__ */ new Map();
      _timer = /* @__PURE__ */ new Map();
      ignoreAttr = Option.Some(/^_/);
      isStackExposed = false;
      enableLevel(level, ...modules) {
        if (modules.length == 0) {
          this._globalLevels.add(level);
          return;
        }
        this.forModules(level, (p) => {
          this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, level]));
        }, ...modules);
      }
      disableLevel(level, ...modules) {
        if (modules.length == 0) {
          this._globalLevels.delete(level);
          return;
        }
        this.forModules(level, (p) => {
          this._modules.delete(p);
        }, ...modules);
      }
      setExposeStack(enable) {
        this.isStackExposed = !!enable;
      }
      setIgnoreAttr(re) {
        this.ignoreAttr = Option.From(re);
      }
      forModules(level, fnAction, ...modules) {
        for (const m of modules.flat()) {
          if (typeof m !== "string") {
            continue;
          }
          const parts = m.split(",").map((s) => s.trim()).filter((s) => s.length);
          for (const p of parts) {
            fnAction(p);
          }
        }
      }
      setDebug(...modules) {
        this.forModules(Level.DEBUG, (p) => {
          this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, Level.DEBUG]));
        }, ...modules);
      }
      isEnabled(ilevel, module) {
        const level = ilevel;
        if (typeof module === "string") {
          const levels = this._modules.get(module);
          if (levels && levels.has(level)) {
            return true;
          }
        }
        const wlevel = this._modules.get("*");
        if (wlevel && typeof level === "string") {
          if (wlevel.has(level)) {
            return true;
          }
        }
        if (typeof level !== "string") {
          return true;
        }
        return this._globalLevels.has(level);
      }
      timerStart(key) {
        const now = /* @__PURE__ */ new Date();
        this._timer.set(key, now);
        return now;
      }
      timerEnd(key) {
        const now = /* @__PURE__ */ new Date();
        const start = this._timer.get(key);
        if (!start) {
          return { now, duration: 0 };
        }
        const duration3 = now.getTime() - start.getTime();
        this._timer.delete(key);
        return { now, duration: duration3 };
      }
    };
    levelSingleton = new LevelHandlerImpl();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/sys-abstraction.js
var TimeMode, RandomMode, IDMode;
var init_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/sys-abstraction.js"() {
    TimeMode = {
      REAL: "real",
      CONST: "const",
      STEP: "step"
    };
    RandomMode = {
      CONST: "const",
      STEP: "step",
      RANDOM: "random"
    };
    IDMode = {
      UUID: "uuid",
      CONST: "const",
      STEP: "step"
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/time.js
var Time, TimeUnits;
var init_time = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/time.js"() {
    Time = class {
      TimeSince(start) {
        const now = this.Now();
        return now.getTime() - start.getTime();
      }
    };
    TimeUnits = {
      Microsecond: 1,
      Second: 1e3 * 1,
      //Microsecond,
      Minute: 60 * 1e3 * 1,
      //Second,
      Hour: 60 * 60 * 1e3 * 1
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/web-env-actions.js
var once, BrowserEnvActions;
var init_web_env_actions = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/web-env-actions.js"() {
    once = void 0;
    BrowserEnvActions = class _BrowserEnvActions {
      env = /* @__PURE__ */ new Map();
      opts;
      static new(opts) {
        once = once ?? new _BrowserEnvActions(opts);
        return once;
      }
      constructor(opts) {
        this.opts = opts;
      }
      get(key) {
        return this.env.get(key);
      }
      set(key, value) {
        if (value) {
          this.env.set(key, value);
        }
      }
      delete(key) {
        this.env.delete(key);
      }
      keys() {
        return Array.from(this.env.keys());
      }
      active() {
        return true;
      }
      register(env) {
        const sym = Symbol.for(this.opts.symbol || "CP_ENV");
        const browser = globalThis;
        browser[sym] = env;
        return env;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/deno-env-actions.js
var once2, DenoEnvActions;
var init_deno_env_actions = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/deno-env-actions.js"() {
    init_runtime();
    once2 = void 0;
    DenoEnvActions = class _DenoEnvActions {
      #deno = globalThis;
      static new(opts) {
        once2 = once2 ?? new _DenoEnvActions(opts);
        return once2;
      }
      get _env() {
        return this.#deno.Deno.env;
      }
      opts;
      constructor(opts) {
        this.opts = opts;
      }
      register(env) {
        for (const key of env.keys()) {
          this._env.set(key, env.get(key) || "");
        }
        return env;
      }
      active() {
        return runtimeFn().isDeno;
      }
      keys() {
        return Object.keys(this._env.toObject());
      }
      get(key) {
        return this._env.get(key);
      }
      set(key, value) {
        if (value) {
          this._env.set(key, value);
        }
      }
      delete(key) {
        this._env.delete(key);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/deno-basic-sys-abstraction.js
function DenoBasicSysAbstraction(param2 = {}) {
  const ende = param2.TxtEnDecoder ?? TxtEnDecoderSingleton();
  baseBasicSysAbstraction = baseBasicSysAbstraction ?? new BaseBasicSysAbstraction({
    TxtEnDecoder: ende
  });
  return new WrapperBasicSysAbstraction(baseBasicSysAbstraction, {
    basicRuntimeService: new DenoRuntimeService(envFactory),
    ...param2
  });
}
var DenoRuntimeService, baseBasicSysAbstraction;
var init_deno_basic_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/deno-basic-sys-abstraction.js"() {
    init_base_sys_abstraction();
    init_sys_env();
    init_txt_en_decoder();
    DenoRuntimeService = class {
      _envFactory;
      constructor(envFactory2) {
        this._envFactory = envFactory2;
      }
      Env() {
        return this._envFactory();
      }
      Args() {
        return Deno.args;
      }
      Stdout() {
        return Deno.stdout.writable;
      }
      Stderr() {
        return Deno.stderr.writable;
      }
    };
    baseBasicSysAbstraction = void 0;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/index.js
var init_deno_env = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/deno-env/index.js"() {
    init_deno_env_actions();
    init_deno_basic_sys_abstraction();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/node-env-actions.js
var once3, NodeEnvActions;
var init_node_env_actions = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/node-env-actions.js"() {
    init_runtime();
    once3 = void 0;
    NodeEnvActions = class _NodeEnvActions {
      #node = globalThis;
      _env;
      static new(opts) {
        once3 = once3 ?? new _NodeEnvActions(opts);
        return once3;
      }
      opts;
      constructor(opts) {
        this.opts = opts;
        this._env = this.active() ? this.#node.process.env : {};
      }
      register(env) {
        for (const key of env.keys()) {
          this._env[key] = env.get(key) || "";
        }
        return env;
      }
      active() {
        return runtimeFn().isNodeIsh;
      }
      keys() {
        return Object.keys(this._env);
      }
      get(key) {
        return this._env[key];
      }
      set(key, value) {
        if (value) {
          this._env[key] = value;
        }
      }
      delete(key) {
        delete this._env[key];
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/node-basic-sys-abstraction.js
function NodeBasicSysAbstraction(param2 = {}) {
  const ende = param2.TxtEnDecoder ?? TxtEnDecoderSingleton();
  baseSysAbstraction = baseSysAbstraction ?? new BaseBasicSysAbstraction({
    TxtEnDecoder: ende
  });
  return new WrapperBasicSysAbstraction(baseSysAbstraction, {
    basicRuntimeService: new NodeRuntimeService(ende, envFactory),
    ...param2
  });
}
var NodeRuntimeService, baseSysAbstraction;
var init_node_basic_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/node-basic-sys-abstraction.js"() {
    init_base_sys_abstraction();
    init_sys_env();
    init_txt_en_decoder();
    NodeRuntimeService = class {
      _txtEnDe;
      _envFactory;
      _gthis;
      constructor(ende, envFactory2) {
        this._txtEnDe = ende;
        this._envFactory = envFactory2;
        this._gthis = globalThis;
      }
      Env() {
        return this._envFactory();
      }
      Args() {
        return this._gthis.process.argv;
      }
      Stdout() {
        return new WritableStream({
          write: (chunk) => {
            this._gthis.process.stdout.write(chunk);
          }
        });
      }
      Stderr() {
        return new WritableStream({
          write: (chunk) => {
            this._gthis.process.stderr.write(chunk);
          }
        });
      }
    };
    baseSysAbstraction = void 0;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/index.js
var init_node_env = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/node-env/index.js"() {
    init_node_env_actions();
    init_node_basic_sys_abstraction();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/cf-basic-sys-abstraction.js
function consumeReadableStream(reader, writeFn) {
  reader.read().then(({ done, value }) => {
    if (done) {
      return;
    }
    writeFn(value).then(() => {
      consumeReadableStream(reader, writeFn);
    }).catch((e) => {
      console.error("consumeReadableStream:writeFn", e);
    });
  }).catch((e) => {
    console.error("consumeReadableStream:read", e);
  });
}
function CFWriteableStream(writeFn) {
  const ts = new TransformStream();
  consumeReadableStream(ts.readable.getReader(), writeFn);
  return ts.writable;
}
function CFBasicSysAbstraction(param2) {
  const ende = param2?.TxtEnDecoder || TxtEnDecoderSingleton();
  baseSysAbstraction2 = baseSysAbstraction2 ?? new BaseBasicSysAbstraction({
    TxtEnDecoder: ende
  });
  return new WrapperBasicSysAbstraction(baseSysAbstraction2, {
    basicRuntimeService: new CFRuntimeService(ende, envFactory),
    ...param2
  });
}
var CFRuntimeService, baseSysAbstraction2;
var init_cf_basic_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/cf-basic-sys-abstraction.js"() {
    init_base_sys_abstraction();
    init_sys_env();
    init_txt_en_decoder();
    CFRuntimeService = class {
      _txtEnDe;
      _envFactory;
      constructor(ende, envFactory2) {
        this._txtEnDe = ende;
        this._envFactory = envFactory2;
      }
      Env() {
        return this._envFactory();
      }
      Args() {
        throw new Error("Args-Method not implemented.");
      }
      Stdout() {
        return CFWriteableStream((chunk) => {
          const decoded = this._txtEnDe.decode(chunk);
          console.log(decoded.trimEnd());
          return Promise.resolve();
        });
      }
      Stderr() {
        return CFWriteableStream((chunk) => {
          const decoded = this._txtEnDe.decode(chunk);
          console.error(decoded.trimEnd());
          return Promise.resolve();
        });
      }
    };
    baseSysAbstraction2 = void 0;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/cf-env-actions.js
var once4, CFEnvActions;
var init_cf_env_actions = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/cf-env-actions.js"() {
    init_runtime();
    once4 = void 0;
    CFEnvActions = class _CFEnvActions {
      injectOnRegister = {};
      cfEnv;
      opts;
      env;
      static new(opts = {}) {
        once4 = once4 ?? new _CFEnvActions(opts);
        return once4;
      }
      static inject(o) {
        const env = _CFEnvActions.new();
        for (const key in o) {
          const value = o[key];
          if (typeof value === "string") {
            if (env.env) {
              env.env.set(key, value);
            } else {
              env.injectOnRegister[key] = value;
            }
          }
        }
      }
      constructor(env) {
        this.cfEnv = new Map(Object.entries(env.presetEnv || {}));
        this.opts = env;
      }
      active() {
        return runtimeFn().isCFWorker;
      }
      register(env) {
        this.env = env;
        for (const key in this.injectOnRegister) {
          env.set(key, this.injectOnRegister[key]);
        }
        return env;
      }
      get(key) {
        return this.cfEnv.get(key);
      }
      set(key, value) {
        if (value) {
          this.cfEnv.set(key, value);
        }
      }
      delete(key) {
        this.cfEnv.delete(key);
      }
      keys() {
        return Array.from(this.cfEnv.keys());
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/index.js
var init_cf_env = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/cf-env/index.js"() {
    init_cf_basic_sys_abstraction();
    init_cf_env_actions();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/import-meta-env.module.js
function wrapImportMetaEnv(ea) {
  return new ImportMetaEnv(ea);
}
var ImportMetaEnv;
var init_import_meta_env_module = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/import-meta-env.module.js"() {
    ImportMetaEnv = class {
      #wrap;
      importMetaEnv = import.meta.env || {};
      constructor(ea) {
        this.#wrap = ea;
      }
      active() {
        return this.#wrap.active();
      }
      register(env) {
        return this.#wrap.register(env);
      }
      get(key) {
        const v = this.#wrap.get(key);
        if (v) {
          return v;
        }
        return this.importMetaEnv?.[key];
      }
      set(key, value) {
        this.#wrap.set(key, value);
      }
      delete(key) {
        this.#wrap.delete(key);
      }
      keys() {
        return Array.from(/* @__PURE__ */ new Set([...this.#wrap.keys(), ...Object.keys(this.importMetaEnv ?? {})])).sort();
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/get-params-result.js
function getParamsResult(keys, getParam) {
  const keyDef = keys.flat().reduce((acc, i) => {
    if (typeof i === "string") {
      acc.push({ key: i, def: void 0, isOptional: false });
    } else if (typeof i === "object") {
      acc.push(...Object.keys(i).map((k) => ({
        key: k,
        def: typeof i[k] === "string" ? i[k] : void 0,
        isOptional: i[k] === param.OPTIONAL
      })));
    }
    return acc;
  }, []);
  const msgFn = keys.find((k) => typeof k === "function") || ((...keys2) => {
    const msg = keys2.join(",");
    return `missing parameters: ${msg}`;
  });
  const errors = [];
  const result = {};
  for (const kd of keyDef) {
    const val = getParam.getParam(kd.key);
    if (val === void 0) {
      if (typeof kd.def === "string") {
        result[kd.key] = kd.def;
      } else {
        if (!kd.isOptional) {
          errors.push(kd.key);
        }
      }
    } else {
      result[kd.key] = val;
    }
  }
  if (errors.length) {
    return Result.Err(msgFn(...errors));
  }
  return Result.Ok(result);
}
var init_get_params_result = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/get-params-result.js"() {
    init_esm();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/console-write-stream.js
var ConsoleWriterStreamDefaultWriter, ConsoleWriterStream;
var init_console_write_stream = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/console-write-stream.js"() {
    init_txt_en_decoder();
    ConsoleWriterStreamDefaultWriter = class {
      stream;
      desiredSize = null;
      closed;
      ready;
      _stream;
      constructor(stream) {
        this.stream = stream;
        this._stream = stream;
        this.ready = Promise.resolve();
        this.closed = Promise.resolve();
      }
      abort(_reason) {
        throw new Error("Method not implemented.");
      }
      async close() {
      }
      releaseLock() {
        this._stream.locked = false;
        this.ready = Promise.resolve();
        this.closed = Promise.resolve();
      }
      write(chunk) {
        let strObj = TxtEnDecoderSingleton().decode(chunk).trimEnd();
        try {
          strObj = JSON.parse(strObj);
          const output = strObj.level || "log";
          const cargs = [strObj];
          if ("msg" in strObj) {
            cargs.unshift(strObj.msg);
            delete strObj["msg"];
          }
          switch (output) {
            case "error":
              this._stream.params.error(...cargs);
              break;
            case "warn":
              this._stream.params.warn(...cargs);
              break;
            default:
              this._stream.params.log(...cargs);
          }
        } catch (e) {
          this._stream.params.log(strObj);
        }
        return Promise.resolve();
      }
    };
    ConsoleWriterStream = class {
      locked = false;
      _writer;
      params;
      constructor(params = {}) {
        this.params = {
          error: (...a) => (params.error || console.error)(...a),
          log: (...a) => (params.log || console.log)(...a),
          warn: (...a) => (params.warn || console.warn)(...a)
        };
      }
      abort(_reason) {
        throw new Error("Method not implemented.");
      }
      close() {
        return Promise.resolve();
      }
      getWriter() {
        if (this.locked) {
          throw new Error("Stream is locked");
        }
        this.locked = true;
        if (!this._writer) {
          this._writer = new ConsoleWriterStreamDefaultWriter(this);
        }
        return this._writer;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/add-cement-do-not-export.js
function addCement(params) {
  return {
    cement: {
      runtimeFn,
      WrapperBasicSysAbstraction,
      WrapperRuntimeSysAbstraction,
      TxtEnDecoderSingleton,
      ConsoleWriterStream,
      envFactory,
      BaseBasicSysAbstraction,
      BaseSysAbstraction,
      NodeBasicSysAbstraction
    },
    ...params
  };
}
var init_add_cement_do_not_export = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/add-cement-do-not-export.js"() {
    init_runtime();
    init_base_sys_abstraction();
    init_txt_en_decoder();
    init_console_write_stream();
    init_sys_env();
    init_node_env();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/sys-env.js
function envFactory(opts = {}) {
  const withCement = addCement(opts);
  const found = envActions.find((fi) => fi.fn(withCement).active());
  if (!found) {
    throw new Error("SysContainer:envFactory: no env available");
  }
  const res = _envFactories.get(opts.id ?? found.id).once(() => {
    const action = wrapImportMetaEnv(found.fn(withCement));
    const ret = new EnvImpl(action, withCement);
    action.register(ret);
    return ret;
  });
  if (opts.testPatchImportMetaEnv && isImportMetaEnv(res._map) && res._map.importMetaEnv) {
    Object.assign(res._map.importMetaEnv, opts.testPatchImportMetaEnv);
  }
  return res;
}
function isImportMetaEnv(obj) {
  return !!obj.importMetaEnv;
}
function isIterable(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
var envActions, _envFactories, EnvImpl;
var init_sys_env = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/sys-env.js"() {
    init_deno_env();
    init_node_env();
    init_web_env();
    init_cf_env();
    init_resolve_once();
    init_import_meta_env_module();
    init_get_params_result();
    init_add_cement_do_not_export();
    envActions = [
      { id: "cf", fn: (opts) => CFEnvActions.new(opts) },
      { id: "node", fn: (opts) => NodeEnvActions.new(opts) },
      { id: "deno", fn: (opts) => DenoEnvActions.new(opts) },
      { id: "browser", fn: (opts) => BrowserEnvActions.new(opts) }
    ];
    _envFactories = new KeyedResolvOnce();
    EnvImpl = class {
      _map;
      constructor(map3, opts) {
        this._map = map3;
        this._updatePresets(opts.presetEnv);
      }
      gets(...kparams) {
        return getParamsResult(kparams, {
          getParam: (k) => this.get(k)
        });
      }
      sets(...keys) {
        keys.forEach((key) => {
          if (Array.isArray(key)) {
            if (key.length === 2) {
              const [k, v] = key;
              if (typeof k === "string" && typeof v === "string") {
                this.set(k, v);
                return;
              }
            }
            for (const item of key) {
              if (Array.isArray(item)) {
                if (item.length === 2) {
                  const [k, v] = item;
                  if (typeof k === "string" && typeof v === "string") {
                    this.set(k, v);
                  }
                }
              }
            }
          } else {
            if (isIterable(key)) {
              for (const [k, v] of key) {
                if (typeof k === "string" && typeof v === "string") {
                  this.set(k, v);
                }
              }
            } else {
              const rKey = key;
              for (const k in rKey) {
                const v = rKey[k];
                if (typeof k === "string" && typeof v === "string") {
                  this.set(k, v);
                }
              }
            }
          }
        });
      }
      _updatePresets(presetEnv2) {
        if (!presetEnv2) {
          return;
        }
        for (const [key, value] of presetEnv2) {
          this._map.set(key, value);
        }
      }
      _applyOnSet(onSet, key, value) {
        onSet.forEach((item) => {
          let keys = [];
          if (key) {
            keys = [key];
          } else {
            keys = this._map.keys();
          }
          keys.filter((k) => {
            if (item.filter.size === 0) {
              return true;
            }
            if (item.filter.has(k)) {
              return true;
            }
            return false;
          }).forEach((k) => {
            let v;
            if (!key && !value) {
              v = this._map.get(k);
            } else if (key && !value) {
              v = void 0;
            } else {
              v = value;
            }
            item.fn(k, v);
          });
        });
      }
      _onSet = [];
      keys() {
        return this._map.keys();
      }
      onSet(fn, ...filter) {
        const item = { filter: new Set(filter), fn };
        this._onSet.push(item);
        this._applyOnSet([item]);
      }
      get(key) {
        return this._map.get(key);
      }
      set(key, value) {
        if (!value) {
          return;
        }
        this._map.set(key, value);
        this._applyOnSet(this._onSet, key, value);
      }
      delete(key) {
        this._map.delete(key);
        this._applyOnSet(this._onSet, key);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/web-basic-sys-abstraction.js
function WebBasicSysAbstraction(param2) {
  const ende = param2.TxtEnDecoder ?? TxtEnDecoderSingleton();
  baseBasicSysAbstraction2 = baseBasicSysAbstraction2 ?? new BaseBasicSysAbstraction({
    TxtEnDecoder: ende
  });
  return new WrapperBasicSysAbstraction(baseBasicSysAbstraction2, {
    basicRuntimeService: new WebSystemService(ende, envFactory, () => new ConsoleWriterStream()),
    ...param2
  });
}
var WebSystemService, baseBasicSysAbstraction2;
var init_web_basic_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/web-basic-sys-abstraction.js"() {
    init_base_sys_abstraction();
    init_sys_env();
    init_txt_en_decoder();
    init_console_write_stream();
    WebSystemService = class {
      _txtEnDe;
      _envFactory;
      _stdoutFactory;
      constructor(ende, envFactory2, stdoutFactory) {
        this._txtEnDe = ende;
        this._envFactory = envFactory2;
        this._stdoutFactory = stdoutFactory;
      }
      Env() {
        return this._envFactory();
      }
      Args() {
        throw new Error("Args-Method not implemented.");
      }
      Stdout() {
        return this._stdoutFactory();
      }
      Stderr() {
        const decoder2 = this._txtEnDe;
        return new WritableStream({
          write(chunk) {
            return new Promise((resolve) => {
              const decoded = decoder2.decode(chunk);
              console.error(decoded.trimEnd());
              resolve();
            });
          }
        });
      }
    };
    baseBasicSysAbstraction2 = void 0;
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/index.js
var init_web_env = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/web-env/index.js"() {
    init_web_env_actions();
    init_web_basic_sys_abstraction();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/base-sys-abstraction.js
function TimeFactory(timeMode) {
  switch (timeMode) {
    case TimeMode.REAL:
      return new SysTime();
    case TimeMode.CONST:
      return new ConstTime();
    case TimeMode.STEP:
      return new StepTime();
  }
  return new SysTime();
}
function BasicSysAbstractionFactory(params) {
  const fn = runtimeFn();
  switch (true) {
    case fn.isBrowser:
      return WebBasicSysAbstraction(addCement(params));
    case fn.isDeno:
      return DenoBasicSysAbstraction(addCement(params));
    case fn.isCFWorker:
      return CFBasicSysAbstraction(addCement(params));
    case fn.isNodeIsh:
      return NodeBasicSysAbstraction(addCement(params));
    default:
      throw new Error("Unknown runtime");
  }
}
var SysTime, ConstTime, StepTime, RandomService, IdService, BaseBasicSysAbstraction, BaseSysAbstraction, WrapperBasicSysAbstraction, WrapperRuntimeSysAbstraction;
var init_base_sys_abstraction = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/base-sys-abstraction.js"() {
    init_runtime();
    init_sys_abstraction();
    init_time();
    init_web_env();
    init_cf_env();
    init_deno_env();
    init_node_env();
    init_add_cement_do_not_export();
    SysTime = class extends Time {
      Now() {
        return /* @__PURE__ */ new Date();
      }
      Sleep(duration3) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, duration3);
        });
      }
    };
    ConstTime = class extends Time {
      Now() {
        return new Date(2021, 1, 1, 0, 0, 0, 0);
      }
      Sleep(duration3) {
        return Promise.resolve();
      }
    };
    StepTime = class extends Time {
      _step;
      _start;
      constructor() {
        super();
        this._step = new ConstTime().Now();
        this._start = this._step;
      }
      Now(steps = 1) {
        for (let i = 0; steps > 0 && i < steps; i++) {
          this._step = new Date(this._step.getTime() + 1e3);
        }
        if (steps < 1) {
          this._step = new Date(this._start.getTime() + steps * -1e3);
        }
        return this._step;
      }
      Sleep(duration3) {
        this._step = new Date(this._step.getTime() + duration3);
        return Promise.resolve();
      }
    };
    RandomService = class {
      _mode;
      _step = 0;
      constructor(mode) {
        this._mode = mode;
      }
      Random0ToValue(value) {
        switch (this._mode) {
          case RandomMode.CONST:
            return 0.5 * value;
          case RandomMode.STEP:
            this._step += 1e-4;
            return this._step * value;
          case RandomMode.RANDOM:
            return Math.random() * value;
          default:
            throw new Error("Unknown RandomMode");
        }
      }
    };
    IdService = class {
      _mode;
      _step = 0;
      constructor(mode) {
        if (!mode) {
          mode = IDMode.UUID;
        }
        this._mode = mode;
      }
      NextId() {
        switch (this._mode) {
          case IDMode.UUID:
            return crypto.randomUUID();
          case IDMode.CONST:
            return "VeryUniqueID";
          case IDMode.STEP:
            return `STEPId-${this._step++}`;
          default:
            throw new Error("Unknown IDMode");
        }
      }
    };
    BaseBasicSysAbstraction = class {
      _time = new SysTime();
      _idService = new IdService();
      _randomService = new RandomService(RandomMode.RANDOM);
      _txtEnDe;
      constructor(params) {
        this._txtEnDe = params.TxtEnDecoder;
      }
    };
    BaseSysAbstraction = class extends BaseBasicSysAbstraction {
      _fileSystem;
      _systemService;
      constructor(params) {
        super(params);
        this._fileSystem = params.FileSystem;
        this._systemService = params.SystemService;
      }
    };
    WrapperBasicSysAbstraction = class {
      _time;
      _idService;
      _randomService;
      _basicRuntimeService;
      constructor(base2, params) {
        this._time = base2._time;
        this._basicRuntimeService = params.basicRuntimeService;
        this._idService = base2._idService;
        this._randomService = base2._randomService;
        if (params.TimeMode) {
          this._time = TimeFactory(params.TimeMode);
        }
        if (params.IdMode) {
          this._idService = new IdService(params.IdMode);
        }
        if (params.RandomMode) {
          this._randomService = new RandomService(params.RandomMode);
        }
      }
      Time() {
        return this._time;
      }
      NextId() {
        return this._idService.NextId();
      }
      Random0ToValue(value) {
        return this._randomService.Random0ToValue(value);
      }
      Stdout() {
        return this._basicRuntimeService.Stdout();
      }
      Stderr() {
        return this._basicRuntimeService.Stderr();
      }
      Env() {
        return this._basicRuntimeService.Env();
      }
      Args() {
        return this._basicRuntimeService.Args();
      }
    };
    WrapperRuntimeSysAbstraction = class extends WrapperBasicSysAbstraction {
      _systemService;
      _fileSystem;
      constructor(base2, params) {
        super(base2, params);
        this._systemService = params.systemService ?? base2._systemService;
        this._fileSystem = params.fileSystem ?? base2._fileSystem;
      }
      System() {
        return this._systemService;
      }
      FileSystem() {
        return this._fileSystem;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/log-writer-impl.js
var LogWriterStream;
var init_log_writer_impl = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/log-writer-impl.js"() {
    LogWriterStream = class {
      _out;
      _toFlush = [];
      _id;
      constructor(out) {
        this._out = out;
        this._id = Math.random();
      }
      write(encoded) {
        const my = async () => {
          try {
            const writer = this._out.getWriter();
            await writer.ready;
            await writer.write(encoded);
            writer.releaseLock();
          } catch (err) {
            console.error("Chunk error:", err);
          }
        };
        this._toFlush.push(my);
        this._flush();
      }
      _flushIsRunning = false;
      _flushDoneFns = [];
      _flush(toFlush = void 0, done) {
        if (done) {
          this._flushDoneFns.push(done);
        }
        if (this._toFlush.length == 0) {
          this._flushIsRunning = false;
          this._flushDoneFns.forEach((fn) => fn());
          this._flushDoneFns = [];
          return;
        }
        if (!toFlush && this._toFlush.length == 1 && !this._flushIsRunning) {
          this._flushIsRunning = true;
        } else if (!toFlush) {
          return;
        }
        const my = this._toFlush.shift();
        my?.().catch((e) => {
          console.error("Flush error:", e);
        }).finally(() => {
          this._flush(this._toFlush);
        });
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/logger-impl.js
function getLen(value, lvs) {
  if (Array.isArray(value)) {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "string") {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "object" && value !== null) {
    if (typeof value.size === "number") {
      return logValue(() => value.size, lvs);
    } else if (typeof value.length === "number") {
      return logValue(() => value.length, lvs);
    }
    return logValue(() => Object.keys(value).length, lvs);
  }
  return logValue(() => -1, lvs);
}
function toLogValue(lop) {
  if (lop && typeof lop.then === "function") {
    throw new Error("async logValue Not implemented");
  }
  return lop;
}
function toLogValueCtx(lvh) {
  return {
    ignoreAttr: lvh.ignoreAttr
  };
}
var JSONFormatter, YAMLFormatter, LoggerImpl, WithLoggerBuilder;
var init_logger_impl = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/logger-impl.js"() {
    init_browser();
    init_logger();
    init_result();
    init_uri();
    init_txt_en_decoder();
    init_log_level_impl();
    init_base_sys_abstraction();
    init_log_writer_impl();
    init_types();
    JSONFormatter = class {
      _txtEnDe;
      _space;
      constructor(txtEnde, space) {
        this._txtEnDe = txtEnde;
        this._space = space;
      }
      format(attr) {
        let ret;
        try {
          ret = JSON.stringify(attr, null, this._space);
        } catch (e) {
          ret = JSON.stringify({ internal: { message: e.message, stack: e.stack } });
        }
        return this._txtEnDe.encode(ret + "\n");
      }
    };
    YAMLFormatter = class {
      _txtEnDe;
      _space;
      constructor(txtEnde, space) {
        this._txtEnDe = txtEnde;
        this._space = space;
      }
      format(attr) {
        return this._txtEnDe.encode("---\n" + browser_default.stringify(attr, null, this._space) + "\n");
      }
    };
    LoggerImpl = class _LoggerImpl {
      _sys;
      _attributes = {};
      _withAttributes;
      _logWriter;
      levelHandler;
      _txtEnDe;
      _formatter;
      constructor(params) {
        if (!params) {
          params = {};
        }
        if (!params.sys) {
          this._sys = BasicSysAbstractionFactory();
        } else {
          this._sys = params.sys;
        }
        if (!params.txtEnDe) {
          this._txtEnDe = TxtEnDecoderSingleton();
        } else {
          this._txtEnDe = params.txtEnDe;
        }
        if (!params.formatter) {
          this._formatter = new JSONFormatter(this._txtEnDe);
        } else {
          this._formatter = params.formatter;
        }
        if (params.logWriter) {
          this._logWriter = params.logWriter;
        } else {
          if (!params.out) {
            this._logWriter = new LogWriterStream(this._sys.Stdout());
          } else {
            this._logWriter = new LogWriterStream(params.out);
          }
        }
        if (!params.withAttributes) {
          this._withAttributes = {};
        } else {
          this._withAttributes = { ...params.withAttributes };
        }
        this._attributes = { ...this._withAttributes };
        if (params.levelHandler) {
          this.levelHandler = params.levelHandler;
        } else {
          this.levelHandler = LevelHandlerSingleton();
        }
      }
      TimerStart(key) {
        const now = this.levelHandler.timerStart(key);
        this.coerceKey(key, now.toISOString());
        return this;
      }
      TimerEnd(key) {
        const dur = this.levelHandler.timerEnd(key);
        this.coerceKey(key, `${dur.now.toISOString()} - ${dur.duration}ms`);
        return this;
      }
      TxtEnDe() {
        return this._txtEnDe;
      }
      Attributes() {
        return JSON.parse(JSON.stringify(this._attributes, null));
      }
      SetExposeStack(enable) {
        this.levelHandler.setExposeStack(enable);
        return this;
      }
      EnableLevel(level, ...modules) {
        this.levelHandler.enableLevel(level, ...modules);
        return this;
      }
      DisableLevel(level, ...modules) {
        this.levelHandler.disableLevel(level, ...modules);
        return this;
      }
      Module(key) {
        this._attributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
        this._withAttributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
        return this;
      }
      SetDebug(...modules) {
        this.levelHandler.setDebug(...modules);
        return this;
      }
      SetIgnoreAttribute(re) {
        this.levelHandler.setIgnoreAttr(re);
        return this;
      }
      SetFormatter(formatter) {
        this._formatter = formatter;
        return this;
      }
      Timestamp() {
        this._attributes["ts"] = logValue(() => this._sys.Time().Now().toISOString(), toLogValueCtx(this.levelHandler));
        return this;
      }
      Warn() {
        this._attributes["level"] = logValue(Level.WARN, toLogValueCtx(this.levelHandler));
        return this;
      }
      Log() {
        return this;
      }
      Debug() {
        this._attributes["level"] = logValue(Level.DEBUG, toLogValueCtx(this.levelHandler));
        return this;
      }
      Error() {
        this._attributes["level"] = logValue(Level.ERROR, toLogValueCtx(this.levelHandler));
        return this;
      }
      Info() {
        this._attributes["level"] = logValue(Level.INFO, toLogValueCtx(this.levelHandler));
        return this;
      }
      Err(err) {
        let key = "error";
        if (Result.Is(err)) {
          if (err.isOk()) {
            key = "noerror";
            err = err.Ok();
          } else {
            err = err.Err();
          }
        }
        if (err instanceof Error) {
          if (err.cause) {
            this.coerceKey(key, {
              message: err.message,
              cause: err.cause
            });
          } else {
            this._attributes[key] = logValue(err.message, toLogValueCtx(this.levelHandler));
          }
          if (this.levelHandler.isStackExposed) {
            this._attributes["stack"] = logValue(err.stack?.split(/[\r\n]+/).map((s) => s.trim()), toLogValueCtx(this.levelHandler));
          }
        } else {
          this.Any(key, err);
        }
        return this;
      }
      WithLevel(l) {
        this._attributes["level"] = logValue(l, toLogValueCtx(this.levelHandler));
        return this;
      }
      Ref(key, action) {
        if (typeof action === "function") {
          this._attributes[key] = logValue(action, toLogValueCtx(this.levelHandler));
        } else if (typeof action.toString === "function") {
          this._attributes[key] = logValue(() => action.toString(), toLogValueCtx(this.levelHandler));
        } else {
          this._attributes[key] = logValue("INVALID REF", toLogValueCtx(this.levelHandler));
        }
        return this;
      }
      Bool(key, value) {
        this.coerceKey(key, !!value);
        return this;
      }
      Http(...mix) {
        const key = mix.find((x) => typeof x === "string");
        mix = mix.filter((x) => typeof x !== "string");
        const resErrors = mix.filter((x) => Result.Is(x) && x.isErr());
        if (resErrors.length) {
          this.Err(resErrors.map((x) => x.Err().message).join("\n"));
          return this;
        }
        const req = mix.map((reqOrResult) => Result.Is(reqOrResult) ? reqOrResult.Ok() : reqOrResult).find((req2) => typeof req2.status !== "number");
        const res = mix.map((resOrResult) => Result.Is(resOrResult) ? resOrResult.Ok() : resOrResult).find((res2) => typeof res2.status === "number");
        let reqAndOrres;
        if (res && req) {
          reqAndOrres = { res, req };
        } else if (!res && !req) {
          reqAndOrres = void 0;
        } else if (res) {
          reqAndOrres = res;
        } else if (req) {
          reqAndOrres = req;
        }
        if (reqAndOrres) {
          this.Any(key || "Http", reqAndOrres);
        }
        return this;
      }
      Pair(x) {
        for (const key of Object.keys(x)) {
          const value = x[key];
          if (value instanceof LogValue) {
            this._attributes[key] = value;
            continue;
          }
          if (Result.Is(value)) {
            this.Result(key, value);
            continue;
          }
          this.Any(key, value);
        }
        return this;
      }
      Result(key, res) {
        if (res.isOk()) {
          this._attributes[key] = logValue(res.Ok(), toLogValueCtx(this.levelHandler));
        } else {
          this.Err(res.Err());
        }
        return this;
      }
      Len(value, key = "len") {
        this._attributes[key] = getLen(value, toLogValueCtx(this.levelHandler));
        return this;
      }
      Hash(value, key = "hash") {
        throw new Error("Not implemented");
      }
      Url(url2, key = "url") {
        this.Ref(key, () => URI.from(url2).toString());
        return this;
      }
      coerceKey(key, value) {
        if (typeof key === "string") {
          this._attributes[key] = logValue(value, toLogValueCtx(this.levelHandler));
        } else {
          this.Pair(key);
        }
      }
      Str(key, value) {
        this.coerceKey(key, value);
        return this;
      }
      Any(key, value) {
        this.coerceKey(key, value);
        return this;
      }
      Dur(key, nsec) {
        this._attributes[key] = logValue(`${nsec}ms`, toLogValueCtx(this.levelHandler));
        return this;
      }
      Uint64(key, value) {
        this.coerceKey(key, value);
        return this;
      }
      Int(key, value) {
        return this.Uint64(key, value);
      }
      async Flush() {
        return new Promise((resolve) => {
          this._logWriter._flush(void 0, resolve);
        });
      }
      With() {
        return new WithLoggerBuilder(new _LoggerImpl({
          logWriter: this._logWriter,
          sys: this._sys,
          levelHandler: this.levelHandler,
          formatter: this._formatter,
          withAttributes: {
            module: this._attributes["module"],
            ...this._withAttributes
          }
        }));
      }
      _resetAttributes(fn) {
        const ret = fn();
        Object.keys(this._attributes).forEach((key) => {
          delete this._attributes[key];
        });
        Object.assign(this._attributes, this._withAttributes);
        return ret;
      }
      Msg(...args) {
        const fnError = this._resetAttributes(() => {
          const doWrite = this.levelHandler.isEnabled(toLogValue(this._attributes["level"])?.value(), toLogValue(this._attributes["module"])?.value());
          this._attributes["msg"] = logValue(args.join(" "), toLogValueCtx(this.levelHandler));
          const msg = this._attributes["msg"].value();
          if (typeof msg === "string" && !msg.trim().length) {
            delete this._attributes["msg"];
          }
          let fnRet = () => this._formatter.format({ ...this._attributes });
          if (doWrite) {
            let encoded;
            try {
              encoded = fnRet();
              this._logWriter.write(encoded);
            } catch (e) {
              const where = "Logger-Impl:Msg:Write error:";
              console.error(where, e, this._attributes);
              encoded = this._txtEnDe.encode(where + e.message + "\n" + e.stack + "\n");
            }
            fnRet = () => encoded;
          }
          return fnRet;
        });
        const asError = () => new Error(this._txtEnDe.decode(fnError()));
        return {
          ResultError: () => Result.Err(asError()),
          AsError: asError
        };
      }
    };
    WithLoggerBuilder = class {
      _li;
      levelHandler;
      constructor(li) {
        this._li = li;
        this.levelHandler = li.levelHandler;
      }
      TimerStart(key) {
        this._li.TimerStart(key);
        return this;
      }
      TimerEnd(key) {
        this._li.TimerEnd(key);
        return this;
      }
      TxtEnDe() {
        return this._li.TxtEnDe();
      }
      Logger() {
        Object.assign(this._li._withAttributes, this._li._attributes);
        return this._li;
      }
      Attributes() {
        return { ...this._li._attributes };
      }
      SetExposeStack(enable) {
        this._li.levelHandler.setExposeStack(enable);
        return this;
      }
      SetIgnoreAttribute(re) {
        this._li.levelHandler.setIgnoreAttr(re);
        return this;
      }
      SetFormatter(fmt) {
        this._li.SetFormatter(fmt);
        return this;
      }
      EnableLevel(level, ...modules) {
        this._li.levelHandler.enableLevel(level, ...modules);
        return this;
      }
      DisableLevel(level, ...modules) {
        this._li.levelHandler.enableLevel(level, ...modules);
        return this;
      }
      Module(key) {
        this._li.Module(key);
        return this;
      }
      SetDebug(...modules) {
        this._li.SetDebug(...modules);
        return this;
      }
      Http(...mix) {
        this._li.Http(...mix);
        return this;
      }
      Pair(x) {
        this._li.Pair(x);
        return this;
      }
      Str(key, value) {
        this._li.Str(key, value);
        return this;
      }
      Len(value, key) {
        this._li.Len(value, key);
        return this;
      }
      Hash(value, key) {
        this._li.Hash(value, key);
        return this;
      }
      Ref(key, action) {
        this._li.Ref(key, action);
        return this;
      }
      Bool(key, value) {
        this._li.Bool(key, value);
        return this;
      }
      Result(key, res) {
        this._li.Result(key, res);
        return this;
      }
      Url(url2, key) {
        this._li.Url(url2, key);
        return this;
      }
      Int(key, value) {
        this._li.Int(key, value);
        return this;
      }
      Log() {
        this._li.Log();
        return this;
      }
      WithLevel(level) {
        this._li.WithLevel(level);
        return this;
      }
      Error() {
        this._li.Error();
        return this;
      }
      Warn() {
        this._li.Error();
        return this;
      }
      Debug() {
        this._li.Debug();
        return this;
      }
      Err(err) {
        this._li.Err(err);
        return this;
      }
      Info() {
        this._li.Info();
        return this;
      }
      Timestamp() {
        this._li.Timestamp();
        return this;
      }
      Any(key, value) {
        this._li.Any(key, value);
        return this;
      }
      Dur(key, nsec) {
        this._li.Dur(key, nsec);
        return this;
      }
      Uint64(key, value) {
        this._li.Uint64(key, value);
        return this;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/log-write-stream.js
var init_log_write_stream = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/log-write-stream.js"() {
    init_esm();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/mock-logger.js
var init_mock_logger = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/mock-logger.js"() {
    init_esm();
    init_log_write_stream();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/index.js
var init_test = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/test/index.js"() {
    init_log_write_stream();
    init_mock_logger();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/tracer.js
var init_tracer = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/tracer.js"() {
    init_is_promise();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/coerce-binary.js
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer || Object.prototype.toString.call(value) === "[object ArrayBuffer]";
}
function isUint8Array(value) {
  return value instanceof Uint8Array || Object.prototype.toString.call(value) === "[object Uint8Array]";
}
async function top_uint8(input) {
  if (input instanceof Blob) {
    return new Uint8Array(await input.arrayBuffer());
  }
  return to_uint8(input);
}
function to_uint8(input, encoder2) {
  if (typeof input === "string") {
    return (encoder2 ?? TxtEnDecoderSingleton()).encode(input);
  }
  if (isArrayBuffer(input)) {
    return new Uint8Array(input);
  }
  if (isUint8Array(input)) {
    return input;
  }
  return new Uint8Array(input);
}
function to_arraybuf(input, encoder2) {
  if (input instanceof ArrayBuffer) {
    return input;
  }
  const u8 = to_uint8(input, encoder2);
  return u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
}
var init_coerce_binary = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/coerce-binary.js"() {
    init_txt_en_decoder();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/crypto.js
function randomBytes(crypto2) {
  return (size) => {
    const bytes = new Uint8Array(size);
    if (size > 0) {
      crypto2.getRandomValues(bytes);
    }
    return bytes;
  };
}
function digestSHA256(crypto2) {
  return (data) => {
    return crypto2.subtle.digest("SHA-256", to_arraybuf(data));
  };
}
function toCryptoRuntime(cryptoOpts = {}) {
  let crypto2;
  if (!globalThis.crypto || !globalThis.crypto.subtle) {
    crypto2 = {
      getRandomValues: globalThis.crypto.getRandomValues.bind(globalThis.crypto),
      subtle: {
        importKey: () => {
          throw new Error("crypto.subtle.importKey not available");
        },
        exportKey: () => {
          throw new Error("crypto.subtle.exportKey not available");
        },
        encrypt: () => {
          throw new Error("crypto.subtle.encrypt not available");
        },
        decrypt: () => {
          throw new Error("crypto.subtle.decrypt not available");
        },
        digest: () => {
          throw new Error("crypto.subtle.digest not available");
        }
      }
    };
  } else {
    crypto2 = globalThis.crypto;
  }
  const runtime = {
    importKey: cryptoOpts.importKey || crypto2.subtle.importKey.bind(crypto2.subtle),
    exportKey: cryptoOpts.exportKey || crypto2.subtle.exportKey.bind(crypto2.subtle),
    encrypt: cryptoOpts.encrypt || crypto2.subtle.encrypt.bind(crypto2.subtle),
    decrypt: cryptoOpts.decrypt || crypto2.subtle.decrypt.bind(crypto2.subtle),
    randomBytes: cryptoOpts.randomBytes || randomBytes(crypto2),
    digestSHA256: cryptoOpts.digestSHA256 || digestSHA256(crypto2)
  };
  return runtime;
}
var init_crypto = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/crypto.js"() {
    init_coerce_binary();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/version.js
var init_version = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/version.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/http_header.js
function hasForEach(unk) {
  return typeof unk.forEach == "function";
}
var HeadersImpl, HttpHeader;
var init_http_header = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/http_header.js"() {
    HeadersImpl = class {
      impl = new Headers();
      constructor(init) {
        for (const [k, v] of init) {
          this.append(k, v);
        }
      }
      forEach(callbackfn) {
        this.impl.forEach((v, k) => {
          callbackfn(v, k, this);
        });
      }
      delete(name2) {
        this.impl.delete(name2);
      }
      get(name2) {
        return this.impl.get(name2);
      }
      getSetCookie() {
        return this.impl.getSetCookie();
      }
      has(name2) {
        return this.impl.has(name2);
      }
      set(name2, value) {
        this.impl.set(name2, value);
      }
      *[Symbol.iterator]() {
        const keys = [];
        this.impl.forEach((v, k) => {
          keys.push([k, v]);
        });
        for (const k of keys) {
          yield k;
        }
      }
      entries() {
        return this[Symbol.iterator]();
      }
      *keys() {
        const keys = [];
        this.impl.forEach((_, k) => {
          keys.push(k);
        });
        for (const k of keys) {
          yield k;
        }
      }
      *values() {
        for (const k of this.keys()) {
          const v = this.impl.get(k);
          if (!v) {
            continue;
          }
          yield v;
        }
      }
      append(key, value) {
        if (!(typeof value === "string" || Array.isArray(value))) {
          return this;
        }
        const existingValues = this.impl.get(key) || "";
        const newValues = Array.isArray(value) ? value : [value];
        const allValues = existingValues ? [...existingValues.split(", ").map((v) => v.trim()), ...newValues] : newValues;
        const uniqueValues = [...new Set(allValues.filter((v) => v !== ""))];
        this.impl.set(key, uniqueValues.join(", "));
        return this;
      }
    };
    HttpHeader = class _HttpHeader {
      _headers = /* @__PURE__ */ new Map();
      static coerce(headers) {
        if (headers instanceof _HttpHeader) {
          return headers;
        }
        const h = new _HttpHeader();
        if (headers) {
          switch (true) {
            case Array.isArray(headers):
              for (const [k, v] of headers) {
                if (v) {
                  h.Add(k, v);
                }
              }
              break;
            case hasForEach(headers):
              headers.forEach((v, k) => {
                if (v) {
                  const arrayV = (typeof v === "string" ? [v] : v).map((vv) => vv.split(",").map((v2) => v2.trim())).flat().filter((v2) => !!v2);
                  h.Add(k, arrayV);
                }
              });
              break;
            default:
              for (const k in headers) {
                const v = headers[k];
                (Array.isArray(v) ? v : [v]).forEach((v2) => {
                  h.Add(k, v2);
                });
              }
          }
        }
        return h;
      }
      static from(...headersArgs) {
        return headersArgs.map((headers) => _HttpHeader.coerce(headers)).reduce((acc, cur) => acc.MergeInplace(cur), new _HttpHeader());
      }
      _asStringString() {
        const ret = /* @__PURE__ */ new Map();
        for (const [key, values] of this._headers) {
          ret.set(key, Array.from(values).join(", "));
        }
        return ret;
      }
      _key(key) {
        return key.toLowerCase();
      }
      Values(key) {
        const values = this._headers.get(this._key(key));
        return values ? Array.from(values) : [];
      }
      Get(key) {
        const values = this._headers.get(this._key(key));
        if (values === void 0 || values.size === 0) {
          return void 0;
        }
        return values.values().next().value;
      }
      Set(key, valueOr) {
        const value = new Set((Array.isArray(valueOr) ? valueOr : [valueOr]).map((v) => v.trim()).filter((v) => v !== ""));
        if (value.size > 0) {
          this._headers.set(this._key(key), value);
        } else {
          this._headers.delete(this._key(key));
        }
        return this;
      }
      Add(key, value) {
        if (typeof value === "undefined") {
          return this;
        }
        let values = this._headers.get(this._key(key));
        if (!values) {
          values = /* @__PURE__ */ new Set();
          this._headers.set(this._key(key), values);
        }
        (Array.isArray(value) ? value : [value]).map((v) => v.trim()).filter((v) => v !== "").reduce((acc, v) => {
          acc.add(v);
          return acc;
        }, values);
        return this;
      }
      Del(ey) {
        this._headers.delete(this._key(ey));
        return this;
      }
      Items() {
        return Array.from(this._headers).filter(([_, vs]) => vs.size > 0).map(([k, vs]) => [k, Array.from(vs)]);
      }
      SortItems() {
        return this.Items().sort(([[a]], [[b]]) => a.localeCompare(b));
      }
      Clone() {
        const clone3 = new _HttpHeader();
        for (const [key, values] of this._headers.entries()) {
          clone3._headers.set(key, new Set(values));
        }
        return clone3;
      }
      AsRecordStringStringArray() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
          obj[key] = [...values];
        }
        return obj;
      }
      AsRecordStringString() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
          obj[key] = Array.from(values).join(", ");
        }
        return obj;
      }
      AsHeaderInit() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
          const vs = values.values().next();
          if (vs.value) {
            obj[key] = vs.value;
          }
        }
        return obj;
      }
      AsHeaders() {
        return new HeadersImpl(this._asStringString());
      }
      MergeInplace(...other) {
        for (const h of other.map((h2) => _HttpHeader.coerce(h2))) {
          for (const [key, values] of h.Items()) {
            this.Add(key, values);
          }
        }
        return this;
      }
      Merge(...other) {
        return this.Clone().MergeInplace(...other);
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/path-ops.js
var pathOpsImpl, pathOps;
var init_path_ops = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/path-ops.js"() {
    pathOpsImpl = class {
      join(...paths) {
        const parts = this.#parts(paths.filter((i) => i).join("/"));
        if (parts.dirname === "" || parts.dirname === ".") {
          return parts.basename ? parts.basename : ".";
        }
        return parts.dirname + "/" + parts.basename;
      }
      #parts(path) {
        path = path.replace(/\/+/g, "/").replace(/(\/\.\/)+/g, "/").replace(/\/+$/, "");
        const splitted = path.split("/");
        if (splitted.length === 1) {
          return {
            dirname: ".",
            basename: splitted[0] === "." ? "" : splitted[0]
          };
        }
        const basename = splitted.pop();
        if (!basename) {
          throw new Error("basename is undefined");
        }
        return {
          dirname: splitted.join("/").replace(/^\.\//, ""),
          basename
        };
      }
      dirname(path) {
        return this.#parts(path).dirname;
      }
      basename(path) {
        return this.#parts(path).basename;
      }
    };
    pathOps = new pathOpsImpl();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/json-en-decoder.js
var init_json_en_decoder = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/json-en-decoder.js"() {
    init_result();
    init_txt_en_decoder();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/app-context.js
function isAppContext(ctx) {
  return AppContext.is(ctx);
}
var AppContext;
var init_app_context = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/app-context.js"() {
    AppContext = class _AppContext {
      ctx = /* @__PURE__ */ new Map();
      static is(ctx) {
        return ctx instanceof _AppContext && "ctx" in ctx && ctx.ctx instanceof Map;
      }
      static merge(...ctxs) {
        const merged = new _AppContext();
        for (const ctx of ctxs) {
          if (!ctx)
            continue;
          let entries4 = [];
          if (isAppContext(ctx)) {
            entries4 = Array.from(ctx.ctx.entries());
          } else if (typeof ctx === "object" && ctx !== null) {
            entries4 = Object.entries(ctx);
          }
          for (const [key, value] of entries4) {
            merged.ctx.set(key, value);
          }
        }
        return merged;
      }
      set(key, value) {
        this.ctx.set(key, value);
        return this;
      }
      get(key) {
        return this.ctx.get(key);
      }
      delete(key) {
        this.ctx.delete(key);
      }
      asObj() {
        return Object.fromEntries(this.ctx.entries());
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/load-asset.js
var init_load_asset = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/load-asset.js"() {
    init_path_ops();
    init_result();
    init_runtime();
    init_txt_en_decoder();
    init_uri();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/promise-sleep.js
var init_promise_sleep = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/promise-sleep.js"() {
    init_future();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/poller.js
var init_poller = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/poller.js"() {
    init_future();
    init_promise_sleep();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/on-func.js
var init_on_func = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/on-func.js"() {
    init_is_promise();
    init_result();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/timeouted.js
var init_timeouted = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/timeouted.js"() {
    init_future();
    init_is_promise();
    init_promise_sleep();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stream-map.js
var init_stream_map = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stream-map.js"() {
    init_is_promise();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/rebuffer.js
var init_rebuffer = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/rebuffer.js"() {
    init_stream_map();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stream2string.js
var init_stream2string = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/stream2string.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/string2stream.js
var init_string2stream = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/string2stream.js"() {
    init_txt_en_decoder();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/fanout-write-stream.js
var init_fanout_write_stream = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/fanout-write-stream.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/uint8array-equal.js
var init_uint8array_equal = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/uint8array-equal.js"() {
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/consume.js
var init_consume = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/utils/consume.js"() {
    init_esm();
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/wait-for-value.js
var WaitingForValue;
var init_wait_for_value = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/wait-for-value.js"() {
    init_future();
    init_option();
    init_resolve_once();
    WaitingForValue = class {
      #value;
      #waitFuture;
      #waitValue;
      constructor(opts = {}) {
        this.init(opts.presetValue);
      }
      init(presetValue = Option.None()) {
        this.#value = presetValue;
        if (presetValue.IsSome() && this.#waitFuture) {
          this.#waitFuture.resolve(presetValue.unwrap());
        }
        if (this.#value.IsSome()) {
          this.#waitFuture = void 0;
          const resolveOnce2 = new ResolveOnce();
          this.#waitValue = () => resolveOnce2.once(() => Promise.resolve(presetValue.unwrap()));
          return;
        }
        const myFuture = this.#waitFuture = new Future();
        const resolveOnce = new ResolveOnce();
        this.#waitValue = () => resolveOnce.once(async () => myFuture.asPromise());
      }
      setValue(value) {
        switch (true) {
          case this.#value.IsNone():
            this.#value = value;
            if (value.IsSome()) {
              this.#waitFuture?.resolve(value.unwrap());
            }
            break;
          case this.#value.IsSome():
            this.init(value);
            break;
        }
      }
      setError(err) {
        if (this.#value.IsSome()) {
          console.warn("WaitingForValue.setError called but value is already set, ignoring error", err);
          return;
        }
        this.#waitFuture?.reject(err);
        this.init();
      }
      waitValue() {
        return this.#waitValue();
      }
      value() {
        return this.#value;
      }
    };
  }
});

// node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/index.js
var init_esm = __esm({
  "node_modules/.pnpm/@adviser+cement@0.5.8_typescript@5.9.3/node_modules/@adviser/cement/esm/index.js"() {
    init_file_service();
    init_logger_impl();
    init_logger();
    init_sys_abstraction();
    init_sys_env();
    init_time();
    init_test();
    init_txt_en_decoder();
    init_log_level_impl();
    init_result();
    init_option();
    init_future();
    init_tracer();
    init_resolve_once();
    init_runtime();
    init_uri();
    init_crypto();
    init_base_sys_abstraction();
    init_bin2text();
    init_version();
    init_http_header();
    init_path_ops();
    init_json_en_decoder();
    init_types();
    init_lru_map_set();
    init_coerce_binary();
    init_is_promise();
    init_app_context();
    init_load_asset();
    init_mutable_url();
    init_poller();
    init_on_func();
    init_timeouted();
    init_promise_sleep();
    init_keyed_ng();
    init_rebuffer();
    init_stream_map();
    init_stream2string();
    init_string2stream();
    init_console_write_stream();
    init_fanout_write_stream();
    init_get_params_result();
    init_stripper();
    init_sorted_object();
    init_uint8array_equal();
    init_coerce_uint8();
    init_consume();
    init_to_sorted();
    init_relative_path();
    init_node_env();
    init_wait_for_value();
    init_is_json();
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
function toHex(d) {
  return d.reduce((hex3, byte) => hex3 + byte.toString(16).padStart(2, "0"), "");
}
function fromHex(hex3) {
  const hexes = hex3.match(/../g);
  return hexes != null ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
  if (aa === bb) {
    return true;
  }
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
}
function coerce(o) {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") {
    return o;
  }
  if (o instanceof ArrayBuffer) {
    return new Uint8Array(o);
  }
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
}
function isBinary(o) {
  return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
  return new TextEncoder().encode(str);
}
function toString(b) {
  return new TextDecoder().decode(b);
}
var empty;
var init_bytes = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bytes.js"() {
    empty = new Uint8Array(0);
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/raw.js
function encode(node) {
  return coerce(node);
}
function decode(data) {
  return coerce(data);
}
var code;
var init_raw = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/raw.js"() {
    init_bytes();
    code = 85;
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode14(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode15(string5) {
    var buffer3 = decodeUnsafe(string5);
    if (buffer3) {
      return buffer3;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode14,
    decodeUnsafe,
    decode: decode15
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/base-x.js"() {
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base.js
function or(left, right) {
  return new ComposedDecoder({
    ...left.decoders ?? { [left.prefix]: left },
    ...right.decoders ?? { [right.prefix]: right }
  });
}
function from2({ name: name2, prefix, encode: encode14, decode: decode15 }) {
  return new Codec(name2, prefix, encode14, decode15);
}
function baseX({ name: name2, prefix, alphabet }) {
  const { encode: encode14, decode: decode15 } = base_x_default(alphabet, name2);
  return from2({
    prefix,
    name: name2,
    encode: encode14,
    decode: (text2) => coerce(decode15(text2))
  });
}
function decode2(string5, alphabetIdx, bitsPerChar, name2) {
  let end = string5.length;
  while (string5[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer3 = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = alphabetIdx[string5[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer3 = buffer3 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer3 >> bits;
    }
  }
  if (bits >= bitsPerChar || (255 & buffer3 << 8 - bits) !== 0) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function encode2(data, alphabet, bitsPerChar) {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer3 = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer3 = buffer3 << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer3 >> bits];
    }
  }
  if (bits !== 0) {
    out += alphabet[mask & buffer3 << bitsPerChar - bits];
  }
  if (pad) {
    while ((out.length * bitsPerChar & 7) !== 0) {
      out += "=";
    }
  }
  return out;
}
function createAlphabetIdx(alphabet) {
  const alphabetIdx = {};
  for (let i = 0; i < alphabet.length; ++i) {
    alphabetIdx[alphabet[i]] = i;
  }
  return alphabetIdx;
}
function rfc4648({ name: name2, prefix, bitsPerChar, alphabet }) {
  const alphabetIdx = createAlphabetIdx(alphabet);
  return from2({
    prefix,
    name: name2,
    encode(input) {
      return encode2(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode2(input, alphabetIdx, bitsPerChar, name2);
    }
  });
}
var Encoder, Decoder, ComposedDecoder, Codec;
var init_base = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base.js"() {
    init_bytes();
    init_base_x();
    Encoder = class {
      name;
      prefix;
      baseEncode;
      constructor(name2, prefix, baseEncode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      name;
      prefix;
      baseDecode;
      prefixCodePoint;
      constructor(name2, prefix, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        const prefixCodePoint = prefix.codePointAt(0);
        if (prefixCodePoint === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefixCodePoint;
        this.baseDecode = baseDecode;
      }
      decode(text2) {
        if (typeof text2 === "string") {
          if (text2.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text2.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or(this, decoder2);
      }
    };
    ComposedDecoder = class {
      decoders;
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2 != null) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec = class {
      name;
      prefix;
      baseEncode;
      baseDecode;
      encoder;
      decoder;
      constructor(name2, prefix, baseEncode, baseDecode) {
        this.name = name2;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name2, prefix, baseEncode);
        this.decoder = new Decoder(name2, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base32.js
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base32.js"() {
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base36.js
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base36.js"() {
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base58.js
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base58.js"() {
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/varint.js
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf3, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf3[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/vendor/varint.js"() {
    encode_1 = encode3;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode3 = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode: decode3,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/varint.js
function decode4(data, offset = 0) {
  const code4 = varint_default.decode(data, offset);
  return [code4, varint_default.decode.bytes];
}
function encodeTo(int4, target, offset = 0) {
  varint_default.encode(int4, target, offset);
  return target;
}
function encodingLength(int4) {
  return varint_default.encodingLength(int4);
}
var init_varint2 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/varint.js"() {
    init_varint();
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/digest.js
function create(code4, digest) {
  const size = digest.byteLength;
  const sizeOffset = encodingLength(code4);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code4, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code4, size, digest, bytes);
}
function decode5(multihash) {
  const bytes = coerce(multihash);
  const [code4, sizeOffset] = decode4(bytes);
  const [size, digestOffset] = decode4(bytes.subarray(sizeOffset));
  const digest = bytes.subarray(sizeOffset + digestOffset);
  if (digest.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code4, size, digest, bytes);
}
function equals2(a, b) {
  if (a === b) {
    return true;
  } else {
    const data = b;
    return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
  }
}
var Digest;
var init_digest = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/digest.js"() {
    init_bytes();
    init_varint2();
    Digest = class {
      code;
      size;
      digest;
      bytes;
      /**
       * Creates a multihash digest.
       */
      constructor(code4, size, digest, bytes) {
        this.code = code4;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
      }
    };
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/link/interface.js
var init_interface = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/link/interface.js"() {
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/cid.js
function format(link, base2) {
  const { bytes, version: version2 } = link;
  switch (version2) {
    case 0:
      return toStringV0(bytes, baseCache(link), base2 ?? base58btc.encoder);
    default:
      return toStringV1(bytes, baseCache(link), base2 ?? base32.encoder);
  }
}
function fromJSON(json2) {
  return CID.parse(json2["/"]);
}
function baseCache(cid) {
  const baseCache2 = cache.get(cid);
  if (baseCache2 == null) {
    const baseCache3 = /* @__PURE__ */ new Map();
    cache.set(cid, baseCache3);
    return baseCache3;
  }
  return baseCache2;
}
function parseCIDtoBytes(source, base2) {
  switch (source[0]) {
    // CIDv0 is parsed differently
    case "Q": {
      const decoder2 = base2 ?? base58btc;
      return [
        base58btc.prefix,
        decoder2.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder2 = base2 ?? base58btc;
      return [base58btc.prefix, decoder2.decode(source)];
    }
    case base32.prefix: {
      const decoder2 = base2 ?? base32;
      return [base32.prefix, decoder2.decode(source)];
    }
    case base36.prefix: {
      const decoder2 = base2 ?? base36;
      return [base36.prefix, decoder2.decode(source)];
    }
    default: {
      if (base2 == null) {
        throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");
      }
      return [source[0], base2.decode(source)];
    }
  }
}
function toStringV0(bytes, cache3, base2) {
  const { prefix } = base2;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base2.name} encoding`);
  }
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base2.encode(bytes).slice(1);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function toStringV1(bytes, cache3, base2) {
  const { prefix } = base2;
  const cid = cache3.get(prefix);
  if (cid == null) {
    const cid2 = base2.encode(bytes);
    cache3.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
}
function encodeCID(version2, code4, multihash) {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code4);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code4, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
}
var cache, CID, DAG_PB_CODE, SHA_256_CODE, cidSymbol;
var init_cid = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/cid.js"() {
    init_base32();
    init_base36();
    init_base58();
    init_bytes();
    init_digest();
    init_varint2();
    init_interface();
    cache = /* @__PURE__ */ new WeakMap();
    CID = class _CID {
      code;
      version;
      multihash;
      bytes;
      "/";
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param multihash - (Multi)hash of the of the content.
       */
      constructor(version2, code4, multihash, bytes) {
        this.code = code4;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
      }
      /**
       * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
       * please either use `CID.asCID(cid)` or switch to new signalling mechanism
       *
       * @deprecated
       */
      get asCID() {
        return this;
      }
      // ArrayBufferView
      get byteOffset() {
        return this.bytes.byteOffset;
      }
      // ArrayBufferView
      get byteLength() {
        return this.bytes.byteLength;
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          case 1: {
            const { code: code4, multihash } = this;
            if (code4 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code4, digest } = this.multihash;
            const multihash = create(code4, digest);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return _CID.equals(this, other);
      }
      static equals(self, other) {
        const unknown2 = other;
        return unknown2 != null && self.code === unknown2.code && self.version === unknown2.version && equals2(self.multihash, unknown2.multihash);
      }
      toString(base2) {
        return format(this, base2);
      }
      toJSON() {
        return { "/": format(this) };
      }
      link() {
        return this;
      }
      [Symbol.toStringTag] = "CID";
      // Legacy
      [/* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
      }
      /**
       * Takes any input `value` and returns a `CID` instance if it was
       * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
       * it will return value back. If `value` is not instance of this CID
       * class, but is compatible CID it will return new instance of this
       * `CID` class. Otherwise returns null.
       *
       * This allows two different incompatible versions of CID library to
       * co-exist and interop as long as binary interface is compatible.
       */
      static asCID(input) {
        if (input == null) {
          return null;
        }
        const value = input;
        if (value instanceof _CID) {
          return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
          const { version: version2, code: code4, multihash, bytes } = value;
          return new _CID(version2, code4, multihash, bytes ?? encodeCID(version2, code4, multihash.bytes));
        } else if (value[cidSymbol] === true) {
          const { version: version2, multihash, code: code4 } = value;
          const digest = decode5(multihash);
          return _CID.create(version2, code4, digest);
        } else {
          return null;
        }
      }
      /**
       * @param version - Version of the CID
       * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
       * @param digest - (Multi)hash of the of the content.
       */
      static create(version2, code4, digest) {
        if (typeof code4 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
          throw new Error("Invalid digest");
        }
        switch (version2) {
          case 0: {
            if (code4 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version2, code4, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes = encodeCID(version2, code4, digest.bytes);
            return new _CID(version2, code4, digest, bytes);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      /**
       * Simplified version of `create` for CIDv0.
       */
      static createV0(digest) {
        return _CID.create(0, DAG_PB_CODE, digest);
      }
      /**
       * Simplified version of `create` for CIDv1.
       *
       * @param code - Content encoding format code.
       * @param digest - Multihash of the content.
       */
      static createV1(code4, digest) {
        return _CID.create(1, code4, digest);
      }
      /**
       * Decoded a CID from its binary representation. The byte array must contain
       * only the CID with no additional bytes.
       *
       * An error will be thrown if the bytes provided do not contain a valid
       * binary representation of a CID.
       */
      static decode(bytes) {
        const [cid, remainder] = _CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      /**
       * Decoded a CID from its binary representation at the beginning of a byte
       * array.
       *
       * Returns an array with the first element containing the CID and the second
       * element containing the remainder of the original byte array. The remainder
       * will be a zero-length byte array if the provided bytes only contained a
       * binary CID representation.
       */
      static decodeFirst(bytes) {
        const specs = _CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest) : _CID.createV1(specs.codec, digest);
        return [cid, bytes.subarray(specs.size)];
      }
      /**
       * Inspect the initial bytes of a CID to determine its properties.
       *
       * Involves decoding up to 4 varints. Typically this will require only 4 to 6
       * bytes but for larger multicodec code values and larger multihash digest
       * lengths these varints can be quite large. It is recommended that at least
       * 10 bytes be made available in the `initialBytes` argument for a complete
       * inspection.
       */
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = decode4(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version2 = next();
        let codec2 = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else {
          codec2 = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return { version: version2, codec: codec2, multihashCode, digestSize, multihashSize, size };
      }
      /**
       * Takes cid in a string representation and creates an instance. If `base`
       * decoder is not provided will use a default from the configuration. It will
       * throw an error if encoding of the CID is not compatible with supplied (or
       * a default decoder).
       */
      static parse(source, base2) {
        const [prefix, bytes] = parseCIDtoBytes(source, base2);
        const cid = _CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
          throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix, source);
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    cidSymbol = /* @__PURE__ */ Symbol.for("@ipld/js-cid/CID");
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/hasher.js
function from3({ name: name2, code: code4, encode: encode14, minDigestLength, maxDigestLength }) {
  return new Hasher(name2, code4, encode14, minDigestLength, maxDigestLength);
}
function createDigest(digest, code4, truncate) {
  if (truncate != null && truncate !== digest.byteLength) {
    if (truncate > digest.byteLength) {
      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`);
    }
    digest = digest.subarray(0, truncate);
  }
  return create(code4, digest);
}
var DEFAULT_MIN_DIGEST_LENGTH, Hasher;
var init_hasher = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/hasher.js"() {
    init_digest();
    DEFAULT_MIN_DIGEST_LENGTH = 20;
    Hasher = class {
      name;
      code;
      encode;
      minDigestLength;
      maxDigestLength;
      constructor(name2, code4, encode14, minDigestLength, maxDigestLength) {
        this.name = name2;
        this.code = code4;
        this.encode = encode14;
        this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
        this.maxDigestLength = maxDigestLength;
      }
      digest(input, options) {
        if (options?.truncate != null) {
          if (options.truncate < this.minDigestLength) {
            throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
          }
          if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
            throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
          }
        }
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          if (result instanceof Uint8Array) {
            return createDigest(result, this.code, options?.truncate);
          }
          return result.then((digest) => createDigest(digest, this.code, options?.truncate));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/sha2-browser.js
function sha(name2) {
  return async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
}
var sha256, sha512;
var init_sha2_browser = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/sha2-browser.js"() {
    init_hasher();
    sha256 = from3({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from3({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// core/runtime/files.ts
async function encodeFile(blob) {
  const data = await top_uint8(blob);
  const bytes = encode(data);
  const hash2 = await sha256.digest(bytes);
  const cid = CID.create(1, code, hash2);
  const block = { cid, bytes };
  return { cid, blocks: [block] };
}
function isHasBlockAGet(obj) {
  return typeof obj.get === "function";
}
async function decodeFile(blocks, cid, meta3) {
  if (!isHasBlockAGet(blocks)) {
    return Result.Err(new Error("Invalid block storage"));
  }
  return exception2Result(async () => {
    const bytes = await blocks.get(cid);
    const data = decode(bytes);
    return new File([data], "file", {
      type: meta3.type,
      lastModified: meta3.lastModified || 0
    });
  });
}
var init_files = __esm({
  "core/runtime/files.ts"() {
    "use strict";
    init_raw();
    init_cid();
    init_sha2_browser();
    init_esm();
  }
});

// core/types/base/indexer.ts
var init_indexer = __esm({
  "core/types/base/indexer.ts"() {
    "use strict";
  }
});

// core/types/base/key-bag-if.ts
var init_key_bag_if = __esm({
  "core/types/base/key-bag-if.ts"() {
    "use strict";
  }
});

// core/types/base/types.ts
function isFalsy(value) {
  return value === false || value === null || value === void 0;
}
function throwFalsy(value) {
  if (isFalsy(value)) {
    throw new Error("value is Falsy");
  }
  return value;
}
function falsyToUndef(value) {
  if (isFalsy(value)) {
    return void 0;
  }
  return value;
}
function isKeyUpsertResultModified(r) {
  return r.modified;
}
function defaultWriteQueueOpts(opts = {}) {
  return {
    ...opts,
    chunkSize: opts.chunkSize && opts.chunkSize > 0 ? opts.chunkSize : 32
  };
}
function isNotFoundError(e) {
  if (Result.Is(e)) {
    if (e.isOk()) return false;
    e = e.Err();
  }
  if (e.code === "ENOENT") return true;
  return false;
}
var NotFoundError, PARAM, DataAndMetaAndWalAndBaseStore;
var init_types2 = __esm({
  "core/types/base/types.ts"() {
    "use strict";
    init_esm();
    NotFoundError = class extends Error {
      code = "ENOENT";
    };
    PARAM = {
      SUFFIX: "suffix",
      URL_GEN: "urlGen",
      // "urlGen" | "default"
      STORE_KEY: "storekey",
      STORE: "store",
      KEY: "key",
      INDEX: "index",
      NAME: "name",
      VERSION: "version",
      RUNTIME: "runtime",
      // "node" | "deno" | "browser"
      FRAG_SIZE: "fragSize",
      IV_VERIFY: "ivVerify",
      IV_HASH: "ivHash",
      FRAG_FID: "fid",
      FRAG_OFS: "ofs",
      FRAG_LEN: "len",
      FRAG_HEAD: "headerSize",
      EXTRACTKEY: "extractKey",
      SELF_REFLECT: "selfReflect",
      // if no subscribe in Gateway see your own META updates
      CAR_PARALLEL: "parallel",
      CAR_CACHE_SIZE: "carCacheSize",
      CAR_COMPACT_CACHE_SIZE: "carCompactCacheSize",
      CAR_META_CACHE_SIZE: "carMetaCacheSize",
      GENESIS_CID: "baembeiarootfireproofgenesisblockaaaafireproofgenesisblocka",
      LOCAL_NAME: "localName"
      // FS = "fs",
    };
    DataAndMetaAndWalAndBaseStore = class {
      wal;
      file;
      car;
      meta;
      baseStores;
      constructor(dam) {
        this.wal = dam.wal;
        this.file = dam.file;
        this.car = dam.car;
        this.meta = dam.meta;
        this.baseStores = [this.file, this.car, this.meta];
        if (this.wal) {
          this.baseStores.push(this.wal);
        }
      }
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name2, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name2)) {
      return;
    }
    inst._zod.traits.add(name2);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name2 });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name2);
    }
  });
  Object.defineProperty(_, "name", { value: name2 });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/core.js"() {
    NEVER = Object.freeze({
      status: "aborted"
    });
    $brand = /* @__PURE__ */ Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError = class extends Error {
      constructor(name2) {
        super(`Encountered unidirectional transform during encode: ${name2}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig = {};
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge2,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries4) {
  const numericValues = Object.values(entries4).filter((v) => typeof v === "number");
  const values = Object.entries(entries4).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match2 = stepString.match(/\d?e-(\d?)/);
    if (match2?.[1]) {
      stepDecCount = Number.parseInt(match2[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema4) {
  return mergeDefs(schema4._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length2 = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length2; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema4, mask) {
  const currDef = schema4._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema4, def);
}
function omit(schema4, mask) {
  const currDef = schema4._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const newShape = { ...schema4._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema4, def);
}
function extend(schema4, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema4._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema4._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const _shape = { ...schema4._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema4, def);
}
function safeExtend(schema4, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const _shape = { ...schema4._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema4, def);
}
function merge2(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema4, mask) {
  const currDef = schema4._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const oldShape = schema4._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema4, def);
}
function required(Class2, schema4, mask) {
  const def = mergeDefs(schema4._zod.def, {
    get shape() {
      const oldShape = schema4._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema4, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message2) {
  return typeof message2 === "string" ? message2 : message2?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message2 = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message2;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base644) {
  const binaryString = atob(base644);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url4) {
  const base644 = base64url4.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base644.length % 4) % 4);
  return base64ToUint8Array(base644 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/util.js"() {
    EVALUATING = /* @__PURE__ */ Symbol("evaluating");
    captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/errors.js
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a2, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError2(error48) {
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors2 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/errors.js"() {
    init_core();
    init_util();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/parse.js
var _parse, parse2, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode4, _decode, decode6, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
var init_parse = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/parse.js"() {
    init_core();
    init_errors2();
    init_util();
    _parse = (_Err) => (schema4, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema4._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
      }
      return result.value;
    };
    parse2 = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema4, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema4._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema4, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema4._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema4, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema4._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    _encode = (_Err) => (schema4, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse(_Err)(schema4, value, ctx);
    };
    encode4 = /* @__PURE__ */ _encode($ZodRealError);
    _decode = (_Err) => (schema4, value, _ctx) => {
      return _parse(_Err)(schema4, value, _ctx);
    };
    decode6 = /* @__PURE__ */ _decode($ZodRealError);
    _encodeAsync = (_Err) => async (schema4, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema4, value, ctx);
    };
    encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
    _decodeAsync = (_Err) => async (schema4, value, _ctx) => {
      return _parseAsync(_Err)(schema4, value, _ctx);
    };
    decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
    _safeEncode = (_Err) => (schema4, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema4, value, ctx);
    };
    safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
    _safeDecode = (_Err) => (schema4, value, _ctx) => {
      return _safeParse(_Err)(schema4, value, _ctx);
    };
    safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
    _safeEncodeAsync = (_Err) => async (schema4, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema4, value, ctx);
    };
    safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
    _safeDecodeAsync = (_Err) => async (schema4, value, _ctx) => {
      return _safeParseAsync(_Err)(schema4, value, _ctx);
    };
    safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string2,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length2) {
  return new RegExp(`^[A-Za-z0-9_-]{${length2}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, mac, cidrv4, cidrv6, base64, base64url, hostname, domain, e164, dateSource, date, string2, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/regexes.js"() {
    init_util();
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail = unicodeEmail;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    mac = (delimiter) => {
      const escapedDelim = escapeRegex(delimiter ?? ":");
      return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
    };
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+[1-9]\d{6,14}$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string2 = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint = /^-?\d+n?$/;
    integer = /^-?\d+$/;
    number = /^-?\d+(?:\.\d+)?$/;
    boolean = /^(?:true|false)$/i;
    _null = /^null$/i;
    _undefined = /^undefined$/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
    hex = /^[0-9a-fA-F]*$/;
    md5_hex = /^[0-9a-fA-F]{32}$/;
    md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
    md5_base64url = /* @__PURE__ */ fixedBase64url(22);
    sha1_hex = /^[0-9a-fA-F]{40}$/;
    sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
    sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
    sha256_hex = /^[0-9a-fA-F]{64}$/;
    sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
    sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
    sha384_hex = /^[0-9a-fA-F]{96}$/;
    sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
    sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
    sha512_hex = /^[0-9a-fA-F]{128}$/;
    sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
    sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/checks.js"() {
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a2;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a2;
        (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                inclusive: true,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length2 = input.length;
        if (length2 <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length2 = input.length;
        if (length2 >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length2 = input.length;
        if (length2 === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length2 > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a2, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 3,
      patch: 5
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodXor, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodExactOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core();
    init_doc();
    init_parse();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a2;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      defineLazy(inst, "~standard", () => ({
        validate: (value) => {
          try {
            const r = safeParse(inst, value);
            return r.success ? { value: r.data } : { issues: r.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      }));
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string2(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url2 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: def.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url2.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv4`;
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv6`;
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
      def.pattern ?? (def.pattern = mac(def.delimiter));
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `mac`;
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base64);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64";
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64url";
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
          const field = shape[key]._zod;
          if (field.values) {
            propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key].add(v);
          }
        }
        return propValues;
      });
      const isObject3 = isObject;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject3(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
          const el = shape[key];
          const isOptionalOut = el._zod.optout === "optional";
          const r = el._zod.run({ value: input[key], issues: [] }, ctx);
          if (r instanceof Promise) {
            proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
          } else {
            handlePropertyResult(r, payload, key, input, isOptionalOut);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
          const k = esc(key);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
          ids[key] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
          const id = ids[key];
          const k = esc(key);
          const schema4 = shape[key];
          const isOptionalOut = schema4?._zod?.optout === "optional";
          doc.write(`const ${id} = ${parseStr(key)};`);
          if (isOptionalOut) {
            doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          } else {
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
          }
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject3 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval2 = allowsEval;
      const fastEnabled = jit && allowsEval2.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject3(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
          const patterns = def.options.map((o) => o._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
      $ZodUnion.init(inst, def);
      def.inclusive = false;
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            results.push(result);
          }
        }
        if (!async)
          return handleExclusiveUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleExclusiveUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      def.inclusive = false;
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map3 = /* @__PURE__ */ new Map();
        for (const o of opts) {
          const values = o._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
          for (const v of values) {
            if (map3.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map3.set(v, o);
          }
        }
        return map3;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        const values = def.keyType._zod.values;
        if (values) {
          payload.value = {};
          const recordKeys = /* @__PURE__ */ new Set();
          for (const key of values) {
            if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
              recordKeys.add(typeof key === "number" ? key.toString() : key);
              const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key, result2.issues));
                  }
                  payload.value[key] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key in input) {
            if (!recordKeys.has(key)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key of Reflect.ownKeys(input)) {
            if (key === "__proto__")
              continue;
            let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length && keyResult.issues.some((iss) => iss.code === "invalid_type" && iss.expected === "number");
            if (checkNumericKey) {
              const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
              if (retryResult instanceof Promise) {
                throw new Error("Async schemas not supported in object keys currently");
              }
              if (retryResult.issues.length === 0) {
                keyResult = retryResult;
              }
            }
            if (keyResult.issues.length) {
              if (def.mode === "loose") {
                payload.value[key] = input[key];
              } else {
                payload.issues.push({
                  code: "invalid_key",
                  origin: "record",
                  issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                  input: key,
                  path: [key],
                  inst
                });
              }
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      const values = new Set(def.values);
      inst._zod.values = values;
      inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r) => handleOptionalResult(r, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
      inst._zod.parse = (payload, ctx) => {
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
      defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "string",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse2(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
          return r.then((r2) => handleRefineResult(r2, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error()
  };
}
var error;
var init_ar = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ar.js"() {
    init_util();
    error = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
            }
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_az = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/az.js"() {
    init_util();
    error2 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
            }
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_be = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/be.js"() {
    init_util();
    error3 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u043B\u0456\u043A",
        array: "\u043C\u0430\u0441\u0456\u045E"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
            }
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_bg = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/bg.js"() {
    init_util();
    error4 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
            }
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error5()
  };
}
var error5;
var init_ca = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ca.js"() {
    init_util();
    error5 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
            }
            return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
          case "invalid_element":
            return `Element inv\xE0lid a ${issue2.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_cs = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/cs.js"() {
    init_util();
    error6 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u010D\xEDslo",
        string: "\u0159et\u011Bzec",
        function: "funkce",
        array: "pole"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
            }
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue2.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error7()
  };
}
var error7;
var init_da = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/da.js"() {
    init_util();
    error7 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
            }
            return `Ugyldigt input: forventede ${expected}, fik ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue2.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error8()
  };
}
var error8;
var init_de = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/de.js"() {
    init_util();
    error8 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "Zahl",
        array: "Array"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
            }
            return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue2.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_en = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/en.js"() {
    init_util();
    error9 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" },
        map: { unit: "entries", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        mac: "MAC address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        // Compatibility: "nan" -> "NaN" for display
        nan: "NaN"
        // All other type names omitted - they fall back to raw values via ?? operator
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            return `Invalid input: expected ${expected}, received ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue2.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue2.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error10()
  };
}
var error10;
var init_eo = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/eo.js"() {
    init_util();
    error10 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombro",
        array: "tabelo",
        null: "senvalora"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
            }
            return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue2.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue2.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error11()
  };
}
var error11;
var init_es = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/es.js"() {
    init_util();
    error11 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
            }
            return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_fa = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fa.js"() {
    init_util();
    error12 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0622\u0631\u0627\u06CC\u0647"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
            }
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          }
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fi = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fi.js"() {
    init_util();
    error13 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
            }
            return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_fr = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fr.js"() {
    init_util();
    error14 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombre",
        array: "tableau"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
            }
            return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_fr_CA = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/fr-CA.js"() {
    init_util();
    error15 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
            }
            return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_he = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/he.js"() {
    init_util();
    error16 = () => {
      const TypeNames = {
        string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
        number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
        boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
        bigint: { label: "BigInt", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
        array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
        object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
        null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
        undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
        symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
        function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
        map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
        set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
        file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
        promise: { label: "Promise", gender: "m" },
        NaN: { label: "NaN", gender: "m" },
        unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
        value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
      };
      const Sizable = {
        string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
        // no unit
      };
      const typeEntry = (t) => t ? TypeNames[t] : void 0;
      const typeLabel = (t) => {
        const e = typeEntry(t);
        if (e)
          return e.label;
        return t ?? TypeNames.unknown.label;
      };
      const withDefinite = (t) => `\u05D4${typeLabel(t)}`;
      const verbFor = (t) => {
        const e = typeEntry(t);
        const gender = e?.gender ?? "m";
        return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
      };
      const getSizing = (origin) => {
        if (!origin)
          return null;
        return Sizable[origin] ?? null;
      };
      const FormatDictionary = {
        regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
        url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
        uuid: { label: "UUID", gender: "m" },
        nanoid: { label: "nanoid", gender: "m" },
        guid: { label: "GUID", gender: "m" },
        cuid: { label: "cuid", gender: "m" },
        cuid2: { label: "cuid2", gender: "m" },
        ulid: { label: "ULID", gender: "m" },
        xid: { label: "XID", gender: "m" },
        ksuid: { label: "KSUID", gender: "m" },
        datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
        time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
        duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
        ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
        ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
        cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
        cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
        base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
        base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
        e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
        jwt: { label: "JWT", gender: "m" },
        ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expectedKey = issue2.expected;
            const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
            }
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          case "invalid_value": {
            if (issue2.values.length === 1) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
            }
            const stringified = issue2.values.map((v) => stringifyPrimitive(v));
            if (issue2.values.length === 2) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
            }
            const lastValue = stringified[stringified.length - 1];
            const restValues = stringified.slice(0, -1).join(", ");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
          }
          case "too_big": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? "<=" : "<";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              if (issue2.minimum === 1 && issue2.inclusive) {
                const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
              }
              const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? ">=" : ">";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            const nounEntry = FormatDictionary[_issue.format];
            const noun = nounEntry?.label ?? _issue.format;
            const gender = nounEntry?.gender ?? "m";
            const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
            return `${noun} \u05DC\u05D0 ${adjective}`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key": {
            return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
          }
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element": {
            const place = withDefinite(issue2.origin ?? "array");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
          }
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_hu = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/hu.js"() {
    init_util();
    error17 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "sz\xE1m",
        array: "t\xF6mb"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
            }
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
function hy_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_hy = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/hy.js"() {
    init_util();
    error18 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0576\u0577\u0561\u0576",
            many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        file: {
          unit: {
            one: "\u0562\u0561\u0575\u0569",
            many: "\u0562\u0561\u0575\u0569\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        array: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        },
        set: {
          unit: {
            one: "\u057F\u0561\u0580\u0580",
            many: "\u057F\u0561\u0580\u0580\u0565\u0580"
          },
          verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0574\u0578\u0582\u057F\u0584",
        email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
        url: "URL",
        emoji: "\u0567\u0574\u0578\u057B\u056B",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
        date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
        time: "ISO \u056A\u0561\u0574",
        duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
        ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
        ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
        cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
        base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
        json_string: "JSON \u057F\u0578\u0572",
        e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
        jwt: "JWT",
        template_literal: "\u0574\u0578\u0582\u057F\u0584"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0569\u056B\u057E",
        array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
            }
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
            return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
              return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
            if (_issue.format === "ends_with")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
            if (_issue.format === "includes")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
            return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
          case "unrecognized_keys":
            return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
          case "invalid_union":
            return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
          case "invalid_element":
            return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
          default:
            return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_id = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/id.js"() {
    init_util();
    error19 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
            }
            return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue2.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var error20;
var init_is = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/is.js"() {
    init_util();
    error20 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmer",
        array: "fylki"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
            }
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue2.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue2.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_it = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/it.js"() {
    init_util();
    error21 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numero",
        array: "vettore"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
            }
            return `Input non valido: atteso ${expected}, ricevuto ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue2.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue2.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ja = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ja.js"() {
    init_util();
    error22 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5024",
        array: "\u914D\u5217"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
            }
            return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var error23;
var init_ka = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ka.js"() {
    init_util();
    error23 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
        array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
            }
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_km = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/km.js"() {
    init_util();
    error24 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u179B\u17C1\u1781",
        array: "\u17A2\u17B6\u179A\u17C1 (Array)",
        null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
            }
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/kh.js"() {
    init_km();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ko = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ko.js"() {
    init_util();
    error25 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
            }
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var capitalizeFirstCharacter, error26;
var init_lt = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/lt.js"() {
    init_util();
    capitalizeFirstCharacter = (text2) => {
      return text2.charAt(0).toUpperCase() + text2.slice(1);
    };
    error26 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const FormatDictionary = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "skai\u010Dius",
        bigint: "sveikasis skai\u010Dius",
        string: "eilut\u0117",
        boolean: "login\u0117 reik\u0161m\u0117",
        undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
        function: "funkcija",
        symbol: "simbolis",
        array: "masyvas",
        object: "objektas",
        null: "nulin\u0117 reik\u0161m\u0117"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
            }
            return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_mk = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/mk.js"() {
    init_util();
    error27 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0431\u0440\u043E\u0458",
        array: "\u043D\u0438\u0437\u0430"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
            }
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_ms = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ms.js"() {
    init_util();
    error28 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "nombor"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
            }
            return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue2.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_nl = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/nl.js"() {
    init_util();
    error29 = () => {
      const Sizable = {
        string: { unit: "tekens", verb: "heeft" },
        file: { unit: "bytes", verb: "heeft" },
        array: { unit: "elementen", verb: "heeft" },
        set: { unit: "elementen", verb: "heeft" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "getal"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
            }
            return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
            if (sizing)
              return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
            return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
            if (sizing) {
              return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue2.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue2.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_no = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/no.js"() {
    init_util();
    error30 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "tall",
        array: "liste"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
            }
            return `Ugyldig input: forventet ${expected}, fikk ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue2.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_ota = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ota.js"() {
    init_util();
    error31 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "numara",
        array: "saf",
        null: "gayb"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
            }
            return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ps = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ps.js"() {
    init_util();
    error32 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0639\u062F\u062F",
        array: "\u0627\u0631\u06D0"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
            }
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          }
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_pl = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/pl.js"() {
    init_util();
    error33 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "liczba",
        array: "tablica"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
            }
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34;
var init_pt = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/pt.js"() {
    init_util();
    error34 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\xFAmero",
        null: "nulo"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
            }
            return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue2.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ru = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ru.js"() {
    init_util();
    error35 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_sl = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/sl.js"() {
    init_util();
    error36 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0161tevilo",
        array: "tabela"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
            }
            return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue2.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_sv = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/sv.js"() {
    init_util();
    error37 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "antal",
        array: "lista"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
            }
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_ta = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ta.js"() {
    init_util();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0B8E\u0BA3\u0BCD",
        array: "\u0B85\u0BA3\u0BBF",
        null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
            }
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_th = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/th.js"() {
    init_util();
    error39 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
        array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
        null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
            }
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var error40;
var init_tr = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/tr.js"() {
    init_util();
    error40 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
            }
            return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41;
var init_uk = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/uk.js"() {
    init_util();
    error41 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0447\u0438\u0441\u043B\u043E",
        array: "\u043C\u0430\u0441\u0438\u0432"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
            }
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ua.js"() {
    init_uk();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42;
var init_ur = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/ur.js"() {
    init_util();
    error42 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u0646\u0645\u0628\u0631",
        array: "\u0622\u0631\u06D2",
        null: "\u0646\u0644"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
            }
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/uz.js
function uz_default() {
  return {
    localeError: error43()
  };
}
var error43;
var init_uz = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/uz.js"() {
    init_util();
    error43 = () => {
      const Sizable = {
        string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
        file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
        array: { unit: "element", verb: "bo\u2018lishi kerak" },
        set: { unit: "element", verb: "bo\u2018lishi kerak" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "kirish",
        email: "elektron pochta manzili",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO sana va vaqti",
        date: "ISO sana",
        time: "ISO vaqt",
        duration: "ISO davomiylik",
        ipv4: "IPv4 manzil",
        ipv6: "IPv6 manzil",
        mac: "MAC manzil",
        cidrv4: "IPv4 diapazon",
        cidrv6: "IPv6 diapazon",
        base64: "base64 kodlangan satr",
        base64url: "base64url kodlangan satr",
        json_string: "JSON satr",
        e164: "E.164 raqam",
        jwt: "JWT",
        template_literal: "kirish"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "raqam",
        array: "massiv"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
            }
            return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
            return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
            return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
            }
            return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
            if (_issue.format === "ends_with")
              return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
            if (_issue.format === "includes")
              return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
            if (_issue.format === "regex")
              return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
            return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
          case "unrecognized_keys":
            return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
          case "invalid_union":
            return "Noto\u2018g\u2018ri kirish";
          case "invalid_element":
            return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
          default:
            return `Noto\u2018g\u2018ri kirish`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error44()
  };
}
var error44;
var init_vi = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/vi.js"() {
    init_util();
    error44 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "s\u1ED1",
        array: "m\u1EA3ng"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
            }
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error45()
  };
}
var error45;
var init_zh_CN = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/zh-CN.js"() {
    init_util();
    error45 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "\u6570\u5B57",
        array: "\u6570\u7EC4",
        null: "\u7A7A\u503C(null)"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
            }
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error46()
  };
}
var error46;
var init_zh_TW = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/zh-TW.js"() {
    init_util();
    error46 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      const TypeDictionary = {
        nan: "NaN"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
            }
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error47()
  };
}
var error47;
var init_yo = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/yo.js"() {
    init_util();
    error47 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const FormatDictionary = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      const TypeDictionary = {
        nan: "NaN",
        number: "n\u1ECD\u0301mb\xE0",
        array: "akop\u1ECD"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
            const receivedType = parsedType(issue2.input);
            const received = TypeDictionary[receivedType] ?? receivedType;
            if (/^[A-Z]/.test(issue2.expected)) {
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
            }
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
          }
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_bg();
    init_ca();
    init_cs();
    init_da();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_hy();
    init_id();
    init_is();
    init_it();
    init_ja();
    init_ka();
    init_kh();
    init_km();
    init_ko();
    init_lt();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_uk();
    init_ur();
    init_uz();
    init_vi();
    init_zh_CN();
    init_zh_TW();
    init_yo();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var _a, $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/registries.js"() {
    $output = /* @__PURE__ */ Symbol("ZodOutput");
    $input = /* @__PURE__ */ Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema4, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema4, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.set(meta3.id, schema4);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema4) {
        const meta3 = this._map.get(schema4);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema4);
        return this;
      }
      get(schema4) {
        const p = schema4._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema4) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema4);
      }
      has(schema4) {
        return this._map.has(schema4);
      }
    };
    (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
    globalRegistry = globalThis.__zod_globalRegistry;
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length2, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length: length2
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema4, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema: schema4,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
// @__NO_SIDE_EFFECTS__
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _enum(Class2, values, params) {
  const entries4 = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries: entries4,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class2, entries4, params) {
  return new Class2({
    type: "enum",
    entries: entries4,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
// @__NO_SIDE_EFFECTS__
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
// @__NO_SIDE_EFFECTS__
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
// @__NO_SIDE_EFFECTS__
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
// @__NO_SIDE_EFFECTS__
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema4 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema4;
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  const schema4 = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema4;
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: ((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }),
    reverseTransform: ((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }),
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format3, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format3,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_registries();
    init_schemas();
    init_util();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process(schema4, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema4._zod.def;
  const seen = ctx.seen.get(schema4);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema4);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema4, result);
  const overrideSchema = schema4._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema4],
      path: _params.path
    };
    if (schema4._zod.processJSONSchema) {
      schema4._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema4, ctx, _json, params);
    }
    const parent = schema4._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema4);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema4)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema4);
  return _result.schema;
}
function extractDefs(ctx, schema4) {
  const root2 = ctx.seen.get(schema4);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root2) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema5 = seen.schema;
    for (const key in schema5) {
      delete schema5[key];
    }
    schema5.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema4 === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema4 !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema4) {
  const root2 = ctx.seen.get(schema4);
  if (!root2)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema5 = seen.def ?? seen.schema;
    const _cached = { ...schema5 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema5.allOf = schema5.allOf ?? [];
        schema5.allOf.push(refSchema);
      } else {
        Object.assign(schema5, refSchema);
      }
      Object.assign(schema5, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema5) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema5[key];
          }
        }
      }
      if (refSchema.$ref) {
        for (const key in schema5) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema5[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema5[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema5.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema5) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema5[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema5[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema5,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id = ctx.external.registry.get(schema4)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root2.def ?? root2.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema4["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema4, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema4, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod, createStandardJSONSchemaMethod;
var init_to_json_schema = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    createToJSONSchemaMethod = (schema4, processors = {}) => (params) => {
      const ctx = initializeContext({ ...params, processors });
      process(schema4, ctx);
      extractDefs(ctx, schema4);
      return finalize(ctx, schema4);
    };
    createStandardJSONSchemaMethod = (schema4, io, processors = {}) => (params) => {
      const { libraryOptions, target } = params ?? {};
      const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
      process(schema4, ctx);
      extractDefs(ctx, schema4);
      return finalize(ctx, schema4);
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema-processors.js
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema4] = entry;
      process(schema4, ctx2);
    }
    const schemas2 = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema4] = entry;
      extractDefs(ctx2, schema4);
      schemas2[key] = finalize(ctx2, schema4);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas2.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas: schemas2 };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
var formatMap, stringProcessor, numberProcessor, booleanProcessor, bigintProcessor, symbolProcessor, nullProcessor, undefinedProcessor, voidProcessor, neverProcessor, anyProcessor, unknownProcessor, dateProcessor, enumProcessor, literalProcessor, nanProcessor, templateLiteralProcessor, fileProcessor, successProcessor, customProcessor, functionProcessor, transformProcessor, mapProcessor, setProcessor, arrayProcessor, objectProcessor, unionProcessor, intersectionProcessor, tupleProcessor, recordProcessor, nullableProcessor, nonoptionalProcessor, defaultProcessor, prefaultProcessor, catchProcessor, pipeProcessor, readonlyProcessor, promiseProcessor, optionalProcessor, lazyProcessor, allProcessors;
var init_json_schema_processors = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema-processors.js"() {
    init_to_json_schema();
    init_util();
    formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    stringProcessor = (schema4, ctx, _json, _params) => {
      const json2 = _json;
      json2.type = "string";
      const { minimum, maximum, format: format3, patterns, contentEncoding } = schema4._zod.bag;
      if (typeof minimum === "number")
        json2.minLength = minimum;
      if (typeof maximum === "number")
        json2.maxLength = maximum;
      if (format3) {
        json2.format = formatMap[format3] ?? format3;
        if (json2.format === "")
          delete json2.format;
        if (format3 === "time") {
          delete json2.format;
        }
      }
      if (contentEncoding)
        json2.contentEncoding = contentEncoding;
      if (patterns && patterns.size > 0) {
        const regexes = [...patterns];
        if (regexes.length === 1)
          json2.pattern = regexes[0].source;
        else if (regexes.length > 1) {
          json2.allOf = [
            ...regexes.map((regex) => ({
              ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
              pattern: regex.source
            }))
          ];
        }
      }
    };
    numberProcessor = (schema4, ctx, _json, _params) => {
      const json2 = _json;
      const { minimum, maximum, format: format3, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema4._zod.bag;
      if (typeof format3 === "string" && format3.includes("int"))
        json2.type = "integer";
      else
        json2.type = "number";
      if (typeof exclusiveMinimum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json2.minimum = exclusiveMinimum;
          json2.exclusiveMinimum = true;
        } else {
          json2.exclusiveMinimum = exclusiveMinimum;
        }
      }
      if (typeof minimum === "number") {
        json2.minimum = minimum;
        if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMinimum >= minimum)
            delete json2.minimum;
          else
            delete json2.exclusiveMinimum;
        }
      }
      if (typeof exclusiveMaximum === "number") {
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json2.maximum = exclusiveMaximum;
          json2.exclusiveMaximum = true;
        } else {
          json2.exclusiveMaximum = exclusiveMaximum;
        }
      }
      if (typeof maximum === "number") {
        json2.maximum = maximum;
        if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
          if (exclusiveMaximum <= maximum)
            delete json2.maximum;
          else
            delete json2.exclusiveMaximum;
        }
      }
      if (typeof multipleOf === "number")
        json2.multipleOf = multipleOf;
    };
    booleanProcessor = (_schema, _ctx, json2, _params) => {
      json2.type = "boolean";
    };
    bigintProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt cannot be represented in JSON Schema");
      }
    };
    symbolProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Symbols cannot be represented in JSON Schema");
      }
    };
    nullProcessor = (_schema, ctx, json2, _params) => {
      if (ctx.target === "openapi-3.0") {
        json2.type = "string";
        json2.nullable = true;
        json2.enum = [null];
      } else {
        json2.type = "null";
      }
    };
    undefinedProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Undefined cannot be represented in JSON Schema");
      }
    };
    voidProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Void cannot be represented in JSON Schema");
      }
    };
    neverProcessor = (_schema, _ctx, json2, _params) => {
      json2.not = {};
    };
    anyProcessor = (_schema, _ctx, _json, _params) => {
    };
    unknownProcessor = (_schema, _ctx, _json, _params) => {
    };
    dateProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Date cannot be represented in JSON Schema");
      }
    };
    enumProcessor = (schema4, _ctx, json2, _params) => {
      const def = schema4._zod.def;
      const values = getEnumValues(def.entries);
      if (values.every((v) => typeof v === "number"))
        json2.type = "number";
      if (values.every((v) => typeof v === "string"))
        json2.type = "string";
      json2.enum = values;
    };
    literalProcessor = (schema4, ctx, json2, _params) => {
      const def = schema4._zod.def;
      const vals = [];
      for (const val of def.values) {
        if (val === void 0) {
          if (ctx.unrepresentable === "throw") {
            throw new Error("Literal `undefined` cannot be represented in JSON Schema");
          } else {
          }
        } else if (typeof val === "bigint") {
          if (ctx.unrepresentable === "throw") {
            throw new Error("BigInt literals cannot be represented in JSON Schema");
          } else {
            vals.push(Number(val));
          }
        } else {
          vals.push(val);
        }
      }
      if (vals.length === 0) {
      } else if (vals.length === 1) {
        const val = vals[0];
        json2.type = val === null ? "null" : typeof val;
        if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
          json2.enum = [val];
        } else {
          json2.const = val;
        }
      } else {
        if (vals.every((v) => typeof v === "number"))
          json2.type = "number";
        if (vals.every((v) => typeof v === "string"))
          json2.type = "string";
        if (vals.every((v) => typeof v === "boolean"))
          json2.type = "boolean";
        if (vals.every((v) => v === null))
          json2.type = "null";
        json2.enum = vals;
      }
    };
    nanProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("NaN cannot be represented in JSON Schema");
      }
    };
    templateLiteralProcessor = (schema4, _ctx, json2, _params) => {
      const _json = json2;
      const pattern = schema4._zod.pattern;
      if (!pattern)
        throw new Error("Pattern not found in template literal");
      _json.type = "string";
      _json.pattern = pattern.source;
    };
    fileProcessor = (schema4, _ctx, json2, _params) => {
      const _json = json2;
      const file2 = {
        type: "string",
        format: "binary",
        contentEncoding: "binary"
      };
      const { minimum, maximum, mime } = schema4._zod.bag;
      if (minimum !== void 0)
        file2.minLength = minimum;
      if (maximum !== void 0)
        file2.maxLength = maximum;
      if (mime) {
        if (mime.length === 1) {
          file2.contentMediaType = mime[0];
          Object.assign(_json, file2);
        } else {
          Object.assign(_json, file2);
          _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
        }
      } else {
        Object.assign(_json, file2);
      }
    };
    successProcessor = (_schema, _ctx, json2, _params) => {
      json2.type = "boolean";
    };
    customProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Custom types cannot be represented in JSON Schema");
      }
    };
    functionProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Function types cannot be represented in JSON Schema");
      }
    };
    transformProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Transforms cannot be represented in JSON Schema");
      }
    };
    mapProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Map cannot be represented in JSON Schema");
      }
    };
    setProcessor = (_schema, ctx, _json, _params) => {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Set cannot be represented in JSON Schema");
      }
    };
    arrayProcessor = (schema4, ctx, _json, params) => {
      const json2 = _json;
      const def = schema4._zod.def;
      const { minimum, maximum } = schema4._zod.bag;
      if (typeof minimum === "number")
        json2.minItems = minimum;
      if (typeof maximum === "number")
        json2.maxItems = maximum;
      json2.type = "array";
      json2.items = process(def.element, ctx, { ...params, path: [...params.path, "items"] });
    };
    objectProcessor = (schema4, ctx, _json, params) => {
      const json2 = _json;
      const def = schema4._zod.def;
      json2.type = "object";
      json2.properties = {};
      const shape = def.shape;
      for (const key in shape) {
        json2.properties[key] = process(shape[key], ctx, {
          ...params,
          path: [...params.path, "properties", key]
        });
      }
      const allKeys = new Set(Object.keys(shape));
      const requiredKeys = new Set([...allKeys].filter((key) => {
        const v = def.shape[key]._zod;
        if (ctx.io === "input") {
          return v.optin === void 0;
        } else {
          return v.optout === void 0;
        }
      }));
      if (requiredKeys.size > 0) {
        json2.required = Array.from(requiredKeys);
      }
      if (def.catchall?._zod.def.type === "never") {
        json2.additionalProperties = false;
      } else if (!def.catchall) {
        if (ctx.io === "output")
          json2.additionalProperties = false;
      } else if (def.catchall) {
        json2.additionalProperties = process(def.catchall, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
    };
    unionProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      const isExclusive = def.inclusive === false;
      const options = def.options.map((x, i) => process(x, ctx, {
        ...params,
        path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
      }));
      if (isExclusive) {
        json2.oneOf = options;
      } else {
        json2.anyOf = options;
      }
    };
    intersectionProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      const a = process(def.left, ctx, {
        ...params,
        path: [...params.path, "allOf", 0]
      });
      const b = process(def.right, ctx, {
        ...params,
        path: [...params.path, "allOf", 1]
      });
      const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
      const allOf = [
        ...isSimpleIntersection(a) ? a.allOf : [a],
        ...isSimpleIntersection(b) ? b.allOf : [b]
      ];
      json2.allOf = allOf;
    };
    tupleProcessor = (schema4, ctx, _json, params) => {
      const json2 = _json;
      const def = schema4._zod.def;
      json2.type = "array";
      const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
      const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
      const prefixItems = def.items.map((x, i) => process(x, ctx, {
        ...params,
        path: [...params.path, prefixPath, i]
      }));
      const rest = def.rest ? process(def.rest, ctx, {
        ...params,
        path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
      }) : null;
      if (ctx.target === "draft-2020-12") {
        json2.prefixItems = prefixItems;
        if (rest) {
          json2.items = rest;
        }
      } else if (ctx.target === "openapi-3.0") {
        json2.items = {
          anyOf: prefixItems
        };
        if (rest) {
          json2.items.anyOf.push(rest);
        }
        json2.minItems = prefixItems.length;
        if (!rest) {
          json2.maxItems = prefixItems.length;
        }
      } else {
        json2.items = prefixItems;
        if (rest) {
          json2.additionalItems = rest;
        }
      }
      const { minimum, maximum } = schema4._zod.bag;
      if (typeof minimum === "number")
        json2.minItems = minimum;
      if (typeof maximum === "number")
        json2.maxItems = maximum;
    };
    recordProcessor = (schema4, ctx, _json, params) => {
      const json2 = _json;
      const def = schema4._zod.def;
      json2.type = "object";
      const keyType = def.keyType;
      const keyBag = keyType._zod.bag;
      const patterns = keyBag?.patterns;
      if (def.mode === "loose" && patterns && patterns.size > 0) {
        const valueSchema = process(def.valueType, ctx, {
          ...params,
          path: [...params.path, "patternProperties", "*"]
        });
        json2.patternProperties = {};
        for (const pattern of patterns) {
          json2.patternProperties[pattern.source] = valueSchema;
        }
      } else {
        if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
          json2.propertyNames = process(def.keyType, ctx, {
            ...params,
            path: [...params.path, "propertyNames"]
          });
        }
        json2.additionalProperties = process(def.valueType, ctx, {
          ...params,
          path: [...params.path, "additionalProperties"]
        });
      }
      const keyValues = keyType._zod.values;
      if (keyValues) {
        const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
        if (validKeyValues.length > 0) {
          json2.required = validKeyValues;
        }
      }
    };
    nullableProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      const inner = process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      if (ctx.target === "openapi-3.0") {
        seen.ref = def.innerType;
        json2.nullable = true;
      } else {
        json2.anyOf = [inner, { type: "null" }];
      }
    };
    nonoptionalProcessor = (schema4, ctx, _json, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
    };
    defaultProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
      json2.default = JSON.parse(JSON.stringify(def.defaultValue));
    };
    prefaultProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
      if (ctx.io === "input")
        json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
    };
    catchProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
      let catchValue;
      try {
        catchValue = def.catchValue(void 0);
      } catch {
        throw new Error("Dynamic catch values are not supported in JSON Schema");
      }
      json2.default = catchValue;
    };
    pipeProcessor = (schema4, ctx, _json, params) => {
      const def = schema4._zod.def;
      const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
      process(innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = innerType;
    };
    readonlyProcessor = (schema4, ctx, json2, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
      json2.readOnly = true;
    };
    promiseProcessor = (schema4, ctx, _json, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
    };
    optionalProcessor = (schema4, ctx, _json, params) => {
      const def = schema4._zod.def;
      process(def.innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = def.innerType;
    };
    lazyProcessor = (schema4, ctx, _json, params) => {
      const innerType = schema4._zod.innerType;
      process(innerType, ctx, params);
      const seen = ctx.seen.get(schema4);
      seen.ref = innerType;
    };
    allProcessors = {
      string: stringProcessor,
      number: numberProcessor,
      boolean: booleanProcessor,
      bigint: bigintProcessor,
      symbol: symbolProcessor,
      null: nullProcessor,
      undefined: undefinedProcessor,
      void: voidProcessor,
      never: neverProcessor,
      any: anyProcessor,
      unknown: unknownProcessor,
      date: dateProcessor,
      enum: enumProcessor,
      literal: literalProcessor,
      nan: nanProcessor,
      template_literal: templateLiteralProcessor,
      file: fileProcessor,
      success: successProcessor,
      custom: customProcessor,
      function: functionProcessor,
      transform: transformProcessor,
      map: mapProcessor,
      set: setProcessor,
      array: arrayProcessor,
      object: objectProcessor,
      union: unionProcessor,
      intersection: intersectionProcessor,
      tuple: tupleProcessor,
      record: recordProcessor,
      nullable: nullableProcessor,
      nonoptional: nonoptionalProcessor,
      default: defaultProcessor,
      prefault: prefaultProcessor,
      catch: catchProcessor,
      pipe: pipeProcessor,
      readonly: readonlyProcessor,
      promise: promiseProcessor,
      optional: optionalProcessor,
      lazy: lazyProcessor
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator;
var init_json_schema_generator = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema-generator.js"() {
    init_json_schema_processors();
    init_to_json_schema();
    JSONSchemaGenerator = class {
      /** @deprecated Access via ctx instead */
      get metadataRegistry() {
        return this.ctx.metadataRegistry;
      }
      /** @deprecated Access via ctx instead */
      get target() {
        return this.ctx.target;
      }
      /** @deprecated Access via ctx instead */
      get unrepresentable() {
        return this.ctx.unrepresentable;
      }
      /** @deprecated Access via ctx instead */
      get override() {
        return this.ctx.override;
      }
      /** @deprecated Access via ctx instead */
      get io() {
        return this.ctx.io;
      }
      /** @deprecated Access via ctx instead */
      get counter() {
        return this.ctx.counter;
      }
      set counter(value) {
        this.ctx.counter = value;
      }
      /** @deprecated Access via ctx instead */
      get seen() {
        return this.ctx.seen;
      }
      constructor(params) {
        let normalizedTarget = params?.target ?? "draft-2020-12";
        if (normalizedTarget === "draft-4")
          normalizedTarget = "draft-04";
        if (normalizedTarget === "draft-7")
          normalizedTarget = "draft-07";
        this.ctx = initializeContext({
          processors: allProcessors,
          target: normalizedTarget,
          ...params?.metadata && { metadata: params.metadata },
          ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
          ...params?.override && { override: params.override },
          ...params?.io && { io: params.io }
        });
      }
      /**
       * Process a schema to prepare it for JSON Schema generation.
       * This must be called before emit().
       */
      process(schema4, _params = { path: [], schemaPath: [] }) {
        return process(schema4, this.ctx, _params);
      }
      /**
       * Emit the final JSON Schema after processing.
       * Must call process() first.
       */
      emit(schema4, _params) {
        if (_params) {
          if (_params.cycles)
            this.ctx.cycles = _params.cycles;
          if (_params.reused)
            this.ctx.reused = _params.reused;
          if (_params.external)
            this.ctx.external = _params.external;
        }
        extractDefs(this.ctx, schema4);
        const result = finalize(this.ctx, schema4);
        const { "~standard": _, ...plainResult } = result;
        return plainResult;
      }
    };
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode6,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode4,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError2,
  process: () => process,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core2 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/core/index.js"() {
    init_core();
    init_parse();
    init_errors2();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_api();
    init_to_json_schema();
    init_json_schema_processors();
    init_json_schema_generator();
    init_json_schema();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});
var init_checks2 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/checks.js"() {
    init_core2();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/iso.js"() {
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors3 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/errors.js"() {
    init_core2();
    init_core2();
    init_util();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => {
            inst.issues.push(issue2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/parse.js
var parse3, parseAsync2, safeParse2, safeParseAsync2, encode5, decode7, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse2 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/parse.js"() {
    init_core2();
    init_errors3();
    parse3 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    encode5 = /* @__PURE__ */ _encode(ZodRealError);
    decode7 = /* @__PURE__ */ _decode(ZodRealError);
    encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
    decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
    safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
    safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
    safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
    safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int3,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map2,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set2,
  strictObject: () => strictObject,
  string: () => string3,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
function string3(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base642(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format3, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format3, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format3 = `${alg}_${enc}`;
  const regex = regexes_exports[format3];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format3}`);
  return _stringFormat(ZodCustomStringFormat, format3, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int3(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema4) {
  const shape = schema4._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
function map2(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set2(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries4 = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries: entries4,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries4, params) {
  return new ZodEnum({
    type: "enum",
    entries: entries4,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string3(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string3(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema4) {
  return pipe(transform(fn), schema4);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodXor, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodExactOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool;
var init_schemas2 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/schemas.js"() {
    init_core2();
    init_core2();
    init_json_schema_processors();
    init_to_json_schema();
    init_checks2();
    init_iso();
    init_parse2();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      Object.assign(inst["~standard"], {
        jsonSchema: {
          input: createStandardJSONSchemaMethod(inst, "input"),
          output: createStandardJSONSchemaMethod(inst, "output")
        }
      });
      inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(util_exports.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }), {
          parent: true
        });
      };
      inst.with = inst.check;
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = ((reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      });
      inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode5(inst, data, params);
      inst.decode = (data, params) => decode7(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.exactOptional = () => exactOptional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      inst.apply = (fn) => fn(inst);
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
      inst.slugify = () => inst.check(_slugify());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
      $ZodMAC.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int3(params));
      inst.safe = (params) => inst.check(int3(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
    });
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
    });
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
    });
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
    });
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
    });
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
    });
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
    });
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
    });
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c = inst._zod.bag;
      inst.minDate = c.minimum ? new Date(c.minimum) : null;
      inst.maxDate = c.maximum ? new Date(c.maximum) : null;
    });
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
      util_exports.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
      inst.options = def.options;
    });
    ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodXor.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
    });
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue2) => {
          if (typeof issue2 === "string") {
            payload.issues.push(util_exports.issue(issue2, payload.value, def));
          } else {
            const _issue = issue2;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
      $ZodExactOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
    });
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
    });
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
    });
    describe2 = describe;
    meta2 = meta;
    stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString
    }, ...args);
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/compat.js
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/compat.js"() {
    init_core2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/from-json-schema.js
function detectVersion(schema4, defaultTarget) {
  const $schema = schema4.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema4, ctx) {
  if (schema4.not !== void 0) {
    if (typeof schema4.not === "object" && Object.keys(schema4.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema4.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema4.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema4.if !== void 0 || schema4.then !== void 0 || schema4.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema4.dependentSchemas !== void 0 || schema4.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema4.$ref) {
    const refPath = schema4.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema4.enum !== void 0) {
    const enumValues = schema4.enum;
    if (ctx.version === "openapi-3.0" && schema4.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema4.const !== void 0) {
    return z.literal(schema4.const);
  }
  const type = schema4.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema4, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema4.format) {
        const format3 = schema4.format;
        if (format3 === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format3 === "uri" || format3 === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format3 === "uuid" || format3 === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format3 === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format3 === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format3 === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format3 === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format3 === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format3 === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format3 === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format3 === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format3 === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format3 === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format3 === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format3 === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format3 === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format3 === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format3 === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format3 === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format3 === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format3 === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format3 === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format3 === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema4.minLength === "number") {
        stringSchema = stringSchema.min(schema4.minLength);
      }
      if (typeof schema4.maxLength === "number") {
        stringSchema = stringSchema.max(schema4.maxLength);
      }
      if (schema4.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema4.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema4.minimum === "number") {
        numberSchema = numberSchema.min(schema4.minimum);
      }
      if (typeof schema4.maximum === "number") {
        numberSchema = numberSchema.max(schema4.maximum);
      }
      if (typeof schema4.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema4.exclusiveMinimum);
      } else if (schema4.exclusiveMinimum === true && typeof schema4.minimum === "number") {
        numberSchema = numberSchema.gt(schema4.minimum);
      }
      if (typeof schema4.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema4.exclusiveMaximum);
      } else if (schema4.exclusiveMaximum === true && typeof schema4.maximum === "number") {
        numberSchema = numberSchema.lt(schema4.maximum);
      }
      if (typeof schema4.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema4.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema4.properties || {};
      const requiredSet = new Set(schema4.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema4.propertyNames) {
        const keySchema = convertSchema(schema4.propertyNames, ctx);
        const valueSchema = schema4.additionalProperties && typeof schema4.additionalProperties === "object" ? convertSchema(schema4.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema4.patternProperties) {
        const patternProps = schema4.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema4.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema4.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema4.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema4.prefixItems;
      const items = schema4.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema4.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema4.minItems));
        }
        if (typeof schema4.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema4.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema4.additionalItems && typeof schema4.additionalItems === "object" ? convertSchema(schema4.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema4.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema4.minItems));
        }
        if (typeof schema4.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema4.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema4.minItems === "number") {
          arraySchema = arraySchema.min(schema4.minItems);
        }
        if (typeof schema4.maxItems === "number") {
          arraySchema = arraySchema.max(schema4.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema4.description) {
    zodSchema = zodSchema.describe(schema4.description);
  }
  if (schema4.default !== void 0) {
    zodSchema = zodSchema.default(schema4.default);
  }
  return zodSchema;
}
function convertSchema(schema4, ctx) {
  if (typeof schema4 === "boolean") {
    return schema4 ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema4, ctx);
  const hasExplicitType = schema4.type || schema4.enum !== void 0 || schema4.const !== void 0;
  if (schema4.anyOf && Array.isArray(schema4.anyOf)) {
    const options = schema4.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema4.oneOf && Array.isArray(schema4.oneOf)) {
    const options = schema4.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema4.allOf && Array.isArray(schema4.allOf)) {
    if (schema4.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema4.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema4.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema4.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema4.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema4.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema4) {
      extraMeta[key] = schema4[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema4) {
      extraMeta[key] = schema4[key];
    }
  }
  for (const key of Object.keys(schema4)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema4[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema4, params) {
  if (typeof schema4 === "boolean") {
    return schema4 ? z.any() : z.never();
  }
  const version2 = detectVersion(schema4, params?.defaultTarget);
  const defs = schema4.$defs || schema4.definitions || {};
  const ctx = {
    version: version2,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema4,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema4, ctx);
}
var z, RECOGNIZED_KEYS;
var init_from_json_schema = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/from-json-schema.js"() {
    init_registries();
    init_checks2();
    init_iso();
    init_schemas2();
    z = {
      ...schemas_exports2,
      ...checks_exports2,
      iso: iso_exports
    };
    RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
      // Schema identification
      "$schema",
      "$ref",
      "$defs",
      "definitions",
      // Core schema keywords
      "$id",
      "id",
      "$comment",
      "$anchor",
      "$vocabulary",
      "$dynamicRef",
      "$dynamicAnchor",
      // Type
      "type",
      "enum",
      "const",
      // Composition
      "anyOf",
      "oneOf",
      "allOf",
      "not",
      // Object
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "propertyNames",
      "minProperties",
      "maxProperties",
      // Array
      "items",
      "prefixItems",
      "additionalItems",
      "minItems",
      "maxItems",
      "uniqueItems",
      "contains",
      "minContains",
      "maxContains",
      // String
      "minLength",
      "maxLength",
      "pattern",
      "format",
      // Number
      "minimum",
      "maximum",
      "exclusiveMinimum",
      "exclusiveMaximum",
      "multipleOf",
      // Already handled metadata
      "description",
      "default",
      // Content
      "contentEncoding",
      "contentMediaType",
      "contentSchema",
      // Unsupported (error-throwing)
      "unevaluatedItems",
      "unevaluatedProperties",
      "if",
      "then",
      "else",
      "dependentSchemas",
      "dependentRequired",
      // OpenAPI
      "nullable",
      "readOnly"
    ]);
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string4
});
function string4(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/coerce.js"() {
    init_core2();
    init_schemas2();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode7,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode5,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int3,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map2,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError2,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set2,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string3,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});
var init_external = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/external.js"() {
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors3();
    init_parse2();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_json_schema_processors();
    init_from_json_schema();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default());
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/index.js
var init_classic = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/classic/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/index.js
var init_v4 = __esm({
  "node_modules/.pnpm/zod@4.3.5/node_modules/zod/v4/index.js"() {
    init_classic();
    init_classic();
  }
});

// core/types/base/jwt-payload.zod.ts
var JWTPayloadSchema, OpenJWTPayloadSchema;
var init_jwt_payload_zod = __esm({
  "core/types/base/jwt-payload.zod.ts"() {
    "use strict";
    init_v4();
    JWTPayloadSchema = external_exports.object({
      azp: external_exports.string().optional(),
      // authorized party
      iss: external_exports.string().optional(),
      // issuer
      sub: external_exports.string().optional(),
      // subject
      aud: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional(),
      // audience
      exp: external_exports.number().int().optional(),
      // expiration time
      nbf: external_exports.number().int().optional(),
      // not before
      iat: external_exports.number().int().optional(),
      // issued at
      jti: external_exports.string().optional()
      // JWT ID
    });
    OpenJWTPayloadSchema = external_exports.intersection(
      JWTPayloadSchema,
      external_exports.record(external_exports.string(), external_exports.any())
      // Custom claims
    );
  }
});

// core/types/base/jwk-public.zod.ts
var JWKPublicSchema, KeyesJWKPublicSchema;
var init_jwk_public_zod = __esm({
  "core/types/base/jwk-public.zod.ts"() {
    "use strict";
    init_esm();
    init_v4();
    JWKPublicSchema = external_exports.object({
      kty: external_exports.enum(["RSA", "EC", "oct", "OKP"]),
      use: external_exports.enum(["sig", "enc"]).optional(),
      key_ops: external_exports.array(external_exports.enum(["sign", "verify", "encrypt", "decrypt", "wrapKey", "unwrapKey", "deriveKey", "deriveBits"])).optional(),
      alg: external_exports.string().optional(),
      kid: external_exports.string().optional(),
      x5u: external_exports.string().url().optional(),
      x5c: external_exports.array(external_exports.string()).optional(),
      x5t: external_exports.string().optional(),
      "x5t#S256": external_exports.string().optional()
    }).and(
      external_exports.discriminatedUnion("kty", [
        // RSA Key
        external_exports.object({
          kty: external_exports.literal("RSA"),
          n: external_exports.string(),
          // modulus
          e: external_exports.string()
          // exponent
          // d: z.string().optional(), // private exponent
          // p: z.string().optional(), // first prime factor
          // q: z.string().optional(), // second prime factor
          // dp: z.string().optional(), // first factor CRT exponent
          // dq: z.string().optional(), // second factor CRT exponent
          // qi: z.string().optional(), // first CRT coefficient
        }),
        // Elliptic Curve Key
        external_exports.object({
          kty: external_exports.literal("EC"),
          crv: external_exports.enum(["P-256", "P-384", "P-521", "secp256k1"]),
          x: external_exports.string(),
          // x coordinate
          y: external_exports.string()
          // y coordinate
          // d: z.string().optional(), // private key
        }),
        // Octet sequence (symmetric key)
        external_exports.object({
          kty: external_exports.literal("oct"),
          k: external_exports.string()
          // key value
        }),
        // Octet string key pairs (Ed25519, Ed448, X25519, X448)
        external_exports.object({
          kty: external_exports.literal("OKP"),
          crv: external_exports.enum(["Ed25519", "Ed448", "X25519", "X448"]),
          x: external_exports.string()
          // public key
          // d: z.string().optional(), // private key
        })
      ])
    );
    KeyesJWKPublicSchema = external_exports.object({
      keys: external_exports.array(JWKPublicSchema)
    });
  }
});

// core/types/base/fp-device-id-payload.zod.ts
var SubjectSchema, ExtensionsSchema, FPDeviceIDCSRPayloadSchema, FPDeviceIDSessionSchema;
var init_fp_device_id_payload_zod = __esm({
  "core/types/base/fp-device-id-payload.zod.ts"() {
    "use strict";
    init_v4();
    init_jwk_public_zod();
    init_jwt_payload_zod();
    SubjectSchema = external_exports.object({
      commonName: external_exports.string(),
      //.optional(),
      countryName: external_exports.string().length(2).optional(),
      // ISO 3166-1 alpha-2
      stateOrProvinceName: external_exports.string().optional(),
      locality: external_exports.string().optional(),
      organization: external_exports.string().optional(),
      organizationalUnitName: external_exports.string().optional(),
      emailAddress: external_exports.string().email().optional(),
      serialNumber: external_exports.string().optional(),
      streetAddress: external_exports.string().optional(),
      postalCode: external_exports.string().optional(),
      businessCategory: external_exports.string().optional(),
      jurisdictionCountryName: external_exports.string().length(2).optional(),
      jurisdictionStateOrProvinceName: external_exports.string().optional(),
      jurisdictionLocalityName: external_exports.string().optional()
    });
    ExtensionsSchema = external_exports.object({
      subjectAltName: external_exports.array(external_exports.string()).optional(),
      keyUsage: external_exports.array(
        external_exports.enum([
          "digitalSignature",
          "nonRepudiation",
          "keyEncipherment",
          "dataEncipherment",
          "keyAgreement",
          "keyCertSign",
          "cRLSign",
          "encipherOnly",
          "decipherOnly"
        ])
      ).optional(),
      extendedKeyUsage: external_exports.array(
        external_exports.enum([
          "serverAuth",
          "clientAuth",
          "codeSigning",
          "emailProtection",
          "timeStamping",
          "OCSPSigning",
          "ipsecIKE",
          "msCodeInd",
          "msCodeCom",
          "msCTLSign",
          "msEFS"
        ])
      ).optional(),
      basicConstraints: external_exports.object({
        cA: external_exports.boolean().optional(),
        pathLenConstraint: external_exports.number().int().min(0).optional()
      }).optional(),
      authorityKeyIdentifier: external_exports.string().optional(),
      subjectKeyIdentifier: external_exports.string().optional(),
      certificatePolicies: external_exports.array(
        external_exports.object({
          policyIdentifier: external_exports.string(),
          policyQualifiers: external_exports.array(external_exports.string()).optional()
        })
      ).optional(),
      crlDistributionPoints: external_exports.array(external_exports.string().url()).optional(),
      authorityInfoAccess: external_exports.object({
        ocsp: external_exports.array(external_exports.string().url()).optional(),
        caIssuers: external_exports.array(external_exports.string().url()).optional()
      }).optional(),
      nameConstraints: external_exports.object({
        permitted: external_exports.array(external_exports.string()).optional(),
        excluded: external_exports.array(external_exports.string()).optional()
      }).optional()
    });
    FPDeviceIDCSRPayloadSchema = JWTPayloadSchema.extend({
      csr: external_exports.object({
        subject: SubjectSchema,
        publicKey: JWKPublicSchema,
        extensions: ExtensionsSchema.optional()
      }).strict().readonly()
    }).strict().readonly();
    FPDeviceIDSessionSchema = JWTPayloadSchema.extend({
      deviceId: external_exports.string(),
      // key fingerprint or identifier
      seq: external_exports.number().int().min(0)
      // session sequence number
    }).strict().readonly();
  }
});

// core/types/base/fp-ca-cert-payload.zod.ts
var CertificateSchema, CertificatePayloadSchema;
var init_fp_ca_cert_payload_zod = __esm({
  "core/types/base/fp-ca-cert-payload.zod.ts"() {
    "use strict";
    init_v4();
    init_fp_device_id_payload_zod();
    init_jwk_public_zod();
    CertificateSchema = external_exports.object({
      version: external_exports.literal("3"),
      // X.509 v3
      serialNumber: external_exports.string(),
      subject: SubjectSchema,
      issuer: SubjectSchema,
      validity: external_exports.object({
        notBefore: external_exports.string().datetime(),
        notAfter: external_exports.string().datetime()
      }),
      subjectPublicKeyInfo: JWKPublicSchema,
      signatureAlgorithm: external_exports.literal("ES256"),
      keyUsage: external_exports.array(
        external_exports.enum([
          "digitalSignature",
          "nonRepudiation",
          "keyEncipherment",
          "dataEncipherment",
          "keyAgreement",
          "keyCertSign",
          "cRLSign",
          "encipherOnly",
          "decipherOnly"
        ])
      ),
      extendedKeyUsage: external_exports.array(
        external_exports.enum([
          "serverAuth",
          "clientAuth",
          "codeSigning",
          "emailProtection",
          "timeStamping",
          "OCSPSigning",
          "ipsecIKE",
          "msCodeInd",
          "msCodeCom",
          "msCTLSign",
          "msEFS"
        ])
      ),
      extensions: ExtensionsSchema.optional()
    });
    CertificatePayloadSchema = external_exports.object({
      // Standard JWT claims
      iss: external_exports.string(),
      // Issuer (CA)
      sub: external_exports.string(),
      // Subject
      aud: external_exports.string().or(external_exports.array(external_exports.string())),
      iat: external_exports.number().int(),
      nbf: external_exports.number().int(),
      // Not before
      exp: external_exports.number().int(),
      // Expiration
      jti: external_exports.string(),
      // JWT ID as serial number
      // Certificate-specific claims
      certificate: CertificateSchema
    }).readonly();
  }
});

// core/types/base/jwk-private.zod.ts
var JWKPrivateSchema, KeyesJWKPrivateSchema;
var init_jwk_private_zod = __esm({
  "core/types/base/jwk-private.zod.ts"() {
    "use strict";
    init_v4();
    JWKPrivateSchema = external_exports.object({
      kty: external_exports.enum(["RSA", "EC", "oct", "OKP"]),
      use: external_exports.enum(["sig", "enc"]).optional(),
      key_ops: external_exports.array(external_exports.enum(["sign", "verify", "encrypt", "decrypt", "wrapKey", "unwrapKey", "deriveKey", "deriveBits"])).optional(),
      alg: external_exports.string().optional(),
      kid: external_exports.string().optional(),
      x5u: external_exports.string().url().optional(),
      x5c: external_exports.array(external_exports.string()).optional(),
      x5t: external_exports.string().optional(),
      "x5t#S256": external_exports.string().optional()
    }).and(
      external_exports.discriminatedUnion("kty", [
        // RSA Key
        external_exports.object({
          kty: external_exports.literal("RSA"),
          n: external_exports.string(),
          // modulus
          e: external_exports.string(),
          // exponent
          d: external_exports.string(),
          // private exponent
          p: external_exports.string(),
          // first prime factor
          q: external_exports.string(),
          // second prime factor
          dp: external_exports.string(),
          // first factor CRT exponent
          dq: external_exports.string(),
          // second factor CRT exponent
          qi: external_exports.string()
          // first CRT coefficient
        }),
        // Elliptic Curve Key
        external_exports.object({
          kty: external_exports.literal("EC"),
          crv: external_exports.enum(["P-256", "P-384", "P-521", "secp256k1"]),
          x: external_exports.string(),
          // x coordinate
          y: external_exports.string(),
          // y coordinate
          d: external_exports.string()
          // private key
        }),
        // Octet sequence (symmetric key)
        external_exports.object({
          kty: external_exports.literal("oct"),
          k: external_exports.string()
          // key value
        }),
        // Octet string key pairs (Ed25519, Ed448, X25519, X448)
        external_exports.object({
          kty: external_exports.literal("OKP"),
          crv: external_exports.enum(["Ed25519", "Ed448", "X25519", "X448"]),
          x: external_exports.string(),
          // public key
          d: external_exports.string()
          // private key
        })
      ])
    );
    KeyesJWKPrivateSchema = external_exports.object({
      keys: external_exports.array(JWKPrivateSchema)
    });
  }
});

// core/types/base/device-id.ts
var init_device_id = __esm({
  "core/types/base/device-id.ts"() {
    "use strict";
  }
});

// core/types/base/device-id-keybag-item.zod.ts
var CertJWTPayloadSchema, DeviceIdKeyBagItemSchema;
var init_device_id_keybag_item_zod = __esm({
  "core/types/base/device-id-keybag-item.zod.ts"() {
    "use strict";
    init_v4();
    init_jwk_private_zod();
    init_fp_ca_cert_payload_zod();
    CertJWTPayloadSchema = external_exports.object({
      certificateJWT: external_exports.string(),
      certificatePayload: CertificatePayloadSchema
    }).readonly();
    DeviceIdKeyBagItemSchema = external_exports.object({
      deviceId: JWKPrivateSchema,
      cert: CertJWTPayloadSchema.optional()
    }).readonly();
  }
});

// core/types/base/keybag-storage.zod.ts
var V1StorageKeyItemSchema, V2KeysItemSchema, V2StorageKeyItemSchema, KeyedV2StorageKeyItemSchema, KeyedDeviceIdKeyBagItemSchema, KeyedJwtKeyBagItemSchema, KeyedItemSchema, LegacyKeyedItemSchema;
var init_keybag_storage_zod = __esm({
  "core/types/base/keybag-storage.zod.ts"() {
    "use strict";
    init_v4();
    init_device_id_keybag_item_zod();
    V1StorageKeyItemSchema = external_exports.object({
      name: external_exports.string(),
      key: external_exports.string()
    }).readonly();
    V2KeysItemSchema = external_exports.object({
      key: external_exports.string(),
      // material
      fingerPrint: external_exports.string(),
      default: external_exports.boolean().optional()
    }).readonly();
    V2StorageKeyItemSchema = external_exports.object({
      name: external_exports.string(),
      keys: external_exports.record(external_exports.string(), V2KeysItemSchema)
    }).readonly();
    KeyedV2StorageKeyItemSchema = external_exports.object({
      id: external_exports.string(),
      clazz: external_exports.literal("V2StorageKeyItem"),
      item: V2StorageKeyItemSchema
    }).readonly();
    KeyedDeviceIdKeyBagItemSchema = external_exports.object({
      id: external_exports.string(),
      clazz: external_exports.literal("DeviceIdKeyBagItem"),
      item: DeviceIdKeyBagItemSchema
    }).readonly();
    KeyedJwtKeyBagItemSchema = external_exports.object({
      id: external_exports.string(),
      clazz: external_exports.literal("JwtKeyBagItem"),
      item: external_exports.object({
        jwtStr: external_exports.string()
      })
    }).readonly();
    KeyedItemSchema = KeyedV2StorageKeyItemSchema.or(KeyedDeviceIdKeyBagItemSchema).or(KeyedJwtKeyBagItemSchema);
    LegacyKeyedItemSchema = KeyedItemSchema.or(V1StorageKeyItemSchema).or(V2StorageKeyItemSchema).readonly();
  }
});

// core/types/base/database-config.zod.ts
var StoreUrlsSchema, StoreUrlsOptsSchema, DatabaseConfigSchemaBase, DatabaseConfigSchema, DatabaseConfigWithNameSchema;
var init_database_config_zod = __esm({
  "core/types/base/database-config.zod.ts"() {
    "use strict";
    init_v4();
    StoreUrlsSchema = external_exports.object({
      // string means local storage
      // URL means schema selects the storeType
      meta: external_exports.string(),
      car: external_exports.string(),
      file: external_exports.string(),
      wal: external_exports.string()
    });
    StoreUrlsOptsSchema = external_exports.object({
      base: external_exports.string().optional(),
      data: StoreUrlsSchema.partial(),
      idx: StoreUrlsSchema.partial()
    }).readonly();
    DatabaseConfigSchemaBase = external_exports.object({
      env: external_exports.record(external_exports.string(), external_exports.string()),
      ctx: external_exports.record(external_exports.string(), external_exports.string()),
      // public: z.boolean(),
      writeQueue: external_exports.object({
        chunkSize: external_exports.number()
      }),
      autoCompact: external_exports.number(),
      compactStrategy: external_exports.string(),
      // default "FULL" other "fireproof" , "no-op"
      storeUrls: StoreUrlsOptsSchema.optional(),
      threshold: external_exports.number()
    });
    DatabaseConfigSchema = DatabaseConfigSchemaBase.readonly();
    DatabaseConfigWithNameSchema = external_exports.object({
      ...DatabaseConfigSchemaBase.partial().shape,
      name: external_exports.string(),
      refId: external_exports.string()
      // typically hash of the config
    });
  }
});

// core/types/base/index.ts
var init_base2 = __esm({
  "core/types/base/index.ts"() {
    "use strict";
    init_indexer();
    init_key_bag_if();
    init_types2();
    init_jwt_payload_zod();
    init_fp_device_id_payload_zod();
    init_fp_ca_cert_payload_zod();
    init_jwk_public_zod();
    init_jwk_private_zod();
    init_device_id();
    init_device_id_keybag_item_zod();
    init_keybag_storage_zod();
    init_database_config_zod();
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/json.js
function encode6(node) {
  return textEncoder.encode(JSON.stringify(node));
}
var textEncoder, textDecoder, code2;
var init_json = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/json.js"() {
    textEncoder = new TextEncoder();
    textDecoder = new TextDecoder();
    code2 = 512;
  }
});

// node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/types.js
function isXXHSeed(value) {
  return typeof value === "number" || typeof value === "bigint" || value instanceof Uint32 || value instanceof Uint64;
}
var mask32, Uint32, mask64, Uint64, txtEncoder;
var init_types3 = __esm({
  "node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/types.js"() {
    mask32 = 0xffffffffn;
    Uint32 = class _Uint32 {
      value;
      static from(value) {
        if (value instanceof _Uint32) {
          return value.clone();
        } else if (value instanceof Uint64) {
          return new _Uint32(value.toNumber());
        } else {
          return new _Uint32(value);
        }
      }
      constructor(value = 0) {
        this.value = BigInt(value) & mask32;
      }
      clone() {
        return new _Uint32(this.value);
      }
      assign(other) {
        if (other instanceof _Uint32) {
          this.value = other.value;
        } else {
          this.value = BigInt(other) & mask32;
        }
        return this;
      }
      add(other) {
        this.value = this.value + other.value & mask32;
        return this;
      }
      subtract(other) {
        this.value = this.value - other.value & mask32;
        return this;
      }
      multiply(other) {
        this.value = this.value * other.value & mask32;
        return this;
      }
      xor(other) {
        this.value = this.value ^ other.value;
        return this;
      }
      rotl(bits) {
        const n = BigInt(bits) & 31n;
        this.value = (this.value << n | this.value >> 32n - n) & mask32;
        return this;
      }
      shiftRight(bits) {
        this.value = this.value >> BigInt(bits);
        return this;
      }
      fromNumber(n) {
        this.value = BigInt(n) & 0xffffffffn;
        return this;
      }
      fromBits(low, high) {
        this.value = BigInt(high & 65535) << 16n | BigInt(low & 65535);
        return this;
      }
      toNumber() {
        return this.value;
      }
      toString(radix) {
        const n = this.value.toString(radix || 10);
        if (radix === 16) {
          return n.padStart(8, "0");
        }
        return n;
      }
    };
    mask64 = 0xffffffffffffffffn;
    Uint64 = class _Uint64 {
      value;
      static from(value) {
        if (value instanceof _Uint64) {
          return value.clone();
        } else if (value instanceof Uint32) {
          return new _Uint64(value.toNumber());
        } else {
          return new _Uint64(value);
        }
      }
      constructor(value = 0) {
        this.value = BigInt(value) & mask64;
      }
      clone() {
        return new _Uint64(this.value);
      }
      assign(other) {
        if (other instanceof _Uint64) {
          this.value = other.value;
        } else {
          this.value = BigInt(other) & mask64;
        }
        return this;
      }
      add(other) {
        this.value = this.value + other.value & mask64;
        return this;
      }
      subtract(other) {
        this.value = this.value - other.value & mask64;
        return this;
      }
      multiply(other) {
        this.value = this.value * other.value & mask64;
        return this;
      }
      xor(other) {
        this.value = this.value ^ other.value;
        return this;
      }
      rotl(bits) {
        const n = BigInt(bits) & 63n;
        this.value = (this.value << n | this.value >> 64n - n) & mask64;
        return this;
      }
      shiftRight(bits) {
        this.value = this.value >> BigInt(bits);
        return this;
      }
      fromNumber(n) {
        this.value = BigInt(n) & mask64;
        return this;
      }
      fromBits(a00, a16, a32, a48) {
        this.value = BigInt(a48 & 65535) << 48n | BigInt(a32 & 65535) << 32n | BigInt(a16 & 65535) << 16n | BigInt(a00 & 65535);
        return this;
      }
      toNumber() {
        return this.value;
      }
      toString(radix) {
        const n = this.value.toString(radix || 10);
        if (radix === 16) {
          return n.padStart(16, "0");
        }
        return n;
      }
    };
    txtEncoder = new TextEncoder();
  }
});

// node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/xxhash32.js
function xxh_update(v, low, high) {
  const other = new Uint32().fromBits(low, high);
  return v.add(other.multiply(PRIME32_2)).rotl(13).multiply(PRIME32_1);
}
var PRIME32_1, PRIME32_2, PRIME32_3, PRIME32_4, PRIME32_5, nullBuffer, XXH32;
var init_xxhash32 = __esm({
  "node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/xxhash32.js"() {
    init_types3();
    PRIME32_1 = new Uint32("2654435761");
    PRIME32_2 = new Uint32("2246822519");
    PRIME32_3 = new Uint32("3266489917");
    PRIME32_4 = new Uint32("668265263");
    PRIME32_5 = new Uint32("374761393");
    nullBuffer = new Uint8Array(16);
    XXH32 = class _XXH32 {
      seed;
      v1 = new Uint32();
      v2 = new Uint32();
      v3 = new Uint32();
      v4 = new Uint32();
      total_len = 0;
      memsize = 0;
      memory = new Uint8Array(16);
      constructor(seed) {
        this.seed = Uint32.from(seed || 0);
        this.#reset();
      }
      #reset() {
        this.v1.assign(this.seed).add(PRIME32_1).add(PRIME32_2);
        this.v2.assign(this.seed).add(PRIME32_2);
        this.v3.assign(this.seed);
        this.v4.assign(this.seed).subtract(PRIME32_1);
        this.total_len = 0;
        this.memsize = 0;
        return this;
      }
      update(input) {
        let processedInput;
        if (typeof input === "string") {
          processedInput = txtEncoder.encode(input);
        } else if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
          processedInput = new Uint8Array(input);
        } else {
          processedInput = input;
        }
        let p = 0;
        const len = processedInput.length;
        const bEnd = p + len;
        if (len === 0)
          return this;
        this.total_len += len;
        if (this.memsize === 0) {
          this.memory.set(nullBuffer);
        }
        if (this.memsize + len < 16) {
          this.memory.set(processedInput.subarray(0, len), this.memsize);
          this.memsize += len;
          return this;
        }
        if (this.memsize > 0) {
          this.memory.set(processedInput.subarray(0, 16 - this.memsize), this.memsize);
          let p32 = 0;
          const mem = this.memory;
          xxh_update(this.v1, mem[p32 + 1] << 8 | mem[p32], mem[p32 + 3] << 8 | mem[p32 + 2]);
          p32 += 4;
          xxh_update(this.v2, mem[p32 + 1] << 8 | mem[p32], mem[p32 + 3] << 8 | mem[p32 + 2]);
          p32 += 4;
          xxh_update(this.v3, mem[p32 + 1] << 8 | mem[p32], mem[p32 + 3] << 8 | mem[p32 + 2]);
          p32 += 4;
          xxh_update(this.v4, mem[p32 + 1] << 8 | mem[p32], mem[p32 + 3] << 8 | mem[p32 + 2]);
          p += 16 - this.memsize;
          this.memsize = 0;
        }
        if (p <= bEnd - 16) {
          const limit = bEnd - 16;
          do {
            xxh_update(this.v1, processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2]);
            p += 4;
            xxh_update(this.v2, processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2]);
            p += 4;
            xxh_update(this.v3, processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2]);
            p += 4;
            xxh_update(this.v4, processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2]);
            p += 4;
          } while (p <= limit);
        }
        if (p < bEnd) {
          this.memory.set(processedInput.subarray(p, bEnd), this.memsize);
          this.memsize = bEnd - p;
        }
        return this;
      }
      digest() {
        const input = this.memory;
        let p = 0;
        const bEnd = this.memsize;
        let h32, h;
        const u = new Uint32();
        if (this.total_len >= 16) {
          h32 = this.v1.clone().rotl(1).add(this.v2.clone().rotl(7).add(this.v3.clone().rotl(12).add(this.v4.clone().rotl(18))));
        } else {
          h32 = this.seed.clone().add(PRIME32_5);
        }
        h32.add(u.fromNumber(this.total_len));
        while (p <= bEnd - 4) {
          u.fromBits(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2]);
          h32.add(u.clone().multiply(PRIME32_3)).rotl(17).multiply(PRIME32_4.clone());
          p += 4;
        }
        while (p < bEnd) {
          u.fromBits(input[p++], 0);
          h32.add(u.clone().multiply(PRIME32_5)).rotl(11).multiply(PRIME32_1);
        }
        h = h32.clone().shiftRight(15);
        h32.xor(h).multiply(PRIME32_2);
        h = h32.clone().shiftRight(13);
        h32.xor(h).multiply(PRIME32_3);
        h = h32.clone().shiftRight(16);
        h32.xor(h);
        this.#reset();
        return h32;
      }
      toString(radix) {
        return this.digest().toString(radix);
      }
      static h32(inputOrSeed, seed = 0) {
        if (!inputOrSeed) {
          return new _XXH32();
        }
        if (isXXHSeed(inputOrSeed)) {
          return new _XXH32(inputOrSeed);
        }
        return new _XXH32(seed).update(inputOrSeed);
      }
      static hash(input, seed = 0) {
        return new _XXH32(seed).update(input).digest();
      }
    };
  }
});

// node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/xxhash64.js
var PRIME64_1, PRIME64_2, PRIME64_3, PRIME64_4, PRIME64_5, nullBuffer2, XXH64;
var init_xxhash64 = __esm({
  "node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/xxhash64.js"() {
    init_types3();
    PRIME64_1 = new Uint64("11400714785074694791");
    PRIME64_2 = new Uint64("14029467366897019727");
    PRIME64_3 = new Uint64("1609587929392839161");
    PRIME64_4 = new Uint64("9650029242287828579");
    PRIME64_5 = new Uint64("2870177450012600261");
    nullBuffer2 = new Uint8Array(32);
    XXH64 = class _XXH64 {
      seed = new Uint64();
      v1 = new Uint64();
      v2 = new Uint64();
      v3 = new Uint64();
      v4 = new Uint64();
      total_len = 0;
      memsize = 0;
      memory = new Uint8Array(32);
      constructor(seed) {
        this.seed = Uint64.from(seed || 0);
        this.#reset();
      }
      #reset() {
        this.v1.assign(this.seed).add(PRIME64_1).add(PRIME64_2);
        this.v2.assign(this.seed).add(PRIME64_2);
        this.v3.assign(this.seed);
        this.v4.assign(this.seed).subtract(PRIME64_1);
        this.total_len = 0;
        this.memsize = 0;
        return this;
      }
      update(input) {
        let processedInput;
        if (typeof input === "string") {
          processedInput = txtEncoder.encode(input);
        } else if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
          processedInput = new Uint8Array(input);
        } else {
          processedInput = input;
        }
        let p = 0;
        const len = processedInput.length;
        const bEnd = p + len;
        if (len === 0)
          return this;
        this.total_len += len;
        if (this.memsize === 0) {
          this.memory.set(nullBuffer2);
        }
        if (this.memsize + len < 32) {
          this.memory.set(processedInput.subarray(0, len), this.memsize);
          this.memsize += len;
          return this;
        }
        if (this.memsize > 0) {
          this.memory.set(processedInput.subarray(0, 32 - this.memsize), this.memsize);
          let p64 = 0;
          let other;
          const mem = this.memory;
          other = new Uint64().fromBits(mem[p64 + 1] << 8 | mem[p64], mem[p64 + 3] << 8 | mem[p64 + 2], mem[p64 + 5] << 8 | mem[p64 + 4], mem[p64 + 7] << 8 | mem[p64 + 6]);
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = new Uint64().fromBits(mem[p64 + 1] << 8 | mem[p64], mem[p64 + 3] << 8 | mem[p64 + 2], mem[p64 + 5] << 8 | mem[p64 + 4], mem[p64 + 7] << 8 | mem[p64 + 6]);
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = new Uint64().fromBits(mem[p64 + 1] << 8 | mem[p64], mem[p64 + 3] << 8 | mem[p64 + 2], mem[p64 + 5] << 8 | mem[p64 + 4], mem[p64 + 7] << 8 | mem[p64 + 6]);
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = new Uint64().fromBits(mem[p64 + 1] << 8 | mem[p64], mem[p64 + 3] << 8 | mem[p64 + 2], mem[p64 + 5] << 8 | mem[p64 + 4], mem[p64 + 7] << 8 | mem[p64 + 6]);
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p += 32 - this.memsize;
          this.memsize = 0;
        }
        if (p <= bEnd - 32) {
          const limit = bEnd - 32;
          do {
            let other;
            other = new Uint64().fromBits(processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2], processedInput[p + 5] << 8 | processedInput[p + 4], processedInput[p + 7] << 8 | processedInput[p + 6]);
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = new Uint64().fromBits(processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2], processedInput[p + 5] << 8 | processedInput[p + 4], processedInput[p + 7] << 8 | processedInput[p + 6]);
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = new Uint64().fromBits(processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2], processedInput[p + 5] << 8 | processedInput[p + 4], processedInput[p + 7] << 8 | processedInput[p + 6]);
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = new Uint64().fromBits(processedInput[p + 1] << 8 | processedInput[p], processedInput[p + 3] << 8 | processedInput[p + 2], processedInput[p + 5] << 8 | processedInput[p + 4], processedInput[p + 7] << 8 | processedInput[p + 6]);
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
          } while (p <= limit);
        }
        if (p < bEnd) {
          this.memory.set(processedInput.subarray(p, bEnd), this.memsize);
          this.memsize = bEnd - p;
        }
        return this;
      }
      digest() {
        const input = this.memory;
        let p = 0;
        const bEnd = this.memsize;
        let h64, h;
        const u = new Uint64();
        if (this.total_len >= 32) {
          h64 = this.v1.clone().rotl(1);
          h64.add(this.v2.clone().rotl(7));
          h64.add(this.v3.clone().rotl(12));
          h64.add(this.v4.clone().rotl(18));
          h64.xor(this.v1.clone().multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
          h64.multiply(PRIME64_1).add(PRIME64_4);
          h64.xor(this.v2.clone().multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
          h64.multiply(PRIME64_1).add(PRIME64_4);
          h64.xor(this.v3.clone().multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
          h64.multiply(PRIME64_1).add(PRIME64_4);
          h64.xor(this.v4.clone().multiply(PRIME64_2.clone()).rotl(31).multiply(PRIME64_1.clone()));
          h64.multiply(PRIME64_1).add(PRIME64_4);
        } else {
          h64 = this.seed.clone().add(PRIME64_5);
        }
        h64.add(u.fromNumber(this.total_len));
        while (p <= bEnd - 8) {
          u.fromBits(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], input[p + 5] << 8 | input[p + 4], input[p + 7] << 8 | input[p + 6]);
          u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
          h64.xor(u.clone()).rotl(27).multiply(PRIME64_1).add(PRIME64_4);
          p += 8;
        }
        if (p + 4 <= bEnd) {
          u.fromBits(input[p + 1] << 8 | input[p], input[p + 3] << 8 | input[p + 2], 0, 0);
          h64.xor(u.clone().multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);
          p += 4;
        }
        while (p < bEnd) {
          u.fromBits(input[p++], 0, 0, 0);
          h64.xor(u.clone().multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);
        }
        h = h64.clone().shiftRight(33);
        h64.xor(h).multiply(PRIME64_2);
        h = h64.clone().shiftRight(29);
        h64.xor(h).multiply(PRIME64_3);
        h = h64.clone().shiftRight(32);
        h64.xor(h);
        this.#reset();
        return h64;
      }
      toString(radix) {
        return this.digest().toNumber().toString(radix || 10);
      }
      static h64(inputOrSeed, seed = 0) {
        if (!inputOrSeed) {
          return new _XXH64();
        }
        if (isXXHSeed(inputOrSeed)) {
          return new _XXH64(inputOrSeed);
        }
        return new _XXH64(seed).update(inputOrSeed);
      }
      static hash(input, seed = 0) {
        return new _XXH64(seed).update(input).digest();
      }
    };
  }
});

// node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/index.js
var XXH;
var init_esm2 = __esm({
  "node_modules/.pnpm/@adviser+ts-xxhash@1.0.2/node_modules/@adviser/ts-xxhash/esm/index.js"() {
    init_xxhash32();
    init_xxhash64();
    init_xxhash32();
    init_xxhash64();
    XXH = { h32: XXH32.h32, h64: XXH64.h64 };
  }
});

// core/runtime/utils.ts
function globalLogger() {
  return _globalLogger.once(() => new LoggerImpl());
}
function presetEnv(ipreset) {
  let preset = {};
  if (ipreset instanceof Map) {
    preset = Object.fromEntries(ipreset.entries());
  } else if (typeof ipreset === "object" && ipreset !== null) {
    preset = ipreset;
  }
  const penv = new Map([
    // ["FP_DEBUG", "xxx"],
    // ["FP_ENV", "development"],
    ...Array.from(
      Object.entries({
        ...setPresetEnv({}),
        ...preset
      })
    )
    // .map(([k, v]) => [k, v as string])
  ]);
  return penv;
}
function ensureSuperThis(osthis) {
  const env = envFactory({
    symbol: osthis?.env?.symbol || "FP_ENV",
    presetEnv: presetEnv(osthis?.env?.presetEnv)
  });
  const ret = new SuperThisImpl({
    logger: osthis?.logger || globalLogger(),
    env,
    crypto: osthis?.crypto || toCryptoRuntime(),
    ctx: AppContext.merge(osthis?.ctx),
    pathOps: pathOps2,
    txt: osthis?.txt || txtOps
  });
  _onSuperThis.forEach((fn) => fn(ret));
  return ret;
}
function ensureLogger(sthis, componentName, ctx) {
  let logger;
  if (sthis && IsLogger(sthis.logger)) {
    logger = sthis.logger;
  } else {
    logger = globalLogger();
  }
  const cLogger = logger.With().Module(componentName);
  const debug = [];
  let exposeStack = false;
  if (ctx) {
    if ("debug" in ctx) {
      if (typeof ctx.debug === "string" && ctx.debug.length > 0) {
        debug.push(ctx.debug);
      } else {
        debug.push(componentName);
      }
      delete ctx.debug;
    }
    if ("exposeStack" in ctx) {
      exposeStack = true;
      delete ctx.exposeStack;
    }
    if ("exposeStack" in ctx) {
      exposeStack = true;
      delete ctx.exposeStack;
    }
    if ("this" in ctx) {
      cLogger.Str("this", sthis.nextId(4).str);
      delete ctx.this;
    }
    for (const [key, value] of Object.entries(ctx)) {
      switch (typeof value) {
        case "string":
          cLogger.Str(key, value);
          break;
        case "number":
          cLogger.Uint64(key, value);
          break;
        default:
          if (value instanceof Date) {
            cLogger.Str(key, value.toISOString());
          } else if (isURL(value)) {
            cLogger.Str(key, value.toString());
          } else if (typeof value === "function") {
            cLogger.Ref(key, value);
          } else {
            cLogger.Any(key, value);
          }
          break;
      }
    }
  }
  registerFP_DEBUG.once(async () => {
    sthis.env.onSet(
      (key, value) => {
        switch (key) {
          case "FP_FORMAT": {
            switch (value) {
              case "jsonice":
                logger.SetFormatter(new JSONFormatter(logger.TxtEnDe(), 2));
                break;
              case "yaml":
                logger.SetFormatter(new YAMLFormatter(logger.TxtEnDe(), 2));
                break;
              case "json":
              default:
                logger.SetFormatter(new JSONFormatter(logger.TxtEnDe()));
                break;
            }
            break;
          }
          case "FP_DEBUG":
            logger.SetDebug(value || []);
            break;
          case "FP_STACK":
            logger.SetExposeStack(!!value);
            break;
        }
      },
      "FP_FORMAT",
      "FP_DEBUG",
      "FP_STACK"
    );
  }).finally(() => {
  });
  if (debug.length > 0) {
    logger.SetDebug(debug);
  }
  if (exposeStack) {
    logger.SetExposeStack(true);
  }
  const out = cLogger.Logger();
  if (sthis.env.get("FP_CONSTRUCTOR_DEBUG")) {
    out.Debug().Msg("constructor");
  }
  return out;
}
function getStore(url2, sthis, joiner) {
  const fromUrl = url2.getParam(PARAM.STORE);
  let pathPart;
  switch (fromUrl) {
    case "car":
    case "file":
      pathPart = "data";
      break;
    case "wal":
    case "meta":
      pathPart = fromUrl;
      break;
    default:
      throw sthis.logger.Error().Url(url2).Msg(`store not found`).AsError();
  }
  let name2 = pathPart;
  if (url2.hasParam("index")) {
    name2 = joiner(url2.getParam(PARAM.INDEX) || "idx", name2);
  }
  return { pathPart, fromUrl, name: name2 };
}
function getKey(url2, logger) {
  const result = url2.getParam(PARAM.KEY);
  if (!result) throw logger.Error().Str("url", url2.toString()).Msg(`key not found`).AsError();
  return result;
}
async function exceptionWrapper(fn) {
  return fn().catch((e) => Result.Err(e));
}
function UInt8ArrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function inplaceFilter(i, pred) {
  const founds = [];
  for (let j = 0; j < i.length; j++) {
    if (!pred(i[j], j)) {
      founds.push(j);
    }
  }
  for (let j = founds.length - 1; j >= 0; j--) {
    i.splice(founds[j], 1);
  }
  return i;
}
function coerceIntoUint82(raw) {
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    return raw;
  }
  return Result.Err("Not a Uint8Array");
}
async function coercePromiseIntoUint8(raw) {
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    return raw;
  }
  if (typeof raw.then === "function") {
    try {
      return coercePromiseIntoUint8(await raw);
    } catch (e) {
      return Result.Err(e);
    }
  }
  return Result.Err("Not a Uint8Array");
}
function makeName(fnString) {
  const regex = /\(([^,()]+,\s*[^,()]+|\[[^\]]+\],\s*[^,()]+)\)/g;
  let found = null;
  const matches = Array.from(fnString.matchAll(regex), (match2) => match2[1].trim());
  if (matches.length === 0) {
    found = /=>\s*{?\s*([^{}]+)\s*}?/.exec(fnString);
    if (found && found[1].includes("return")) {
      found = null;
    }
  }
  if (!found) {
    return fnString;
  } else {
    return found[1];
  }
}
function storeType2DataMetaWal(store) {
  switch (store) {
    case "car":
    case "file":
      return "data";
    case "meta":
    case "wal":
      return store;
    default:
      throw new Error(`unknown store ${store}`);
  }
}
function ensureURIDefaults(sthis, names, curi, uri, store, ctx) {
  ctx = ctx || {};
  const ret = (curi ? URI.from(curi) : uri).build().setParam(PARAM.STORE, store).defParam(PARAM.NAME, names.name);
  if (names.localURI) {
    const rParams = names.localURI.getParamsResult({
      [PARAM.NAME]: param.OPTIONAL,
      [PARAM.STORE_KEY]: param.OPTIONAL
    });
    const params = rParams.Ok();
    if (params[PARAM.NAME]) {
      ret.defParam(PARAM.LOCAL_NAME, params[PARAM.NAME]);
    }
    if (params[PARAM.STORE_KEY]) {
      ret.defParam(PARAM.STORE_KEY, params[PARAM.STORE_KEY]);
    }
  }
  if (ctx.idx) {
    ret.defParam(PARAM.INDEX, "idx");
    ret.defParam(PARAM.STORE_KEY, `@${ret.getParam(PARAM.NAME)}-${storeType2DataMetaWal(store)}-idx@`);
  } else {
    ret.defParam(PARAM.STORE_KEY, `@${ret.getParam(PARAM.NAME)}-${storeType2DataMetaWal(store)}@`);
  }
  if (store === "car") {
    ret.defParam(PARAM.SUFFIX, ".car");
  }
  return ret.URI();
}
function setPresetEnv(o, symbol2 = "FP_PRESET_ENV") {
  const key = Symbol.for(symbol2);
  const env = globalThis[key] ?? {};
  for (const [k, v] of Object.entries(o)) {
    env[k] = v;
  }
  globalThis[key] = env;
  return env;
}
async function hashStringAsync(str) {
  const bytes = encode6(str);
  const hash2 = await sha256.digest(bytes);
  return CID.create(1, code2, hash2).toString();
}
function hashStringSync(str) {
  return new Hasher2().update(str).digest();
}
function hashObjectSync(o) {
  const hasher = new Hasher2();
  toSorted(o, (x, key) => {
    switch (key) {
      case "Null":
      case "Array":
      case "Function":
        break;
      case "Date":
        hasher.update(`D:${x.toISOString()}`);
        break;
      case "Symbol":
        hasher.update(`S:(x as symbol).toString()}`);
        break;
      case "Key":
        hasher.update(`K:${x}`);
        break;
      case "String":
        hasher.update(`S:${x}`);
        break;
      case "Boolean":
        hasher.update(`B:${x ? "true" : "false"}`);
        break;
      case "Number":
        hasher.update(`N:${x.toString()}`);
        break;
      case "Uint8Array":
        hasher.update(new Uint8Array(["U".charCodeAt(0), ":".charCodeAt(0), ...x]));
        break;
    }
  });
  return hasher.digest();
}
function sleep2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function deepClone(value) {
  return (structuredClone ?? ((v) => JSON.parse(JSON.stringify(v))))(value);
}
function coerceLogger(loggerOrHasLogger) {
  if (IsLogger(loggerOrHasLogger)) {
    return loggerOrHasLogger;
  } else {
    return loggerOrHasLogger.logger;
  }
}
function timerStart(loggerOrHasLogger, tag2) {
  coerceLogger(loggerOrHasLogger).Debug().TimerStart(tag2).Msg("Timing started");
}
function timerEnd(loggerOrHasLogger, tag2) {
  coerceLogger(loggerOrHasLogger).Debug().TimerEnd(tag2).Msg("Timing ended");
}
var _globalLogger, registerFP_DEBUG, SuperThisImpl, pathOpsImpl2, pathOps2, txtOps, _onSuperThis, Hasher2;
var init_utils = __esm({
  "core/runtime/utils.ts"() {
    "use strict";
    init_esm();
    init_base2();
    init_base58();
    init_sha2_browser();
    init_cid();
    init_json();
    init_esm2();
    init_v4();
    _globalLogger = new ResolveOnce();
    registerFP_DEBUG = new ResolveOnce();
    SuperThisImpl = class _SuperThisImpl {
      logger;
      env;
      pathOps;
      ctx;
      txt;
      crypto;
      constructor(opts) {
        this.logger = opts.logger;
        this.env = opts.env;
        this.crypto = opts.crypto;
        this.pathOps = opts.pathOps;
        this.txt = opts.txt;
        this.ctx = opts.ctx;
      }
      nextId(bytes = 6) {
        const bin = this.crypto.randomBytes(bytes);
        return {
          str: base58btc.encode(bin),
          bin
        };
      }
      timeOrderedNextId(now) {
        now = typeof now === "number" ? now : (/* @__PURE__ */ new Date()).getTime();
        const t = (281474976710656 + now).toString(16).replace(/^1/, "");
        const bin = this.crypto.randomBytes(10);
        bin[1] = bin[1] & 240 | (bin[1] | 8 && 11);
        const hex3 = Array.from(bin).map((i) => i.toString(16).padStart(2, "0")).join("");
        return {
          str: `${t.slice(0, 8)}-${t.slice(8)}-7${hex3.slice(0, 3)}-${hex3.slice(3, 7)}-${hex3.slice(7, 19)}`
        };
      }
      start() {
        return Promise.resolve();
      }
      clone(override) {
        return new _SuperThisImpl({
          logger: override.logger || this.logger,
          env: envFactory(override.env) || this.env,
          crypto: override.crypto || this.crypto,
          pathOps: override.pathOps || this.pathOps,
          txt: override.txt || this.txt,
          ctx: AppContext.merge(this.ctx, override.ctx)
        });
      }
    };
    pathOpsImpl2 = class {
      join(...paths) {
        return paths.map((i) => i.replace(/\/+$/, "")).join("/");
      }
      dirname(path) {
        return path.split("/").slice(0, -1).join("/");
      }
      basename(path) {
        return path.split("/").pop() || "";
      }
      // homedir() {
      //     throw new Error("SysContainer:homedir is not available in seeded state");
      //   }
    };
    pathOps2 = new pathOpsImpl2();
    txtOps = /* @__PURE__ */ ((txtEncoder2, txtDecoder) => ({
      id: () => "fp-txtOps",
      encode: (input) => txtEncoder2.encode(input),
      decode: (input) => txtDecoder.decode(coerceIntoUint82(input).Ok()),
      base64: {
        encode: (input) => {
          if (typeof input === "string") {
            const data = txtEncoder2.encode(input);
            return btoa(String.fromCharCode(...data));
          }
          let charStr = "";
          for (const i of coerceIntoUint82(input).Ok()) {
            charStr += String.fromCharCode(i);
          }
          return btoa(charStr);
        },
        decodeUint8: (input) => {
          const data = atob(input.replace(/\s+/g, ""));
          return new Uint8Array(data.split("").map((c) => c.charCodeAt(0)));
        },
        decode: (input) => {
          const data = atob(input.replace(/\s+/g, ""));
          const uint8 = new Uint8Array(data.split("").map((c) => c.charCodeAt(0)));
          return txtDecoder.decode(uint8);
        }
      },
      base58: {
        encode: (input) => {
          if (typeof input === "string") {
            const data = txtEncoder2.encode(input);
            return base58btc.encode(data);
          }
          return base58btc.encode(coerceIntoUint82(input).Ok());
        },
        decodeUint8: (input) => {
          return base58btc.decode(input.replace(/\s+/g, ""));
        },
        decode: (input) => {
          const data = base58btc.decode(input.replace(/\s+/g, ""));
          return txtDecoder.decode(data);
        }
      }
      // eslint-disable-next-line no-restricted-globals
    }))(new TextEncoder(), new TextDecoder());
    _onSuperThis = /* @__PURE__ */ new Map();
    Hasher2 = class {
      hasher;
      ende;
      constructor(ende) {
        this.hasher = XXH.h64();
        this.ende = ende || txtOps;
      }
      update(x) {
        switch (true) {
          case x instanceof Uint8Array:
            this.hasher.update(x);
            break;
          case typeof x === "string":
            this.hasher.update(this.ende.encode(x));
            break;
          case typeof x === "number":
            this.hasher.update(this.ende.encode(x.toString()));
            break;
          case typeof x === "boolean":
            this.hasher.update(this.ende.encode(x ? "true" : "false"));
            break;
          default:
            throw new Error(`unsupported type ${typeof x}`);
        }
        return this;
      }
      digest(x) {
        if (!(x === void 0 || x === null)) {
          this.update(x);
        }
        const hex3 = this.hasher.digest().toString(16);
        const asBytes = new Uint8Array(hex3.length / 2 + 1);
        for (let i = 0; i < hex3.length; i += 2) {
          asBytes[i / 2] = parseInt(hex3.slice(i, i + 2), 16);
        }
        return base58btc.encode(asBytes);
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/is.js
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs, objectTypeNames;
var init_is2 = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/is.js"() {
    typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/token.js
var Type, Token;
var init_token = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/token.js"() {
    Type = class {
      /**
       * @param {number} major
       * @param {string} name
       * @param {boolean} terminal
       */
      constructor(major, name2, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name2;
        this.terminal = terminal;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      /**
       * @param {Type} typ
       * @returns {number}
       */
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    Token = class {
      /**
       * @param {Type} type
       * @param {any} [value]
       * @param {number} [encodedLength]
       */
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/byte-utils.js
function isBuffer2(buf3) {
  return useBuffer && globalThis.Buffer.isBuffer(buf3);
}
function asU8A(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer2(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
var useBuffer, textDecoder2, textEncoder2, toString2, fromString2, fromArray, slice, concat, alloc, MAX_ARGUMENTS_LENGTH;
var init_byte_utils = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/byte-utils.js"() {
    useBuffer = globalThis.process && // @ts-ignore
    !globalThis.process.browser && // @ts-ignore
    globalThis.Buffer && // @ts-ignore
    typeof globalThis.Buffer.isBuffer === "function";
    textDecoder2 = new TextDecoder();
    textEncoder2 = new TextEncoder();
    toString2 = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return end - start > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
        ) : utf8Slice(bytes, start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return end - start > 64 ? textDecoder2.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);
      }
    );
    fromString2 = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string5) => {
        return string5.length > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(string5)
        ) : utf8ToBytes(string5);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string5) => {
        return string5.length > 64 ? textEncoder2.encode(string5) : utf8ToBytes(string5);
      }
    );
    fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    slice = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        if (isBuffer2(bytes)) {
          return new Uint8Array(bytes.subarray(start, end));
        }
        return bytes.slice(start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return bytes.slice(start, end);
      }
    );
    concat = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length2) => {
        chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(c)
        ));
        return asU8A(globalThis.Buffer.concat(chunks, length2));
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length2) => {
        const out = new Uint8Array(length2);
        let off = 0;
        for (let b of chunks) {
          if (off + b.length > out.length) {
            b = b.subarray(0, out.length - off);
          }
          out.set(b, off);
          off += b.length;
        }
        return out;
      }
    );
    alloc = useBuffer ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size) => {
        return globalThis.Buffer.allocUnsafe(size);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size) => {
        return new Uint8Array(size);
      }
    );
    MAX_ARGUMENTS_LENGTH = 4096;
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/bl.js
var defaultChunkSize, Bl;
var init_bl = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/bl.js"() {
    init_byte_utils();
    defaultChunkSize = 256;
    Bl = class {
      /**
       * @param {number} [chunkSize]
       */
      constructor(chunkSize = defaultChunkSize) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      /**
       * @param {Uint8Array|number[]} bytes
       */
      push(bytes) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes.length < 64 && bytes.length < this.chunkSize) {
            topChunk = alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes, 0);
          } else {
            this.chunks.push(bytes);
            this.maxCursor += bytes.length;
          }
        }
        this.cursor += bytes.length;
      }
      /**
       * @param {boolean} [reset]
       * @returns {Uint8Array}
       */
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/common.js
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
var decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes;
var init_common = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/common.js"() {
    decodeErrPrefix = "CBOR decode error:";
    encodeErrPrefix = "CBOR encode error:";
    uintMinorPrefixBytes = [];
    uintMinorPrefixBytes[23] = 1;
    uintMinorPrefixBytes[24] = 2;
    uintMinorPrefixBytes[25] = 3;
    uintMinorPrefixBytes[26] = 5;
    uintMinorPrefixBytes[27] = 9;
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/0uint.js
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf3, token) {
  return encodeUintValue(buf3, 0, token.value);
}
function encodeUintValue(buf3, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set3 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set3[8] = lo & 255;
      lo = lo >> 8;
      set3[7] = lo & 255;
      lo = lo >> 8;
      set3[6] = lo & 255;
      lo = lo >> 8;
      set3[5] = lo & 255;
      set3[4] = hi & 255;
      hi = hi >> 8;
      set3[3] = hi & 255;
      hi = hi >> 8;
      set3[2] = hi & 255;
      hi = hi >> 8;
      set3[1] = hi & 255;
      buf3.push(set3);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries;
var init_uint = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/0uint.js"() {
    init_token();
    init_common();
    uintBoundaries = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize2(uint) {
      if (uint < uintBoundaries[0]) {
        return 1;
      }
      if (uint < uintBoundaries[1]) {
        return 2;
      }
      if (uint < uintBoundaries[2]) {
        return 3;
      }
      if (uint < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
function decodeNegint64(data, pos, _minor, options) {
  const int4 = readUint64(data, pos + 1, options);
  if (typeof int4 !== "bigint") {
    const value = -1 - int4;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int4), 9);
}
function encodeNegint(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf3, token.type.majorEncoded, unsigned);
}
var neg1b, pos1b;
var init_negint = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/1negint.js"() {
    init_token();
    init_uint();
    init_common();
    neg1b = BigInt(-1);
    pos1b = BigInt(1);
    encodeNegint.encodedSize = function encodedSize3(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/2bytes.js
function toToken(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf3 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf3, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf3, token) {
  const bytes = tokenBytes(token);
  encodeUintValue(buf3, token.type.majorEncoded, bytes.length);
  buf3.push(bytes);
}
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
var init_bytes2 = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/2bytes.js"() {
    init_token();
    init_common();
    init_uint();
    init_byte_utils();
    encodeBytes.encodedSize = function encodedSize4(token) {
      const bytes = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes.length) + bytes.length;
    };
    encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/3string.js
function toToken2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l, options);
}
var encodeString;
var init_string2 = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/3string.js"() {
    init_token();
    init_common();
    init_uint();
    init_bytes2();
    init_byte_utils();
    encodeString = encodeBytes;
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/4array.js
function toToken3(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf3, token) {
  encodeUintValue(buf3, Type.array.majorEncoded, token.value);
}
var init_array = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/4array.js"() {
    init_token();
    init_uint();
    init_common();
    encodeArray.compareTokens = encodeUint.compareTokens;
    encodeArray.encodedSize = function encodedSize5(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/5map.js
function toToken4(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf3, token) {
  encodeUintValue(buf3, Type.map.majorEncoded, token.value);
}
var init_map2 = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/5map.js"() {
    init_token();
    init_uint();
    init_common();
    encodeMap.compareTokens = encodeUint.compareTokens;
    encodeMap.encodedSize = function encodedSize6(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf3, token) {
  encodeUintValue(buf3, Type.tag.majorEncoded, token.value);
}
var init_tag = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/6tag.js"() {
    init_token();
    init_uint();
    encodeTag.compareTokens = encodeUint.compareTokens;
    encodeTag.encodedSize = function encodedSize7(token) {
      return encodeUintValue.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/7float.js
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf3, token, options) {
  const float3 = token.value;
  if (float3 === false) {
    buf3.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float3 === true) {
    buf3.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float3 === null) {
    buf3.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float3 === void 0) {
    buf3.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success2 = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float3);
      decoded = readFloat16(ui8a, 1);
      if (float3 === decoded || Number.isNaN(float3)) {
        ui8a[0] = 249;
        buf3.push(ui8a.slice(0, 3));
        success2 = true;
      } else {
        encodeFloat32(float3);
        decoded = readFloat32(ui8a, 1);
        if (float3 === decoded) {
          ui8a[0] = 250;
          buf3.push(ui8a.slice(0, 5));
          success2 = true;
        }
      }
    }
    if (!success2) {
      encodeFloat64(float3);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf3.push(ui8a.slice(0, 9));
    }
  }
}
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
var MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView, ui8a;
var init_float3 = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/7float.js"() {
    init_token();
    init_common();
    init_uint();
    MINOR_FALSE = 20;
    MINOR_TRUE = 21;
    MINOR_NULL = 22;
    MINOR_UNDEFINED = 23;
    encodeFloat.encodedSize = function encodedSize8(token, options) {
      const float3 = token.value;
      if (float3 === false || float3 === true || float3 === null || float3 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat16(float3);
        let decoded = readFloat16(ui8a, 1);
        if (float3 === decoded || Number.isNaN(float3)) {
          return 3;
        }
        encodeFloat32(float3);
        decoded = readFloat32(ui8a, 1);
        if (float3 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer = new ArrayBuffer(9);
    dataView = new DataView(buffer, 1);
    ui8a = new Uint8Array(buffer, 0);
    encodeFloat.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
var jump, quick;
var init_jump = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/jump.js"() {
    init_token();
    init_uint();
    init_negint();
    init_bytes2();
    init_string2();
    init_array();
    init_map2();
    init_tag();
    init_float3();
    init_common();
    init_byte_utils();
    jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/encode.js
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries4, options) {
  if (options.mapSorter) {
    entries4.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function rfc8949MapSorter(e1, e2) {
  if (e1[0] instanceof Token && e2[0] instanceof Token) {
    const t1 = (
      /** @type {TokenEx} */
      e1[0]
    );
    const t2 = (
      /** @type {TokenEx} */
      e2[0]
    );
    if (!t1._keyBytes) {
      t1._keyBytes = encodeRfc8949(t1.value);
    }
    if (!t2._keyBytes) {
      t2._keyBytes = encodeRfc8949(t2.value);
    }
    return compare(t1._keyBytes, t2._keyBytes);
  }
  throw new Error("rfc8949MapSorter: complex key types are not supported yet");
}
function encodeRfc8949(data) {
  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions);
}
function tokensToEncoded(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf3 = new Bl(size);
      encoder2(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf3.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode7(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
var defaultEncodeOptions, rfc8949EncodeOptions, cborEncoders, buf, Ref, simpleTokens, typeEncoders;
var init_encode = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/encode.js"() {
    init_is2();
    init_token();
    init_bl();
    init_common();
    init_jump();
    init_byte_utils();
    init_uint();
    init_negint();
    init_bytes2();
    init_string2();
    init_array();
    init_map2();
    init_tag();
    init_float3();
    defaultEncodeOptions = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    rfc8949EncodeOptions = Object.freeze({
      float64: true,
      mapSorter: rfc8949MapSorter,
      quickEncodeToken
    });
    cborEncoders = makeCborEncoders();
    buf = new Bl();
    Ref = class _Ref {
      /**
       * @param {object|any[]} obj
       * @param {Reference|undefined} parent
       */
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      /**
       * @param {object|any[]} obj
       * @returns {boolean}
       */
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      /**
       * @param {Reference|undefined} stack
       * @param {object|any[]} obj
       * @returns {Reference}
       */
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    typeEncoders = {
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      string(obj, _typ, _options, _refStack) {
        return new Token(Type.string, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens.null;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens.undefined;
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      DataView(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [simpleTokens.emptyArray, new Token(Type.break)];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries4 = [];
        let i = 0;
        for (const e of obj) {
          entries4[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [new Token(Type.array, obj.length), entries4, new Token(Type.break)];
        }
        return [new Token(Type.array, obj.length), entries4];
      },
      /**
       * @param {any} obj
       * @param {string} typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Object(obj, typ, options, refStack) {
        const isMap2 = typ !== "Object";
        const keys = isMap2 ? obj.keys() : Object.keys(obj);
        const length2 = isMap2 ? obj.size : keys.length;
        if (!length2) {
          if (options.addBreakTokens === true) {
            return [simpleTokens.emptyMap, new Token(Type.break)];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries4 = [];
        let i = 0;
        for (const key of keys) {
          entries4[i++] = [
            objectToTokens(key, options, refStack),
            objectToTokens(isMap2 ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries(entries4, options);
        if (options.addBreakTokens) {
          return [new Token(Type.map, length2), entries4, new Token(Type.break)];
        }
        return [new Token(Type.map, length2), entries4];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/decode.js
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK3) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK3) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK3;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK3) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode8(data, options) {
  const [decoded, remainder] = decodeFirst(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions, Tokeniser, DONE, BREAK3;
var init_decode = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/lib/decode.js"() {
    init_common();
    init_token();
    init_jump();
    defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
      }
      pos() {
        return this._pos;
      }
      done() {
        return this._pos >= this.data.length;
      }
      next() {
        const byt = this.data[this._pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder2 = jump[byt];
          if (!decoder2) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder2(this.data, this._pos, minor, this.options);
        }
        this._pos += token.encodedLength;
        return token;
      }
    };
    DONE = /* @__PURE__ */ Symbol.for("DONE");
    BREAK3 = /* @__PURE__ */ Symbol.for("BREAK");
  }
});

// node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/cborg.js
var init_cborg = __esm({
  "node_modules/.pnpm/cborg@4.3.2/node_modules/cborg/cborg.js"() {
    init_encode();
    init_decode();
    init_token();
  }
});

// core/runtime/keyed-crypto.ts
function getGenerateIVFn(url2, opts) {
  const ivhash = opts.ivCalc || url2.getParam(PARAM.IV_HASH) || "hash";
  return generateIV[ivhash] || generateIV["hash"];
}
async function keyedCryptoFactory(url2, kb, sthis) {
  const storekey = url2.getParam(PARAM.STORE_KEY);
  if (storekey && storekey !== "insecure") {
    const rkey = await kb.getNamedKey(storekey, false);
    if (rkey.isErr()) {
      throw sthis.logger.Error().Str("keybag", kb.rt.id()).Str("name", storekey).Msg("getNamedKey failed").AsError();
    }
    return new cryptoAction(url2, rkey.Ok(), kb.rt.crypto, sthis);
  }
  return new noCrypto(url2, kb.rt.crypto, sthis);
}
var generateIV, BlockIvKeyIdCodec, cryptoAction, nullCodec, noCrypto;
var init_keyed_crypto = __esm({
  "core/runtime/keyed-crypto.ts"() {
    "use strict";
    init_base2();
    init_utils();
    init_base58();
    init_sha2_browser();
    init_cborg();
    generateIV = {
      random: {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        calc: async (ko, crypto2, data) => {
          return crypto2.randomBytes(ko.ivLength);
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        verify: async (ko, crypto2, iv, data) => {
          return true;
        }
      },
      hash: {
        calc: async (ko, crypto2, data) => {
          const hash2 = await sha256.digest(data);
          const hashBytes = new Uint8Array(hash2.bytes);
          const hashArray = new Uint8Array(ko.ivLength);
          for (let i = 0; i < hashBytes.length; i++) {
            hashArray[i % ko.ivLength] ^= hashBytes[i];
          }
          return hashArray;
        },
        verify: async function(ko, crypto2, iv, data) {
          return ko.url.getParam(PARAM.IV_VERIFY) !== "disable" && UInt8ArrayEqual(iv, await this.calc(ko, crypto2, data));
        }
      }
    };
    BlockIvKeyIdCodec = class {
      code = 24;
      name = "Fireproof@encrypted-block:aes-gcm";
      ko;
      iv;
      opts;
      constructor(ko, iv, opts) {
        this.ko = ko;
        this.iv = iv;
        this.opts = opts || {};
      }
      // hashAsBytes(data: IvKeyIdData): AsyncHashAsBytes<Uint8Array<ArrayBufferLike>> {
      //   return data;
      // }
      valueToHashBytes(value) {
        return Promise.resolve(value.data);
      }
      bytesToHash(data) {
        return Promise.resolve(data);
      }
      async encode(data) {
        const calcIv = this.iv || await getGenerateIVFn(this.ko.url, this.opts).calc(this.ko, this.ko.crypto, data);
        const { iv } = this.ko.algo(calcIv);
        const defKey = await this.ko.key.get();
        if (!defKey) {
          throw this.ko.logger.Error().Msg("default key not found").AsError();
        }
        const keyId = base58btc.decode(defKey?.fingerPrint);
        this.ko.logger.Debug().Str("fp", defKey.fingerPrint).Msg("encode");
        return encode7({
          iv,
          keyId,
          data: await this.ko._encrypt({ iv, key: defKey.key, bytes: data })
        });
      }
      async decode(abytes) {
        let bytes;
        if (abytes instanceof Uint8Array) {
          bytes = abytes;
        } else {
          bytes = new Uint8Array(abytes);
        }
        const { iv, keyId, data } = decode8(bytes);
        const key = await this.ko.key.get(keyId);
        if (!key) {
          throw this.ko.logger.Error().Str("fp", base58btc.encode(keyId)).Msg("keyId not found").AsError();
        }
        const result = await this.ko._decrypt({ iv, key: key.key, bytes: data });
        if (!this.opts?.noIVVerify && !await getGenerateIVFn(this.ko.url, this.opts).verify(this.ko, this.ko.crypto, iv, result)) {
          throw this.ko.logger.Error().Msg("iv missmatch").AsError();
        }
        return {
          iv,
          keyId,
          data: result
        };
      }
    };
    cryptoAction = class {
      code = 24;
      ivLength = 12;
      logger;
      crypto;
      key;
      isEncrypting = true;
      url;
      constructor(url2, key, cyopt, sthis) {
        this.logger = ensureLogger(sthis, "cryptoAction");
        this.crypto = cyopt;
        this.key = key;
        this.url = url2;
      }
      // keyByFingerPrint(id: Uint8Array | string): Promise<Result<KeyWithFingerPrint>> {
      //   return this.key.get(id)
      // }
      // fingerPrint(): Promise<string> {
      //   return this.key.get().then((k) => k.fingerPrint);
      // }
      codec(iv, opts) {
        return new BlockIvKeyIdCodec(this, iv, opts);
      }
      algo(iv) {
        return {
          name: "AES-GCM",
          iv: iv || this.crypto.randomBytes(this.ivLength),
          tagLength: 128
        };
      }
      async _decrypt(data) {
        return new Uint8Array(await this.crypto.decrypt(this.algo(data.iv), data.key, data.bytes));
      }
      async _encrypt(data) {
        const a = this.algo(data.iv);
        return new Uint8Array(await this.crypto.encrypt(a, data.key, data.bytes));
      }
    };
    nullCodec = class {
      code = 24;
      name = "Fireproof@unencrypted-block";
      empty = new Uint8Array();
      async encode(data) {
        return data;
      }
      async decode(data) {
        return {
          iv: this.empty,
          keyId: this.empty,
          data
        };
      }
    };
    noCrypto = class {
      ivLength = 0;
      code = 0;
      name = "Fireproof@unencrypted-block";
      logger;
      crypto;
      key;
      isEncrypting = false;
      _fingerPrint = "noCrypto:" + Math.random();
      url;
      constructor(url2, cyrt, sthis) {
        this.logger = ensureLogger(sthis, "noCrypto");
        this.crypto = cyrt;
        this.key = {
          id: sthis.nextId().str,
          name: "noCrypto",
          get: () => {
            throw this.logger.Error().Msg("noCrypto.get not implemented").AsError();
          },
          upsert: () => {
            throw this.logger.Error().Msg("noCrypto.upsert not implemented").AsError();
          },
          asV2StorageKeyItem: () => {
            throw this.logger.Error().Msg("noCrypto.asV2KeysItem not implemented").AsError();
          }
        };
        this.url = url2;
      }
      fingerPrint() {
        return Promise.resolve(this._fingerPrint);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      codec(iv) {
        return new nullCodec();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      algo(iv) {
        return {
          name: "noCrypto",
          iv: new Uint8Array(),
          tagLength: 0
        };
      }
      _decrypt() {
        throw this.logger.Error().Msg("noCrypto.decrypt not implemented").AsError();
      }
      _encrypt() {
        throw this.logger.Error().Msg("noCrypto.decrypt not implemented").AsError();
      }
    };
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/interface.js
var init_interface2 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/interface.js"() {
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/interface.js
var init_interface3 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/hashes/interface.js"() {
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/interface.js
var init_interface4 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/codecs/interface.js"() {
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/block/interface.js
var init_interface5 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/block/interface.js"() {
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/interface.js
var init_interface6 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/interface.js"() {
    init_interface2();
    init_interface3();
    init_interface4();
    init_interface();
    init_interface5();
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/index.js
var init_src = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/index.js"() {
    init_bytes();
    init_cid();
    init_digest();
    init_hasher();
    init_varint2();
    init_interface6();
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/block.js
function readonly2({ enumerable = true, configurable = false } = {}) {
  return { enumerable, configurable, writable: false };
}
function* linksWithin(path, value) {
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (const [index2, element] of value.entries()) {
        const elementPath = [...path, index2];
        const cid = CID.asCID(element);
        if (cid != null) {
          yield [elementPath.join("/"), cid];
        } else if (typeof element === "object") {
          yield* links(element, elementPath);
        }
      }
    } else {
      const cid = CID.asCID(value);
      if (cid != null) {
        yield [path.join("/"), cid];
      } else {
        yield* links(value, path);
      }
    }
  }
}
function* links(source, base2) {
  if (source == null || source instanceof Uint8Array) {
    return;
  }
  const cid = CID.asCID(source);
  if (cid != null) {
    yield [base2.join("/"), cid];
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [...base2, key];
    yield* linksWithin(path, value);
  }
}
function* treeWithin(path, value) {
  if (Array.isArray(value)) {
    for (const [index2, element] of value.entries()) {
      const elementPath = [...path, index2];
      yield elementPath.join("/");
      if (typeof element === "object" && CID.asCID(element) == null) {
        yield* tree(element, elementPath);
      }
    }
  } else {
    yield* tree(value, path);
  }
}
function* tree(source, base2) {
  if (source == null || typeof source !== "object") {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [...base2, key];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && CID.asCID(value) == null) {
      yield* treeWithin(path, value);
    }
  }
}
function get(source, path) {
  let node = source;
  for (const [index2, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index2 + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID.asCID(node);
    if (cid != null) {
      return { value: cid, remaining: path.slice(index2 + 1).join("/") };
    }
  }
  return { value: node };
}
async function encode8({ value, codec: codec2, hasher }) {
  if (typeof value === "undefined") {
    throw new Error('Missing required argument "value"');
  }
  if (codec2 == null || hasher == null) {
    throw new Error("Missing required argument: codec or hasher");
  }
  const bytes = codec2.encode(value);
  const hash2 = await hasher.digest(bytes);
  const cid = CID.create(1, codec2.code, hash2);
  return new Block({ value, bytes, cid });
}
async function decode9({ bytes, codec: codec2, hasher }) {
  if (bytes == null) {
    throw new Error('Missing required argument "bytes"');
  }
  if (codec2 == null || hasher == null) {
    throw new Error("Missing required argument: codec or hasher");
  }
  const value = codec2.decode(bytes);
  const hash2 = await hasher.digest(bytes);
  const cid = CID.create(1, codec2.code, hash2);
  return new Block({ value, bytes, cid });
}
var Block;
var init_block = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/block.js"() {
    init_src();
    Block = class {
      cid;
      bytes;
      value;
      asBlock;
      constructor({ cid, bytes, value }) {
        if (cid == null || bytes == null || typeof value === "undefined") {
          throw new Error("Missing required argument");
        }
        this.cid = cid;
        this.bytes = bytes;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly2(),
          bytes: readonly2(),
          value: readonly2(),
          asBlock: readonly2()
        });
      }
      links() {
        return links(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      get(path = "/") {
        return get(this.value, path.split("/").filter(Boolean));
      }
    };
  }
});

// core/runtime/async-block-encode.ts
async function asyncBlockDecode({
  bytes,
  codec: codec2,
  hasher
}) {
  if (bytes == null) throw new Error('Missing required argument "bytes"');
  if (codec2 == null || hasher == null) throw new Error("Missing required argument: codec or hasher");
  const value = await Promise.resolve(codec2.decode(bytes));
  let toHash = bytes;
  if (codec2.valueToHashBytes) {
    toHash = await Promise.resolve(codec2.valueToHashBytes(value));
  }
  const hash2 = await hasher.digest(toHash);
  const cid = CID.create(1, codec2.code, hash2);
  return new Block({ value, bytes: toHash, cid });
}
async function asyncBlockEncode({
  value,
  codec: codec2,
  hasher
}) {
  if (typeof value === "undefined") throw new Error('Missing required argument "value"');
  if (codec2 == null || hasher == null) throw new Error("Missing required argument: codec or hasher");
  let bytes;
  let hash2;
  if (codec2.bytesToHash) {
    const hashable = await Promise.resolve(codec2.bytesToHash(value));
    hash2 = await hasher.digest(hashable);
    bytes = await Promise.resolve(codec2.encode(value));
  } else {
    bytes = await Promise.resolve(codec2.encode(value));
    hash2 = await hasher.digest(bytes);
  }
  const cid = CID.create(1, codec2.code, hash2);
  return new Block2({ value, bytes, cid });
}
async function asyncBlockCreate({
  bytes,
  cid,
  hasher,
  codec: codec2
}) {
  if (bytes == null) throw new Error('Missing required argument "bytes"');
  if (hasher == null) throw new Error('Missing required argument "hasher"');
  const value = await Promise.resolve(codec2.decode(bytes));
  const hash2 = await hasher.digest(bytes);
  if (!bytes_exports.equals(cid.multihash.bytes, hash2.bytes)) {
    throw new Error("CID hash does not match bytes");
  }
  return asyncBlockCreateUnsafe({
    bytes,
    cid,
    value,
    codec: codec2
  });
}
async function asyncBlockCreateUnsafe({
  bytes,
  cid,
  value: maybeValue,
  codec: codec2
}) {
  const value = await Promise.resolve(maybeValue !== void 0 ? maybeValue : codec2?.decode(bytes));
  if (value === void 0) throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block2({
    cid,
    bytes,
    value
  });
}
var Block2;
var init_async_block_encode = __esm({
  "core/runtime/async-block-encode.ts"() {
    "use strict";
    init_src();
    init_block();
    Block2 = Block;
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/buffer_utils.js
function concat2(...buffers) {
  const size = buffers.reduce((acc, { length: length2 }) => acc + length2, 0);
  const buf3 = new Uint8Array(size);
  let i = 0;
  for (const buffer3 of buffers) {
    buf3.set(buffer3, i);
    i += buffer3.length;
  }
  return buf3;
}
function encode9(string5) {
  const bytes = new Uint8Array(string5.length);
  for (let i = 0; i < string5.length; i++) {
    const code4 = string5.charCodeAt(i);
    if (code4 > 127) {
      throw new TypeError("non-ASCII string encountered in encode()");
    }
    bytes[i] = code4;
  }
  return bytes;
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/buffer_utils.js"() {
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/base64.js
function decodeBase64(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary2 = atob(encoded);
  const bytes = new Uint8Array(binary2.length);
  for (let i = 0; i < binary2.length; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
var init_base64 = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/base64.js"() {
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/base64url.js
function decode10(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
var init_base64url = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/base64url.js"() {
    init_buffer_utils();
    init_base64();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/errors.js
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWSInvalid, JWTInvalid, JWSSignatureVerificationFailed;
var init_errors4 = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/errors.js"() {
    JOSEError = class extends Error {
      static code = "ERR_JOSE_GENERIC";
      code = "ERR_JOSE_GENERIC";
      constructor(message2, options) {
        super(message2, options);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
      code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
      claim;
      reason;
      payload;
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JWTExpired = class extends JOSEError {
      static code = "ERR_JWT_EXPIRED";
      code = "ERR_JWT_EXPIRED";
      claim;
      reason;
      payload;
      constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
        super(message2, { cause: { claim, reason, payload } });
        this.claim = claim;
        this.reason = reason;
        this.payload = payload;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      static code = "ERR_JOSE_ALG_NOT_ALLOWED";
      code = "ERR_JOSE_ALG_NOT_ALLOWED";
    };
    JOSENotSupported = class extends JOSEError {
      static code = "ERR_JOSE_NOT_SUPPORTED";
      code = "ERR_JOSE_NOT_SUPPORTED";
    };
    JWSInvalid = class extends JOSEError {
      static code = "ERR_JWS_INVALID";
      code = "ERR_JWS_INVALID";
    };
    JWTInvalid = class extends JOSEError {
      static code = "ERR_JWT_INVALID";
      code = "ERR_JWT_INVALID";
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      constructor(message2 = "signature verification failed", options) {
        super(message2, options);
      }
    };
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/crypto_key.js
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (usage && !key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg, usage) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg))
        throw unusable(alg);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}
var unusable, isAlgorithm;
var init_crypto_key = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/crypto_key.js"() {
    unusable = (name2, prop = "algorithm.name") => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name2}`);
    isAlgorithm = (algorithm, name2) => algorithm.name === name2;
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/invalid_key_input.js
function message(msg, actual, ...types) {
  types = types.filter(Boolean);
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalidKeyInput, withAlg;
var init_invalid_key_input = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/invalid_key_input.js"() {
    invalidKeyInput = (actual, ...types) => message("Key must be ", actual, ...types);
    withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_key_like.js
var isCryptoKey, isKeyObject, isKeyLike;
var init_is_key_like = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_key_like.js"() {
    isCryptoKey = (key) => {
      if (key?.[Symbol.toStringTag] === "CryptoKey")
        return true;
      try {
        return key instanceof CryptoKey;
      } catch {
        return false;
      }
    };
    isKeyObject = (key) => key?.[Symbol.toStringTag] === "KeyObject";
    isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_disjoint.js
function isDisjoint(...headers) {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}
var init_is_disjoint = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_disjoint.js"() {
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_object.js
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var isObjectLike;
var init_is_object = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_object.js"() {
    isObjectLike = (value) => typeof value === "object" && value !== null;
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/check_key_length.js
function checkKeyLength(alg, key) {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}
var init_check_key_length = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/check_key_length.js"() {
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
async function jwkToKey(jwk) {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
}
var init_jwk_to_key = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/jwk_to_key.js"() {
    init_errors4();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var init_validate_crit = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/validate_crit.js"() {
    init_errors4();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/validate_algorithms.js
function validateAlgorithms(option, algorithms) {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
}
var init_validate_algorithms = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/validate_algorithms.js"() {
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_jwk.js
var isJWK, isPrivateJWK, isPublicJWK, isSecretJWK;
var init_is_jwk = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/is_jwk.js"() {
    init_is_object();
    isJWK = (key) => isObject2(key) && typeof key.kty === "string";
    isPrivateJWK = (key) => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");
    isPublicJWK = (key) => key.kty !== "oct" && key.d === void 0 && key.priv === void 0;
    isSecretJWK = (key) => key.kty === "oct" && typeof key.k === "string";
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/normalize_key.js
async function normalizeKey(key, alg) {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode10(key.k);
    }
    return handleJWK(key, key, alg, true);
  }
  throw new Error("unreachable");
}
var cache2, handleJWK, handleKeyObject;
var init_normalize_key = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/normalize_key.js"() {
    init_is_jwk();
    init_base64url();
    init_jwk_to_key();
    init_is_key_like();
    handleJWK = async (key, jwk, alg, freeze2 = false) => {
      cache2 ||= /* @__PURE__ */ new WeakMap();
      let cached2 = cache2.get(key);
      if (cached2?.[alg]) {
        return cached2[alg];
      }
      const cryptoKey = await jwkToKey({ ...jwk, alg });
      if (freeze2)
        Object.freeze(key);
      if (!cached2) {
        cache2.set(key, { [alg]: cryptoKey });
      } else {
        cached2[alg] = cryptoKey;
      }
      return cryptoKey;
    };
    handleKeyObject = (keyObject, alg) => {
      cache2 ||= /* @__PURE__ */ new WeakMap();
      let cached2 = cache2.get(keyObject);
      if (cached2?.[alg]) {
        return cached2[alg];
      }
      const isPublic = keyObject.type === "public";
      const extractable = isPublic ? true : false;
      let cryptoKey;
      if (keyObject.asymmetricKeyType === "x25519") {
        switch (alg) {
          case "ECDH-ES":
          case "ECDH-ES+A128KW":
          case "ECDH-ES+A192KW":
          case "ECDH-ES+A256KW":
            break;
          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
      }
      if (keyObject.asymmetricKeyType === "ed25519") {
        if (alg !== "EdDSA" && alg !== "Ed25519") {
          throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
          isPublic ? "verify" : "sign"
        ]);
      }
      switch (keyObject.asymmetricKeyType) {
        case "ml-dsa-44":
        case "ml-dsa-65":
        case "ml-dsa-87": {
          if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
          }
          cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
            isPublic ? "verify" : "sign"
          ]);
        }
      }
      if (keyObject.asymmetricKeyType === "rsa") {
        let hash2;
        switch (alg) {
          case "RSA-OAEP":
            hash2 = "SHA-1";
            break;
          case "RS256":
          case "PS256":
          case "RSA-OAEP-256":
            hash2 = "SHA-256";
            break;
          case "RS384":
          case "PS384":
          case "RSA-OAEP-384":
            hash2 = "SHA-384";
            break;
          case "RS512":
          case "PS512":
          case "RSA-OAEP-512":
            hash2 = "SHA-512";
            break;
          default:
            throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg.startsWith("RSA-OAEP")) {
          return keyObject.toCryptoKey({
            name: "RSA-OAEP",
            hash: hash2
          }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
        }
        cryptoKey = keyObject.toCryptoKey({
          name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
          hash: hash2
        }, extractable, [isPublic ? "verify" : "sign"]);
      }
      if (keyObject.asymmetricKeyType === "ec") {
        const nist = /* @__PURE__ */ new Map([
          ["prime256v1", "P-256"],
          ["secp384r1", "P-384"],
          ["secp521r1", "P-521"]
        ]);
        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
        if (!namedCurve) {
          throw new TypeError("given KeyObject instance cannot be used for this algorithm");
        }
        if (alg === "ES256" && namedCurve === "P-256") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg === "ES384" && namedCurve === "P-384") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg === "ES512" && namedCurve === "P-521") {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDSA",
            namedCurve
          }, extractable, [isPublic ? "verify" : "sign"]);
        }
        if (alg.startsWith("ECDH-ES")) {
          cryptoKey = keyObject.toCryptoKey({
            name: "ECDH",
            namedCurve
          }, extractable, isPublic ? [] : ["deriveBits"]);
        }
      }
      if (!cryptoKey) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      if (!cached2) {
        cache2.set(keyObject, { [alg]: cryptoKey });
      } else {
        cached2[alg] = cryptoKey;
      }
      return cryptoKey;
    };
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/check_key_type.js
function checkKeyType(alg, key, usage) {
  switch (alg.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      symmetricTypeCheck(alg, key, usage);
      break;
    default:
      asymmetricTypeCheck(alg, key, usage);
  }
}
var tag, jwkMatchesOp, symmetricTypeCheck, asymmetricTypeCheck;
var init_check_key_type = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    init_is_jwk();
    tag = (key) => key?.[Symbol.toStringTag];
    jwkMatchesOp = (alg, key, usage) => {
      if (key.use !== void 0) {
        let expected;
        switch (usage) {
          case "sign":
          case "verify":
            expected = "sig";
            break;
          case "encrypt":
          case "decrypt":
            expected = "enc";
            break;
        }
        if (key.use !== expected) {
          throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
        }
      }
      if (key.alg !== void 0 && key.alg !== alg) {
        throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg}" when present`);
      }
      if (Array.isArray(key.key_ops)) {
        let expectedKeyOp;
        switch (true) {
          case (usage === "sign" || usage === "verify"):
          case alg === "dir":
          case alg.includes("CBC-HS"):
            expectedKeyOp = usage;
            break;
          case alg.startsWith("PBES2"):
            expectedKeyOp = "deriveBits";
            break;
          case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
            if (!alg.includes("GCM") && alg.endsWith("KW")) {
              expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
            } else {
              expectedKeyOp = usage;
            }
            break;
          case (usage === "encrypt" && alg.startsWith("RSA")):
            expectedKeyOp = "wrapKey";
            break;
          case usage === "decrypt":
            expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
            break;
        }
        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
          throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
        }
      }
      return true;
    };
    symmetricTypeCheck = (alg, key, usage) => {
      if (key instanceof Uint8Array)
        return;
      if (isJWK(key)) {
        if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
      }
      if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (isJWK(key)) {
        switch (usage) {
          case "decrypt":
          case "sign":
            if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation must be a private JWK`);
          case "encrypt":
          case "verify":
            if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
              return;
            throw new TypeError(`JSON Web Key for this operation must be a public JWK`);
        }
      }
      if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
      }
      if (key.type === "secret") {
        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (key.type === "public") {
        switch (usage) {
          case "sign":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
          case "decrypt":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
        }
      }
      if (key.type === "private") {
        switch (usage) {
          case "verify":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
          case "encrypt":
            throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
        }
      }
    };
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/subtle_dsa.js
function subtleAlgorithm(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: parseInt(alg.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/subtle_dsa.js"() {
    init_errors4();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js
async function getSigKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg, usage);
  return key;
}
var init_get_sign_verify_key = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js"() {
    init_crypto_key();
    init_invalid_key_input();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/verify.js
async function verify(alg, key, signature, data) {
  const cryptoKey = await getSigKey(alg, key, "verify");
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
}
var init_verify = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/verify.js"() {
    init_subtle_dsa();
    init_check_key_length();
    init_get_sign_verify_key();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode10(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType(alg, key, "verify");
  const data = concat2(jws.protected !== void 0 ? encode9(jws.protected) : new Uint8Array(), encode9("."), typeof jws.payload === "string" ? b64 ? encode9(jws.payload) : encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode10(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k = await normalizeKey(key, alg);
  const verified = await verify(alg, k, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode10(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: k };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors4();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
    init_normalize_key();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length: length2 } = jws.split(".");
  if (length2 !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jws/compact/verify.js"() {
    init_verify2();
    init_errors4();
    init_buffer_utils();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/jwt_claims_set.js
function secs(str) {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject2(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}
var epoch, minute, hour, day, week, year, REGEX, normalizeTyp, checkAudiencePresence;
var init_jwt_claims_set = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/lib/jwt_claims_set.js"() {
    init_errors4();
    init_buffer_utils();
    init_is_object();
    epoch = (date5) => Math.floor(date5.getTime() / 1e3);
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
    normalizeTyp = (value) => {
      if (value.includes("/")) {
        return value.toLowerCase();
      }
      return `application/${value.toLowerCase()}`;
    };
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jwt/verify.js
async function jwtVerify(jwt2, key, options) {
  const verified = await compactVerify(jwt2, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify4 = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors4();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/decode_jwt.js
function decodeJwt(jwt2) {
  if (typeof jwt2 !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length: length2 } = jwt2.split(".");
  if (length2 === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length2 !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode10(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject2(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/util/decode_jwt.js"() {
    init_base64url();
    init_buffer_utils();
    init_is_object();
    init_errors4();
  }
});

// node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/index.js
var init_webapi = __esm({
  "node_modules/.pnpm/jose@6.1.3/node_modules/jose/dist/webapi/index.js"() {
    init_verify4();
    init_decode_jwt();
  }
});

// core/runtime/sts-service/index.ts
var keysFromWellKnownJwksCache;
var init_sts_service = __esm({
  "core/runtime/sts-service/index.ts"() {
    "use strict";
    init_esm();
    init_base58();
    init_utils();
    init_base2();
    init_v4();
    keysFromWellKnownJwksCache = new KeyedResolvOnce({
      resetAfter: 30 * 60 * 1e3
      // 30 minutes
    });
  }
});

// core/runtime/commit-queue.ts
var CommitQueue;
var init_commit_queue = __esm({
  "core/runtime/commit-queue.ts"() {
    "use strict";
    init_esm();
    CommitQueue = class {
      queue = [];
      processing = false;
      traceFn;
      constructor({ tracer }) {
        this.traceFn = tracer;
      }
      _waitIdleItems = /* @__PURE__ */ new Set();
      waitIdle() {
        if (this.queue.length === 0 && !this.processing) {
          return Promise.resolve();
        }
        const fn = new Future();
        this._waitIdleItems.add(fn);
        return fn.asPromise();
      }
      async enqueue(fn) {
        return new Promise((resolve, reject) => {
          const queueFn = async () => {
            try {
              resolve(await fn());
            } catch (e) {
              reject(e);
            } finally {
              this.processing = false;
              this.processNext();
            }
          };
          this.traceFn({
            event: "busyFromCommitQueue",
            queueLen: this.queue.length + 1
          });
          this.queue.push(queueFn);
          if (!this.processing) {
            this.processNext();
          }
        });
      }
      processNext() {
        if (this.queue.length > 0 && !this.processing) {
          this.processing = true;
          const queueFn = this.queue.shift();
          if (queueFn) {
            queueFn().finally(() => {
            });
          }
        }
        if (this.queue.length === 0 && !this.processing) {
          this.traceFn({
            event: "idleFromCommitQueue"
          });
          const toResolve = Array.from(this._waitIdleItems);
          this._waitIdleItems.clear();
          toResolve.map((fn) => fn.resolve());
        }
      }
    };
  }
});

// core/runtime/task-manager.ts
var TaskManager;
var init_task_manager = __esm({
  "core/runtime/task-manager.ts"() {
    "use strict";
    init_utils();
    TaskManager = class {
      // we need to remove the events after some time
      eventsWeHandled = /* @__PURE__ */ new Set();
      queue = [];
      isProcessing = false;
      logger;
      params;
      callback;
      constructor(sthis, callback, params) {
        this.logger = ensureLogger(sthis, "TaskManager");
        this.callback = callback;
        this.params = params;
      }
      async handleEvent(cid, parents, dbMeta, store) {
        for (const parent of parents) {
          this.eventsWeHandled.add(parent.toString());
        }
        this.queue.push({ cid: cid.toString(), dbMeta, retries: 0, store });
        this.queue = this.queue.filter(({ cid: cid2 }) => !this.eventsWeHandled.has(cid2));
        void this.processQueue();
      }
      async processQueue() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        const filteredQueue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));
        const first = filteredQueue[0];
        if (!first) {
          this.isProcessing = false;
          return;
        }
        try {
          await this.callback(first.dbMeta, first.store);
          this.eventsWeHandled.add(first.cid);
          this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));
        } catch (err) {
          if (first.retries++ > 3) {
            this.logger.Error().Str("cid", first.cid).Msg("failed to process event block after 3 retries");
            this.queue = this.queue.filter(({ cid }) => cid !== first.cid);
          }
          await new Promise((resolve) => setTimeout(resolve, 50));
          this.logger.Warn().Err(err).Msg("retry to process event block");
        } finally {
          this.isProcessing = false;
          if (this.queue.length > 0) {
            void this.processQueue();
          }
        }
      }
    };
  }
});

// core/runtime/register-compact-strategy.ts
function registerCompactStrategy(compactStrategy) {
  const key = compactStrategy.name.toLowerCase();
  if (compactStrategyRegistry.has(key)) {
    return () => {
      compactStrategyRegistry.delete(key);
    };
  }
  compactStrategyRegistry.set(key, compactStrategy);
  return () => {
    compactStrategyRegistry.delete(key);
  };
}
function getCompactStrategy(name2 = "fireproof") {
  return exception2Result(() => getCompactStrategyThrow(name2));
}
function getCompactStrategyThrow(name2 = "fireproof") {
  const key = name2.toLowerCase();
  if (!compactStrategyRegistry.has(key)) {
    throw new Error(`compactStrategy ${name2} not found`);
  }
  return compactStrategyRegistry.get(key);
}
var compactStrategyRegistry;
var init_register_compact_strategy = __esm({
  "core/runtime/register-compact-strategy.ts"() {
    "use strict";
    init_esm();
    compactStrategyRegistry = /* @__PURE__ */ new Map();
  }
});

// core/runtime/index.ts
var init_runtime2 = __esm({
  "core/runtime/index.ts"() {
    "use strict";
    init_files();
    init_keyed_crypto();
    init_async_block_encode();
    init_sts_service();
    init_esm();
    init_utils();
    init_commit_queue();
    init_task_manager();
    init_register_compact_strategy();
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/is.js
function is2(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs2.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer3(value)) {
    return "Buffer";
  }
  const objectType = getObjectType2(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer3(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType2(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames2.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs2, objectTypeNames2;
var init_is3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/is.js"() {
    typeofs2 = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames2 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/token.js
var Type2, Token2;
var init_token2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/token.js"() {
    Type2 = class {
      /**
       * @param {number} major
       * @param {string} name
       * @param {boolean} terminal
       */
      constructor(major, name2, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name2;
        this.terminal = terminal;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      /**
       * @param {Type} typ
       * @returns {number}
       */
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type2.uint = new Type2(0, "uint", true);
    Type2.negint = new Type2(1, "negint", true);
    Type2.bytes = new Type2(2, "bytes", true);
    Type2.string = new Type2(3, "string", true);
    Type2.array = new Type2(4, "array", false);
    Type2.map = new Type2(5, "map", false);
    Type2.tag = new Type2(6, "tag", false);
    Type2.float = new Type2(7, "float", true);
    Type2.false = new Type2(7, "false", true);
    Type2.true = new Type2(7, "true", true);
    Type2.null = new Type2(7, "null", true);
    Type2.undefined = new Type2(7, "undefined", true);
    Type2.break = new Type2(7, "break", true);
    Token2 = class {
      /**
       * @param {Type} type
       * @param {any} [value]
       * @param {number} [encodedLength]
       */
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
        this.byteValue = void 0;
      }
      /* c8 ignore next 3 */
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/byte-utils.js
function isBuffer4(buf3) {
  return useBuffer2 && globalThis.Buffer.isBuffer(buf3);
}
function asU8A2(buf3) {
  if (!(buf3 instanceof Uint8Array)) {
    return Uint8Array.from(buf3);
  }
  return isBuffer4(buf3) ? new Uint8Array(buf3.buffer, buf3.byteOffset, buf3.byteLength) : buf3;
}
function compare2(b1, b2) {
  if (isBuffer4(b1) && isBuffer4(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes2(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
}
function utf8Slice2(buf3, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf3[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf3[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf3[offset + 1];
          thirdByte = buf3[offset + 2];
          fourthByte = buf3[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
function decodeCodePointsArray2(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
var useBuffer2, textDecoder3, textEncoder3, toString3, fromString3, fromArray2, slice2, concat3, alloc2, MAX_ARGUMENTS_LENGTH2;
var init_byte_utils2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/byte-utils.js"() {
    useBuffer2 = globalThis.process && // @ts-ignore
    !globalThis.process.browser && // @ts-ignore
    globalThis.Buffer && // @ts-ignore
    typeof globalThis.Buffer.isBuffer === "function";
    textDecoder3 = new TextDecoder();
    textEncoder3 = new TextEncoder();
    toString3 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return end - start > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(bytes.subarray(start, end)).toString("utf8")
        ) : utf8Slice2(bytes, start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return end - start > 64 ? textDecoder3.decode(bytes.subarray(start, end)) : utf8Slice2(bytes, start, end);
      }
    );
    fromString3 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string5) => {
        return string5.length > 64 ? (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(string5)
        ) : utf8ToBytes2(string5);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {string} string
       */
      (string5) => {
        return string5.length > 64 ? textEncoder3.encode(string5) : utf8ToBytes2(string5);
      }
    );
    fromArray2 = (arr) => {
      return Uint8Array.from(arr);
    };
    slice2 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        if (isBuffer4(bytes)) {
          return new Uint8Array(bytes.subarray(start, end));
        }
        return bytes.slice(start, end);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array} bytes
       * @param {number} start
       * @param {number} end
       */
      (bytes, start, end) => {
        return bytes.slice(start, end);
      }
    );
    concat3 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length2) => {
        chunks = chunks.map((c) => c instanceof Uint8Array ? c : (
          // eslint-disable-line operator-linebreak
          // @ts-ignore
          globalThis.Buffer.from(c)
        ));
        return asU8A2(globalThis.Buffer.concat(chunks, length2));
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {Uint8Array[]} chunks
       * @param {number} length
       * @returns {Uint8Array}
       */
      (chunks, length2) => {
        const out = new Uint8Array(length2);
        let off = 0;
        for (let b of chunks) {
          if (off + b.length > out.length) {
            b = b.subarray(0, out.length - off);
          }
          out.set(b, off);
          off += b.length;
        }
        return out;
      }
    );
    alloc2 = useBuffer2 ? (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size) => {
        return globalThis.Buffer.allocUnsafe(size);
      }
    ) : (
      // eslint-disable-line operator-linebreak
      /**
       * @param {number} size
       * @returns {Uint8Array}
       */
      (size) => {
        return new Uint8Array(size);
      }
    );
    MAX_ARGUMENTS_LENGTH2 = 4096;
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/bl.js
var defaultChunkSize2, Bl2;
var init_bl2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/bl.js"() {
    init_byte_utils2();
    defaultChunkSize2 = 256;
    Bl2 = class {
      /**
       * @param {number} [chunkSize]
       */
      constructor(chunkSize = defaultChunkSize2) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.cursor = 0;
        this.maxCursor = -1;
        if (this.chunks.length) {
          this.chunks = [];
        }
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      /**
       * @param {Uint8Array|number[]} bytes
       */
      push(bytes) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes.length < 64 && bytes.length < this.chunkSize) {
            topChunk = alloc2(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes, 0);
          } else {
            this.chunks.push(bytes);
            this.maxCursor += bytes.length;
          }
        }
        this.cursor += bytes.length;
      }
      /**
       * @param {boolean} [reset]
       * @returns {Uint8Array}
       */
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice2(chunk, 0, this.cursor);
          }
        } else {
          byts = concat3(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/common.js
function assertEnoughData2(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix2} not enough data for type`);
  }
}
var decodeErrPrefix2, encodeErrPrefix2, uintMinorPrefixBytes2;
var init_common2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/common.js"() {
    decodeErrPrefix2 = "CBOR decode error:";
    encodeErrPrefix2 = "CBOR encode error:";
    uintMinorPrefixBytes2 = [];
    uintMinorPrefixBytes2[23] = 1;
    uintMinorPrefixBytes2[24] = 2;
    uintMinorPrefixBytes2[25] = 3;
    uintMinorPrefixBytes2[26] = 5;
    uintMinorPrefixBytes2[27] = 9;
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/0uint.js
function readUint82(data, offset, options) {
  assertEnoughData2(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries2[0]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint162(data, offset, options) {
  assertEnoughData2(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries2[1]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint322(data, offset, options) {
  assertEnoughData2(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries2[2]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint642(data, offset, options) {
  assertEnoughData2(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries2[3]) {
    throw new Error(`${decodeErrPrefix2} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
}
function decodeUint82(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint82(data, pos + 1, options), 2);
}
function decodeUint162(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint162(data, pos + 1, options), 3);
}
function decodeUint322(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint322(data, pos + 1, options), 5);
}
function decodeUint642(data, pos, _minor, options) {
  return new Token2(Type2.uint, readUint642(data, pos + 1, options), 9);
}
function encodeUint2(buf3, token) {
  return encodeUintValue2(buf3, 0, token.value);
}
function encodeUintValue2(buf3, major, uint) {
  if (uint < uintBoundaries2[0]) {
    const nuint = Number(uint);
    buf3.push([major | nuint]);
  } else if (uint < uintBoundaries2[1]) {
    const nuint = Number(uint);
    buf3.push([major | 24, nuint]);
  } else if (uint < uintBoundaries2[2]) {
    const nuint = Number(uint);
    buf3.push([major | 25, nuint >>> 8, nuint & 255]);
  } else if (uint < uintBoundaries2[3]) {
    const nuint = Number(uint);
    buf3.push([major | 26, nuint >>> 24 & 255, nuint >>> 16 & 255, nuint >>> 8 & 255, nuint & 255]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries2[4]) {
      const set3 = [major | 27, 0, 0, 0, 0, 0, 0, 0];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set3[8] = lo & 255;
      lo = lo >> 8;
      set3[7] = lo & 255;
      lo = lo >> 8;
      set3[6] = lo & 255;
      lo = lo >> 8;
      set3[5] = lo & 255;
      set3[4] = hi & 255;
      hi = hi >> 8;
      set3[3] = hi & 255;
      hi = hi >> 8;
      set3[2] = hi & 255;
      hi = hi >> 8;
      set3[1] = hi & 255;
      buf3.push(set3);
    } else {
      throw new Error(`${decodeErrPrefix2} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries2;
var init_uint2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/0uint.js"() {
    init_token2();
    init_common2();
    uintBoundaries2 = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
    encodeUint2.encodedSize = function encodedSize9(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
    encodeUintValue2.encodedSize = function encodedSize10(uint) {
      if (uint < uintBoundaries2[0]) {
        return 1;
      }
      if (uint < uintBoundaries2[1]) {
        return 2;
      }
      if (uint < uintBoundaries2[2]) {
        return 3;
      }
      if (uint < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint2.compareTokens = function compareTokens4(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/1negint.js
function decodeNegint82(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint82(data, pos + 1, options), 2);
}
function decodeNegint162(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint162(data, pos + 1, options), 3);
}
function decodeNegint322(data, pos, _minor, options) {
  return new Token2(Type2.negint, -1 - readUint322(data, pos + 1, options), 5);
}
function decodeNegint642(data, pos, _minor, options) {
  const int4 = readUint642(data, pos + 1, options);
  if (typeof int4 !== "bigint") {
    const value = -1 - int4;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token2(Type2.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix2} integers outside of the safe integer range are not supported`);
  }
  return new Token2(Type2.negint, neg1b2 - BigInt(int4), 9);
}
function encodeNegint2(buf3, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
  encodeUintValue2(buf3, token.type.majorEncoded, unsigned);
}
var neg1b2, pos1b2;
var init_negint2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/1negint.js"() {
    init_token2();
    init_uint2();
    init_common2();
    neg1b2 = BigInt(-1);
    pos1b2 = BigInt(1);
    encodeNegint2.encodedSize = function encodedSize11(token) {
      const negint = token.value;
      const unsigned = typeof negint === "bigint" ? negint * neg1b2 - pos1b2 : negint * -1 - 1;
      if (unsigned < uintBoundaries2[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries2[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries2[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries2[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint2.compareTokens = function compareTokens5(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : (
        /* c8 ignore next */
        0
      );
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/2bytes.js
function toToken5(data, pos, prefix, length2) {
  assertEnoughData2(data, pos, prefix + length2);
  const buf3 = slice2(data, pos + prefix, pos + prefix + length2);
  return new Token2(Type2.bytes, buf3, prefix + length2);
}
function decodeBytesCompact2(data, pos, minor, _options) {
  return toToken5(data, pos, 1, minor);
}
function decodeBytes82(data, pos, _minor, options) {
  return toToken5(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeBytes162(data, pos, _minor, options) {
  return toToken5(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeBytes322(data, pos, _minor, options) {
  return toToken5(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeBytes642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer bytes lengths not supported`);
  }
  return toToken5(data, pos, 9, l);
}
function tokenBytes2(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type2.string ? fromString3(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes2(buf3, token) {
  const bytes = tokenBytes2(token);
  encodeUintValue2(buf3, token.type.majorEncoded, bytes.length);
  buf3.push(bytes);
}
function compareBytes2(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare2(b1, b2);
}
var init_bytes3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/2bytes.js"() {
    init_token2();
    init_common2();
    init_uint2();
    init_byte_utils2();
    encodeBytes2.encodedSize = function encodedSize12(token) {
      const bytes = tokenBytes2(token);
      return encodeUintValue2.encodedSize(bytes.length) + bytes.length;
    };
    encodeBytes2.compareTokens = function compareTokens6(tok1, tok2) {
      return compareBytes2(tokenBytes2(tok1), tokenBytes2(tok2));
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/3string.js
function toToken6(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData2(data, pos, totLength);
  const tok = new Token2(Type2.string, toString3(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice2(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact2(data, pos, minor, options) {
  return toToken6(data, pos, 1, minor, options);
}
function decodeString82(data, pos, _minor, options) {
  return toToken6(data, pos, 2, readUint82(data, pos + 1, options), options);
}
function decodeString162(data, pos, _minor, options) {
  return toToken6(data, pos, 3, readUint162(data, pos + 1, options), options);
}
function decodeString322(data, pos, _minor, options) {
  return toToken6(data, pos, 5, readUint322(data, pos + 1, options), options);
}
function decodeString642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer string lengths not supported`);
  }
  return toToken6(data, pos, 9, l, options);
}
var encodeString2;
var init_string3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/3string.js"() {
    init_token2();
    init_common2();
    init_uint2();
    init_bytes3();
    init_byte_utils2();
    encodeString2 = encodeBytes2;
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/4array.js
function toToken7(_data, _pos, prefix, length2) {
  return new Token2(Type2.array, length2, prefix);
}
function decodeArrayCompact2(data, pos, minor, _options) {
  return toToken7(data, pos, 1, minor);
}
function decodeArray82(data, pos, _minor, options) {
  return toToken7(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeArray162(data, pos, _minor, options) {
  return toToken7(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeArray322(data, pos, _minor, options) {
  return toToken7(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeArray642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer array lengths not supported`);
  }
  return toToken7(data, pos, 9, l);
}
function decodeArrayIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken7(data, pos, 1, Infinity);
}
function encodeArray2(buf3, token) {
  encodeUintValue2(buf3, Type2.array.majorEncoded, token.value);
}
var init_array2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/4array.js"() {
    init_token2();
    init_uint2();
    init_common2();
    encodeArray2.compareTokens = encodeUint2.compareTokens;
    encodeArray2.encodedSize = function encodedSize13(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/5map.js
function toToken8(_data, _pos, prefix, length2) {
  return new Token2(Type2.map, length2, prefix);
}
function decodeMapCompact2(data, pos, minor, _options) {
  return toToken8(data, pos, 1, minor);
}
function decodeMap82(data, pos, _minor, options) {
  return toToken8(data, pos, 2, readUint82(data, pos + 1, options));
}
function decodeMap162(data, pos, _minor, options) {
  return toToken8(data, pos, 3, readUint162(data, pos + 1, options));
}
function decodeMap322(data, pos, _minor, options) {
  return toToken8(data, pos, 5, readUint322(data, pos + 1, options));
}
function decodeMap642(data, pos, _minor, options) {
  const l = readUint642(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix2} 64-bit integer map lengths not supported`);
  }
  return toToken8(data, pos, 9, l);
}
function decodeMapIndefinite2(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return toToken8(data, pos, 1, Infinity);
}
function encodeMap2(buf3, token) {
  encodeUintValue2(buf3, Type2.map.majorEncoded, token.value);
}
var init_map3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/5map.js"() {
    init_token2();
    init_uint2();
    init_common2();
    encodeMap2.compareTokens = encodeUint2.compareTokens;
    encodeMap2.encodedSize = function encodedSize14(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/6tag.js
function decodeTagCompact2(_data, _pos, minor, _options) {
  return new Token2(Type2.tag, minor, 1);
}
function decodeTag82(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint82(data, pos + 1, options), 2);
}
function decodeTag162(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint162(data, pos + 1, options), 3);
}
function decodeTag322(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint322(data, pos + 1, options), 5);
}
function decodeTag642(data, pos, _minor, options) {
  return new Token2(Type2.tag, readUint642(data, pos + 1, options), 9);
}
function encodeTag2(buf3, token) {
  encodeUintValue2(buf3, Type2.tag.majorEncoded, token.value);
}
var init_tag2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/6tag.js"() {
    init_token2();
    init_uint2();
    encodeTag2.compareTokens = encodeUint2.compareTokens;
    encodeTag2.encodedSize = function encodedSize15(token) {
      return encodeUintValue2.encodedSize(token.value);
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/7float.js
function decodeUndefined2(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix2} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token2(Type2.null, null, 1);
  }
  return new Token2(Type2.undefined, void 0, 1);
}
function decodeBreak2(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix2} indefinite length items not allowed`);
  }
  return new Token2(Type2.break, void 0, 1);
}
function createToken2(value, bytes, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix2} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix2} Infinity values are not supported`);
    }
  }
  return new Token2(Type2.float, value, bytes);
}
function decodeFloat162(data, pos, _minor, options) {
  return createToken2(readFloat162(data, pos + 1), 3, options);
}
function decodeFloat322(data, pos, _minor, options) {
  return createToken2(readFloat322(data, pos + 1), 5, options);
}
function decodeFloat642(data, pos, _minor, options) {
  return createToken2(readFloat642(data, pos + 1), 9, options);
}
function encodeFloat2(buf3, token, options) {
  const float3 = token.value;
  if (float3 === false) {
    buf3.push([Type2.float.majorEncoded | MINOR_FALSE2]);
  } else if (float3 === true) {
    buf3.push([Type2.float.majorEncoded | MINOR_TRUE2]);
  } else if (float3 === null) {
    buf3.push([Type2.float.majorEncoded | MINOR_NULL2]);
  } else if (float3 === void 0) {
    buf3.push([Type2.float.majorEncoded | MINOR_UNDEFINED2]);
  } else {
    let decoded;
    let success2 = false;
    if (!options || options.float64 !== true) {
      encodeFloat162(float3);
      decoded = readFloat162(ui8a2, 1);
      if (float3 === decoded || Number.isNaN(float3)) {
        ui8a2[0] = 249;
        buf3.push(ui8a2.slice(0, 3));
        success2 = true;
      } else {
        encodeFloat322(float3);
        decoded = readFloat322(ui8a2, 1);
        if (float3 === decoded) {
          ui8a2[0] = 250;
          buf3.push(ui8a2.slice(0, 5));
          success2 = true;
        }
      }
    }
    if (!success2) {
      encodeFloat642(float3);
      decoded = readFloat642(ui8a2, 1);
      ui8a2[0] = 251;
      buf3.push(ui8a2.slice(0, 9));
    }
  }
}
function encodeFloat162(inp) {
  if (inp === Infinity) {
    dataView2.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView2.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView2.setUint16(0, 32256, false);
  } else {
    dataView2.setFloat32(0, inp);
    const valu32 = dataView2.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView2.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView2.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView2.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | /* sign bit */
        1 << 24 + logicalExponent, false);
      } else {
        dataView2.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat162(ui8a3, pos) {
  if (ui8a3.length - pos < 2) {
    throw new Error(`${decodeErrPrefix2} not enough data for float16`);
  }
  const half = (ui8a3[pos] << 8) + ui8a3[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat322(inp) {
  dataView2.setFloat32(0, inp, false);
}
function readFloat322(ui8a3, pos) {
  if (ui8a3.length - pos < 4) {
    throw new Error(`${decodeErrPrefix2} not enough data for float32`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat642(inp) {
  dataView2.setFloat64(0, inp, false);
}
function readFloat642(ui8a3, pos) {
  if (ui8a3.length - pos < 8) {
    throw new Error(`${decodeErrPrefix2} not enough data for float64`);
  }
  const offset = (ui8a3.byteOffset || 0) + pos;
  return new DataView(ui8a3.buffer, offset, 8).getFloat64(0, false);
}
var MINOR_FALSE2, MINOR_TRUE2, MINOR_NULL2, MINOR_UNDEFINED2, buffer2, dataView2, ui8a2;
var init_float4 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/7float.js"() {
    init_token2();
    init_common2();
    init_uint2();
    MINOR_FALSE2 = 20;
    MINOR_TRUE2 = 21;
    MINOR_NULL2 = 22;
    MINOR_UNDEFINED2 = 23;
    encodeFloat2.encodedSize = function encodedSize16(token, options) {
      const float3 = token.value;
      if (float3 === false || float3 === true || float3 === null || float3 === void 0) {
        return 1;
      }
      if (!options || options.float64 !== true) {
        encodeFloat162(float3);
        let decoded = readFloat162(ui8a2, 1);
        if (float3 === decoded || Number.isNaN(float3)) {
          return 3;
        }
        encodeFloat322(float3);
        decoded = readFloat322(ui8a2, 1);
        if (float3 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer2 = new ArrayBuffer(9);
    dataView2 = new DataView(buffer2, 1);
    ui8a2 = new Uint8Array(buffer2, 0);
    encodeFloat2.compareTokens = encodeUint2.compareTokens;
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/jump.js
function invalidMinor2(data, pos, minor) {
  throw new Error(`${decodeErrPrefix2} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer2(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix2} ${msg}`);
  };
}
function quickEncodeToken2(token) {
  switch (token.type) {
    case Type2.false:
      return fromArray2([244]);
    case Type2.true:
      return fromArray2([245]);
    case Type2.null:
      return fromArray2([246]);
    case Type2.bytes:
      if (!token.value.length) {
        return fromArray2([64]);
      }
      return;
    case Type2.string:
      if (token.value === "") {
        return fromArray2([96]);
      }
      return;
    case Type2.array:
      if (token.value === 0) {
        return fromArray2([128]);
      }
      return;
    case Type2.map:
      if (token.value === 0) {
        return fromArray2([160]);
      }
      return;
    case Type2.uint:
      if (token.value < 24) {
        return fromArray2([Number(token.value)]);
      }
      return;
    case Type2.negint:
      if (token.value >= -24) {
        return fromArray2([31 - Number(token.value)]);
      }
  }
}
var jump2, quick2;
var init_jump2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/jump.js"() {
    init_token2();
    init_uint2();
    init_negint2();
    init_bytes3();
    init_string3();
    init_array2();
    init_map3();
    init_tag2();
    init_float4();
    init_common2();
    init_byte_utils2();
    jump2 = [];
    for (let i = 0; i <= 23; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[24] = decodeUint82;
    jump2[25] = decodeUint162;
    jump2[26] = decodeUint322;
    jump2[27] = decodeUint642;
    jump2[28] = invalidMinor2;
    jump2[29] = invalidMinor2;
    jump2[30] = invalidMinor2;
    jump2[31] = invalidMinor2;
    for (let i = 32; i <= 55; i++) {
      jump2[i] = invalidMinor2;
    }
    jump2[56] = decodeNegint82;
    jump2[57] = decodeNegint162;
    jump2[58] = decodeNegint322;
    jump2[59] = decodeNegint642;
    jump2[60] = invalidMinor2;
    jump2[61] = invalidMinor2;
    jump2[62] = invalidMinor2;
    jump2[63] = invalidMinor2;
    for (let i = 64; i <= 87; i++) {
      jump2[i] = decodeBytesCompact2;
    }
    jump2[88] = decodeBytes82;
    jump2[89] = decodeBytes162;
    jump2[90] = decodeBytes322;
    jump2[91] = decodeBytes642;
    jump2[92] = invalidMinor2;
    jump2[93] = invalidMinor2;
    jump2[94] = invalidMinor2;
    jump2[95] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump2[i] = decodeStringCompact2;
    }
    jump2[120] = decodeString82;
    jump2[121] = decodeString162;
    jump2[122] = decodeString322;
    jump2[123] = decodeString642;
    jump2[124] = invalidMinor2;
    jump2[125] = invalidMinor2;
    jump2[126] = invalidMinor2;
    jump2[127] = errorer2("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump2[i] = decodeArrayCompact2;
    }
    jump2[152] = decodeArray82;
    jump2[153] = decodeArray162;
    jump2[154] = decodeArray322;
    jump2[155] = decodeArray642;
    jump2[156] = invalidMinor2;
    jump2[157] = invalidMinor2;
    jump2[158] = invalidMinor2;
    jump2[159] = decodeArrayIndefinite2;
    for (let i = 160; i <= 183; i++) {
      jump2[i] = decodeMapCompact2;
    }
    jump2[184] = decodeMap82;
    jump2[185] = decodeMap162;
    jump2[186] = decodeMap322;
    jump2[187] = decodeMap642;
    jump2[188] = invalidMinor2;
    jump2[189] = invalidMinor2;
    jump2[190] = invalidMinor2;
    jump2[191] = decodeMapIndefinite2;
    for (let i = 192; i <= 215; i++) {
      jump2[i] = decodeTagCompact2;
    }
    jump2[216] = decodeTag82;
    jump2[217] = decodeTag162;
    jump2[218] = decodeTag322;
    jump2[219] = decodeTag642;
    jump2[220] = invalidMinor2;
    jump2[221] = invalidMinor2;
    jump2[222] = invalidMinor2;
    jump2[223] = invalidMinor2;
    for (let i = 224; i <= 243; i++) {
      jump2[i] = errorer2("simple values are not supported");
    }
    jump2[244] = invalidMinor2;
    jump2[245] = invalidMinor2;
    jump2[246] = invalidMinor2;
    jump2[247] = decodeUndefined2;
    jump2[248] = errorer2("simple values are not supported");
    jump2[249] = decodeFloat162;
    jump2[250] = decodeFloat322;
    jump2[251] = decodeFloat642;
    jump2[252] = invalidMinor2;
    jump2[253] = invalidMinor2;
    jump2[254] = invalidMinor2;
    jump2[255] = decodeBreak2;
    quick2 = [];
    for (let i = 0; i < 24; i++) {
      quick2[i] = new Token2(Type2.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick2[31 - i] = new Token2(Type2.negint, i, 1);
    }
    quick2[64] = new Token2(Type2.bytes, new Uint8Array(0), 1);
    quick2[96] = new Token2(Type2.string, "", 1);
    quick2[128] = new Token2(Type2.array, 0, 1);
    quick2[160] = new Token2(Type2.map, 0, 1);
    quick2[244] = new Token2(Type2.false, false, 1);
    quick2[245] = new Token2(Type2.true, true, 1);
    quick2[246] = new Token2(Type2.null, null, 1);
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/encode.js
function makeCborEncoders2() {
  const encoders = [];
  encoders[Type2.uint.major] = encodeUint2;
  encoders[Type2.negint.major] = encodeNegint2;
  encoders[Type2.bytes.major] = encodeBytes2;
  encoders[Type2.string.major] = encodeString2;
  encoders[Type2.array.major] = encodeArray2;
  encoders[Type2.map.major] = encodeMap2;
  encoders[Type2.tag.major] = encodeTag2;
  encoders[Type2.float.major] = encodeFloat2;
  return encoders;
}
function objectToTokens2(obj, options = {}, refStack) {
  const typ = is2(obj);
  const customTypeEncoder = options && options.typeEncoders && /** @type {OptionalTypeEncoder} */
  options.typeEncoders[typ] || typeEncoders2[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders2[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix2} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries2(entries4, options) {
  if (options.mapSorter) {
    entries4.sort(options.mapSorter);
  }
}
function mapSorter2(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders2[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function rfc8949MapSorter2(e1, e2) {
  if (e1[0] instanceof Token2 && e2[0] instanceof Token2) {
    const t1 = (
      /** @type {TokenEx} */
      e1[0]
    );
    const t2 = (
      /** @type {TokenEx} */
      e2[0]
    );
    if (!t1._keyBytes) {
      t1._keyBytes = encodeRfc89492(t1.value);
    }
    if (!t2._keyBytes) {
      t2._keyBytes = encodeRfc89492(t2.value);
    }
    return compare2(t1._keyBytes, t2._keyBytes);
  }
  throw new Error("rfc8949MapSorter: complex key types are not supported yet");
}
function encodeRfc89492(data) {
  return encodeCustom2(data, cborEncoders2, rfc8949EncodeOptions2);
}
function tokensToEncoded2(buf3, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded2(buf3, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf3, tokens, options);
  }
}
function encodeCustom2(data, encoders, options) {
  const tokens = objectToTokens2(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize) {
      const size = encoder2.encodedSize(tokens, options);
      const buf3 = new Bl2(size);
      encoder2(buf3, tokens, options);
      if (buf3.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A2(buf3.chunks[0]);
    }
  }
  buf2.reset();
  tokensToEncoded2(buf2, tokens, encoders, options);
  return buf2.toBytes(true);
}
function encode10(data, options) {
  options = Object.assign({}, defaultEncodeOptions2, options);
  return encodeCustom2(data, cborEncoders2, options);
}
var defaultEncodeOptions2, rfc8949EncodeOptions2, cborEncoders2, buf2, Ref2, simpleTokens2, typeEncoders2;
var init_encode2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/encode.js"() {
    init_is3();
    init_token2();
    init_bl2();
    init_common2();
    init_jump2();
    init_byte_utils2();
    init_uint2();
    init_negint2();
    init_bytes3();
    init_string3();
    init_array2();
    init_map3();
    init_tag2();
    init_float4();
    defaultEncodeOptions2 = {
      float64: false,
      mapSorter: mapSorter2,
      quickEncodeToken: quickEncodeToken2
    };
    rfc8949EncodeOptions2 = Object.freeze({
      float64: true,
      mapSorter: rfc8949MapSorter2,
      quickEncodeToken: quickEncodeToken2
    });
    cborEncoders2 = makeCborEncoders2();
    buf2 = new Bl2();
    Ref2 = class _Ref {
      /**
       * @param {object|any[]} obj
       * @param {Reference|undefined} parent
       */
      constructor(obj, parent) {
        this.obj = obj;
        this.parent = parent;
      }
      /**
       * @param {object|any[]} obj
       * @returns {boolean}
       */
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      /**
       * @param {Reference|undefined} stack
       * @param {object|any[]} obj
       * @returns {Reference}
       */
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix2} object contains circular references`);
        }
        return new _Ref(obj, stack);
      }
    };
    simpleTokens2 = {
      null: new Token2(Type2.null, null),
      undefined: new Token2(Type2.undefined, void 0),
      true: new Token2(Type2.true, true),
      false: new Token2(Type2.false, false),
      emptyArray: new Token2(Type2.array, 0),
      emptyMap: new Token2(Type2.map, 0)
    };
    typeEncoders2 = {
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token2(Type2.float, obj);
        } else if (obj >= 0) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token2(Type2.uint, obj);
        } else {
          return new Token2(Type2.negint, obj);
        }
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      string(obj, _typ, _options, _refStack) {
        return new Token2(Type2.string, obj);
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens2.true : simpleTokens2.false;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens2.null;
      },
      /**
       * @param {any} _obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens2.undefined;
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} _options
       * @param {Reference} [_refStack]
       * @returns {TokenOrNestedTokens}
       */
      DataView(obj, _typ, _options, _refStack) {
        return new Token2(Type2.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      /**
       * @param {any} obj
       * @param {string} _typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [simpleTokens2.emptyArray, new Token2(Type2.break)];
          }
          return simpleTokens2.emptyArray;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries4 = [];
        let i = 0;
        for (const e of obj) {
          entries4[i++] = objectToTokens2(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [new Token2(Type2.array, obj.length), entries4, new Token2(Type2.break)];
        }
        return [new Token2(Type2.array, obj.length), entries4];
      },
      /**
       * @param {any} obj
       * @param {string} typ
       * @param {EncodeOptions} options
       * @param {Reference} [refStack]
       * @returns {TokenOrNestedTokens}
       */
      Object(obj, typ, options, refStack) {
        const isMap2 = typ !== "Object";
        const keys = isMap2 ? obj.keys() : Object.keys(obj);
        const length2 = isMap2 ? obj.size : keys.length;
        if (!length2) {
          if (options.addBreakTokens === true) {
            return [simpleTokens2.emptyMap, new Token2(Type2.break)];
          }
          return simpleTokens2.emptyMap;
        }
        refStack = Ref2.createCheck(refStack, obj);
        const entries4 = [];
        let i = 0;
        for (const key of keys) {
          entries4[i++] = [
            objectToTokens2(key, options, refStack),
            objectToTokens2(isMap2 ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries2(entries4, options);
        if (options.addBreakTokens) {
          return [new Token2(Type2.map, length2), entries4, new Token2(Type2.break)];
        }
        return [new Token2(Type2.map, length2), entries4];
      }
    };
    typeEncoders2.Map = typeEncoders2.Object;
    typeEncoders2.Buffer = typeEncoders2.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders2[`${typ}Array`] = typeEncoders2.DataView;
    }
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/decode.js
function tokenToArray2(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject2(tokeniser, options);
    if (value === BREAK4) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed array`);
    }
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap2(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject2(tokeniser, options);
    if (key === BREAK4) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix2} got unexpected break to lengthed map`);
    }
    if (key === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix2} non-string keys not supported (got ${typeof key})`);
    }
    if (options.rejectDuplicateMapKeys === true) {
      if (useMaps && m.has(key) || !useMaps && key in obj) {
        throw new Error(`${decodeErrPrefix2} found repeat map key "${key}"`);
      }
    }
    const value = tokensToObject2(tokeniser, options);
    if (value === DONE2) {
      throw new Error(`${decodeErrPrefix2} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject2(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE2;
  }
  const token = tokeniser.next();
  if (token.type === Type2.break) {
    return BREAK4;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type2.array) {
    return tokenToArray2(token, tokeniser, options);
  }
  if (token.type === Type2.map) {
    return tokenToMap2(token, tokeniser, options);
  }
  if (token.type === Type2.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject2(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix2} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decodeFirst2(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix2} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions2, options);
  const tokeniser = options.tokenizer || new Tokeniser2(data, options);
  const decoded = tokensToObject2(tokeniser, options);
  if (decoded === DONE2) {
    throw new Error(`${decodeErrPrefix2} did not find any content to decode`);
  }
  if (decoded === BREAK4) {
    throw new Error(`${decodeErrPrefix2} got unexpected break`);
  }
  return [decoded, data.subarray(tokeniser.pos())];
}
function decode11(data, options) {
  const [decoded, remainder] = decodeFirst2(data, options);
  if (remainder.length > 0) {
    throw new Error(`${decodeErrPrefix2} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions2, Tokeniser2, DONE2, BREAK4;
var init_decode2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/decode.js"() {
    init_common2();
    init_token2();
    init_jump2();
    defaultDecodeOptions2 = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser2 = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
      }
      pos() {
        return this._pos;
      }
      done() {
        return this._pos >= this.data.length;
      }
      next() {
        const byt = this.data[this._pos];
        let token = quick2[byt];
        if (token === void 0) {
          const decoder2 = jump2[byt];
          if (!decoder2) {
            throw new Error(`${decodeErrPrefix2} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder2(this.data, this._pos, minor, this.options);
        }
        this._pos += token.encodedLength;
        return token;
      }
    };
    DONE2 = /* @__PURE__ */ Symbol.for("DONE");
    BREAK4 = /* @__PURE__ */ Symbol.for("BREAK");
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/cborg.js
var init_cborg2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/cborg.js"() {
    init_encode2();
    init_decode2();
    init_token2();
  }
});

// node_modules/.pnpm/@ipld+dag-cbor@9.2.5/node_modules/@ipld/dag-cbor/src/index.js
var src_exports = {};
__export(src_exports, {
  code: () => code3,
  decode: () => decode12,
  decodeOptions: () => decodeOptions,
  encode: () => encode11,
  encodeOptions: () => encodeOptions,
  name: () => name,
  toByteView: () => toByteView
});
function toByteView(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
function cidEncoder(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes = new Uint8Array(cid.bytes.byteLength + 1);
  bytes.set(cid.bytes, 1);
  return [
    new Token2(Type2.tag, CID_CBOR_TAG),
    new Token2(Type2.bytes, bytes)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function mapEncoder(map3) {
  for (const key of map3.keys()) {
    if (typeof key !== "string" || key.length === 0) {
      throw new Error("Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded");
    }
  }
  return null;
}
function cidDecoder(bytes) {
  if (bytes[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes.subarray(1));
}
var CID_CBOR_TAG, _encodeOptions, encodeOptions, _decodeOptions, decodeOptions, name, code3, encode11, decode12;
var init_src2 = __esm({
  "node_modules/.pnpm/@ipld+dag-cbor@9.2.5/node_modules/@ipld/dag-cbor/src/index.js"() {
    init_cborg2();
    init_cid();
    CID_CBOR_TAG = 42;
    _encodeOptions = {
      float64: true,
      typeEncoders: {
        Map: mapEncoder,
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
      }
    };
    encodeOptions = {
      ..._encodeOptions,
      typeEncoders: {
        ..._encodeOptions.typeEncoders
      }
    };
    _decodeOptions = {
      allowIndefinite: false,
      coerceUndefinedToNull: true,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    _decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
    decodeOptions = {
      ..._decodeOptions,
      tags: _decodeOptions.tags.slice()
    };
    name = "dag-cbor";
    code3 = 113;
    encode11 = (node) => encode10(node, _encodeOptions);
    decode12 = (data) => decode11(toByteView(data), _decodeOptions);
  }
});

// node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js
var require_number = __commonJS({
  "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js"(exports) {
    exports.encode = function(number4) {
      if (isNaN(number4)) {
        return "DaN";
      }
      if (number4 === 0) {
        return "FE  0M0";
      }
      if (number4 === Infinity) {
        return "FF";
      }
      if (number4 === -Infinity) {
        return "DD";
      }
      var splitScientificNotation = number4.toExponential().split("e");
      var exponent = Number(splitScientificNotation[1]) + 500;
      var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf(".") === -1 ? "." : "") + "0".repeat(20);
      var encoded = "E" + padStart(String(exponent), 3) + "M" + String(mantissa);
      if (number4 > 0) {
        return "F" + encoded;
      } else {
        return "D" + flip(encoded);
      }
    };
    exports.decode = function(encoded) {
      if (encoded === "DaN") {
        return NaN;
      }
      if (encoded === "FF") {
        return Infinity;
      }
      if (encoded === "DD") {
        return -Infinity;
      }
      var isNegative = encoded[0] === "D";
      var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split("M");
      return Number((isNegative ? "-" : "") + splitEncoded[1] + "e" + String(Number(splitEncoded[0]) - 500));
    };
    function flip(number4) {
      var flipped = "";
      for (var i = 0; i < number4.length; i++) {
        var digit = number4[i];
        if (isNaN(Number(digit)) || digit === " ") {
          if (digit !== "-") {
            flipped += digit;
          }
        } else {
          flipped += String(9 - Number(digit));
        }
      }
      return flipped;
    }
    function padStart(str, count) {
      return " ".repeat(count - str.length).substr(0, count) + str;
    }
  }
});

// node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js
var require_object = __commonJS({
  "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js"(exports) {
    var dictEscape = { "?": "?@", "!": "??", '"': "?%" };
    function escape(str) {
      if (!/[!"]/.test(str)) {
        return str;
      }
      return str.replace(/[\?!"]/g, function(match2) {
        return dictEscape[match2];
      });
    }
    var dictUnescape = { "?@": "?", "??": "!", "?%": '"' };
    function unescape(str) {
      if (!/\?[%\?@]/.test(str)) {
        return str;
      }
      return str.replace(/\?[%\?@]/g, function(match2) {
        return dictUnescape[match2];
      });
    }
    exports.factory = function(codec2) {
      return {
        encode: encode14,
        decode: decode15
      };
      function encode14(array2) {
        if (array2 === null) {
          return "A";
        }
        if (!Array.isArray(array2)) {
          throw new Error("can only encode arrays");
        }
        var l = array2.length;
        if (l == 0) {
          return "K!";
        }
        var s = encodeItem(array2[0]);
        for (var i = 1; i < l; i++) {
          s += '"' + encodeItem(array2[i]);
        }
        return "K" + s + "!";
      }
      function encodeItem(item) {
        if (typeof item === "object") {
          return encode14(item);
        }
        return escape(codec2.encode(item));
      }
      function decode15(encoded) {
        if (encoded === "A") {
          return null;
        }
        if (encoded === "K!") {
          return [];
        }
        var items = encoded.split('"');
        var pointers = [[]];
        var array2;
        var depth = 0;
        var l = items.length;
        for (var i = 0; i < l; i++) {
          var item = items[i];
          var itemLength = item.length;
          var open = 0;
          while (item[open] == "K") {
            open++;
          }
          var close2 = 0;
          while (item[itemLength - close2 - 1] == "!") {
            close2++;
          }
          var content = item.slice(open, itemLength - close2);
          var newdepth = depth + open;
          for (var j = depth; j < newdepth; j++) {
            pointers[j + 1] = [];
            pointers[j].push(pointers[j + 1]);
            depth = newdepth;
            array2 = pointers[depth];
          }
          if (content.length !== 0) {
            array2.push(codec2.decode(unescape(content)));
          }
          var newdepth = depth - close2;
          for (var j = newdepth; j < depth; j++) {
            pointers[j + 1] = [];
            depth = newdepth;
            array2 = pointers[depth];
          }
        }
        return pointers[0][0];
      }
    };
  }
});

// node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js
var require_charwise = __commonJS({
  "node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js"(exports) {
    var number4 = require_number();
    var object2 = require_object();
    var flip = exports.flip = function(n) {
      var s = n.toString();
      var f = "";
      for (var i in s) {
        f += s[i] == "." ? "." : 9 - +s[i];
      }
      return f;
    };
    exports.number = number4;
    exports.string = {
      encode: function(s) {
        if (!/\x00|\x01/.test(s))
          return "J" + s;
        else {
          return "J" + s.replace(/\x01/g, "").replace(/\x00/g, "");
        }
      },
      decode: function(s) {
        if ("J" === s[0])
          return s.substring(1);
      }
    };
    exports.encode = function(t) {
      return exports[typeof t].encode(t);
    };
    exports.decode = function(s) {
      if (s === "") return s;
      if (!decoders[s[0]])
        throw new Error("no decoder for:" + JSON.stringify(s));
      return decoders[s[0]](s);
    };
    exports.object = object2.factory(exports);
    exports.boolean = {
      encode: function(b) {
        return b ? "C" : "B";
      },
      decode: function(b) {
        return "C" === b;
      }
    };
    exports.undefined = {
      encode: function(b) {
        return "L";
      },
      decode: function() {
        return void 0;
      }
    };
    var decoders = {
      A: exports.object.decode,
      //null
      B: exports.boolean.decode,
      // false
      C: exports.boolean.decode,
      // true
      D: exports.number.decode,
      // number
      F: exports.number.decode,
      // number
      // G Date
      // H Date
      // I Buffer
      J: exports.string.decode,
      // String
      K: exports.object.decode,
      // Array
      L: exports.undefined.decode
      // undefined
    };
    exports.buffer = false;
    exports.type = "charwise";
  }
});

// core/types/blockstore/commit-queue-if.ts
var init_commit_queue_if = __esm({
  "core/types/blockstore/commit-queue-if.ts"() {
    "use strict";
  }
});

// core/types/blockstore/fp-envelope-serialize.ts
var init_fp_envelope_serialize = __esm({
  "core/types/blockstore/fp-envelope-serialize.ts"() {
    "use strict";
  }
});

// core/types/blockstore/fp-envelope.ts
function Car2FPMsg(fpcar) {
  return Result.Ok({ type: FPEnvelopeTypes.CAR, payload: fpcar });
}
function File2FPMsg(fpfile) {
  return Result.Ok({ type: FPEnvelopeTypes.FILE, payload: fpfile });
}
var FPEnvelopeTypes;
var init_fp_envelope = __esm({
  "core/types/blockstore/fp-envelope.ts"() {
    "use strict";
    init_esm();
    FPEnvelopeTypes = {
      CAR: "car",
      FILE: "file",
      META: "meta",
      WAL: "wal"
    };
  }
});

// core/types/blockstore/serde-gateway.ts
var init_serde_gateway = __esm({
  "core/types/blockstore/serde-gateway.ts"() {
    "use strict";
  }
});

// core/types/blockstore/task-manager-if.ts
var init_task_manager_if = __esm({
  "core/types/blockstore/task-manager-if.ts"() {
    "use strict";
  }
});

// core/types/blockstore/types.ts
function isFPBlockItem(fpb) {
  return fpb.item.type === "fp";
}
function isCarBlockItemReady(ifp) {
  const fp = ifp;
  return fp.item && fp.item.type === "car" && fp.item.status === "ready";
}
function isCarBlockItemStale(ifp) {
  const fp = ifp;
  return fp.item && fp.item.type === "car" && fp.item.status === "stale";
}
var CarLog, BaseActiveStore, CarActiveStore, FileActiveStore, MetaActiveStore, WALActiveStore;
var init_types4 = __esm({
  "core/types/blockstore/types.ts"() {
    "use strict";
    CarLog = class {
      _logs = [];
      get length() {
        return this._logs.length;
      }
      last() {
        const x = [...this._logs[this._logs.length - 1]];
        Object.freeze(x);
        return x;
      }
      unshift(logs) {
        this._logs.unshift(logs);
      }
      update(logs) {
        this._logs.length = 0;
        this._logs.push(...logs);
      }
      asArray() {
        const a = [
          ...this._logs.map((l) => {
            const x = [...l];
            Object.freeze(x);
            return x;
          })
        ];
        Object.freeze(a);
        return a;
      }
    };
    BaseActiveStore = class {
    };
    CarActiveStore = class extends BaseActiveStore {
    };
    FileActiveStore = class extends BaseActiveStore {
    };
    MetaActiveStore = class extends BaseActiveStore {
    };
    WALActiveStore = class extends BaseActiveStore {
    };
  }
});

// core/types/blockstore/gateway.ts
var init_gateway = __esm({
  "core/types/blockstore/gateway.ts"() {
    "use strict";
  }
});

// core/types/blockstore/index.ts
var init_blockstore = __esm({
  "core/types/blockstore/index.ts"() {
    "use strict";
    init_commit_queue_if();
    init_fp_envelope_serialize();
    init_fp_envelope();
    init_serde_gateway();
    init_task_manager_if();
    init_types4();
    init_gateway();
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js"(exports, module) {
    module.exports = encode14;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode14(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode14.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode14.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js"(exports, module) {
    module.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf3, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf3.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf3[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js"(exports, module) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js"(exports, module) {
    module.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// core/gateways/file-node/to-array-buffer.ts
function toArrayBuffer(buffer3) {
  if (typeof buffer3 === "string") {
    buffer3 = Buffer.from(buffer3);
  }
  const ab = new ArrayBuffer(buffer3.length);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buffer3.length; ++i) {
    view[i] = buffer3[i];
  }
  return view;
}
var init_to_array_buffer = __esm({
  "core/gateways/file-node/to-array-buffer.ts"() {
    "use strict";
  }
});

// core/gateways/file-node/node-filesystem.ts
var NodeFileSystem;
var init_node_filesystem = __esm({
  "core/gateways/file-node/node-filesystem.ts"() {
    "use strict";
    init_to_array_buffer();
    NodeFileSystem = class {
      fs;
      async start() {
        this.fs = await import("node:fs/promises");
        return this;
      }
      async mkdir(path, options) {
        return this.fs?.mkdir(path, options);
      }
      async readdir(path, options) {
        return this.fs?.readdir(path, options);
      }
      async rm(path, options) {
        return this.fs?.rm(path, options);
      }
      async copyFile(source, destination) {
        return this.fs?.copyFile(source, destination);
      }
      async readfile(path, options) {
        const ret = await this.fs?.readFile(path, options);
        return toArrayBuffer(ret);
      }
      stat(path) {
        return this.fs?.stat(path);
      }
      async unlink(path) {
        return this.fs?.unlink(path);
      }
      async writefile(path, data) {
        return this.fs?.writeFile(path, data);
      }
    };
  }
});

// core/gateways/file-node/get-sys-file-system.ts
async function getSysFileSystem(url2) {
  return nfs.once(async () => {
    const nfs3 = new NodeFileSystem();
    await nfs3.start();
    return nfs3;
  });
}
var nfs;
var init_get_sys_file_system = __esm({
  "core/gateways/file-node/get-sys-file-system.ts"() {
    "use strict";
    init_node_filesystem();
    init_esm();
    nfs = new ResolveOnce();
  }
});

// core/gateways/file-node/index.ts
var file_node_exports = {};
__export(file_node_exports, {
  getSysFileSystem: () => getSysFileSystem
});
var init_file_node = __esm({
  "core/gateways/file-node/index.ts"() {
    "use strict";
    init_get_sys_file_system();
  }
});

// core/gateways/file-deno/deno-filesystem.ts
var DenoFileSystem;
var init_deno_filesystem = __esm({
  "core/gateways/file-deno/deno-filesystem.ts"() {
    "use strict";
    init_esm();
    DenoFileSystem = class {
      fs;
      async start() {
        this.fs = Deno;
        return this;
      }
      async mkdir(path, options) {
        return this.fs?.mkdir(path, options).then(() => path);
      }
      async readdir(path) {
        const ret = [];
        for await (const dirEntry of this.fs.readDir(path)) {
          ret.push(dirEntry.name);
        }
        return ret;
      }
      async rm(path, options) {
        return this.fs?.rm(path, options);
      }
      async copyFile(source, destination) {
        return this.fs?.copyFile(source, destination);
      }
      async readfile(path) {
        return this.fs.readFile(path);
      }
      async stat(path) {
        const x = await this.fs.stat(path);
        return {
          isFile: () => x.isFile,
          isDirectory: () => x.isDirectory,
          isBlockDevice: () => !!x.isBlockDevice,
          isCharacterDevice: () => !!x.isCharDevice,
          isSymbolicLink: () => x.isSymlink,
          isFIFO: () => !!x.isFifo,
          isSocket: () => !!x.isSocket,
          uid: x.uid,
          gid: x.gid,
          size: x.size,
          atime: x.atime,
          mtime: x.mtime,
          ctime: x.birthtime,
          birthtime: x.birthtime
        };
      }
      async unlink(path) {
        return this.fs?.remove(path);
      }
      async writefile(path, data) {
        return this.fs?.writeFile(path, to_uint8(data));
      }
    };
  }
});

// core/gateways/file-deno/get-sys-file-system.ts
async function getSysFileSystem2(url2) {
  return nfs2.once(async () => {
    const nfs3 = new DenoFileSystem();
    await nfs3.start();
    return nfs3;
  });
}
var nfs2;
var init_get_sys_file_system2 = __esm({
  "core/gateways/file-deno/get-sys-file-system.ts"() {
    "use strict";
    init_deno_filesystem();
    init_esm();
    nfs2 = new ResolveOnce();
  }
});

// core/gateways/file-deno/index.ts
var file_deno_exports = {};
__export(file_deno_exports, {
  getSysFileSystem: () => getSysFileSystem2
});
var init_file_deno = __esm({
  "core/gateways/file-deno/index.ts"() {
    "use strict";
    init_get_sys_file_system2();
  }
});

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/clock/api.js
var init_api2 = __esm({
  "node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/clock/api.js"() {
  }
});

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/clock/index.js
var advance, EventBlock, EventFetcher, encodeEventBlock, compareBytes3, decodeEventBlock, contains, vis, shortLink;
var init_clock = __esm({
  "node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/clock/index.js"() {
    init_block();
    init_sha2_browser();
    init_src2();
    init_api2();
    advance = async (blocks, head, event) => {
      const events = new EventFetcher(blocks);
      const headmap = new Map(head.map((cid) => [cid.toString(), cid]));
      if (headmap.has(event.toString()))
        return head;
      let changed = false;
      for (const cid of head) {
        if (await contains(events, event, cid)) {
          headmap.delete(cid.toString());
          headmap.set(event.toString(), event);
          changed = true;
        }
      }
      if (changed) {
        return [...headmap.values()];
      }
      for (const p of head) {
        if (await contains(events, p, event)) {
          return head;
        }
      }
      return head.concat(event);
    };
    EventBlock = class extends Block {
      /**
       * @param {object} config
       * @param {API.EventLink<T>} config.cid
       * @param {Event} config.value
       * @param {Uint8Array} config.bytes
       * @param {string} config.prefix
       */
      constructor({ cid, value, bytes, prefix }) {
        super({ cid, value, bytes });
        this.prefix = prefix;
      }
      /**
       * @template T
       * @param {T} data
       * @param {API.EventLink<T>[]} [parents]
       */
      static create(data, parents) {
        return encodeEventBlock({ data, parents: parents ?? [] });
      }
    };
    EventFetcher = class {
      /** @param {API.BlockFetcher} blocks */
      constructor(blocks) {
        this._blocks = blocks;
      }
      /**
       * @param {API.EventLink<T>} link
       * @returns {Promise<API.EventBlockView<T>>}
       */
      async get(link) {
        const block = await this._blocks.get(link);
        if (!block)
          throw new Error(`missing block: ${link}`);
        return decodeEventBlock(block.bytes);
      }
    };
    encodeEventBlock = async (value) => {
      if (typeof value.data === "undefined" || !Array.isArray(value.parents)) {
        throw new Error("invalid event block structure");
      }
      const { data } = value;
      const parents = [...value.parents].sort((a, b) => compareBytes3(a.bytes, b.bytes));
      const { cid, bytes } = await encode8({ value: { data, parents }, codec: src_exports, hasher: sha256 });
      return new Block({ cid, value, bytes });
    };
    compareBytes3 = (a, b) => {
      for (let i = 0; i < a.byteLength; i++) {
        if (a[i] < b[i])
          return -1;
        if (a[i] > b[i])
          return 1;
      }
      if (a.byteLength > b.byteLength)
        return 1;
      if (a.byteLength < b.byteLength)
        return -1;
      return 0;
    };
    decodeEventBlock = async (bytes) => {
      const { cid, value } = await decode9({ bytes, codec: src_exports, hasher: sha256 });
      return new Block({ cid, value, bytes });
    };
    contains = async (events, a, b) => {
      if (a.toString() === b.toString())
        return true;
      const [{ value: aevent }, { value: bevent }] = await Promise.all([events.get(a), events.get(b)]);
      const links2 = [...aevent.parents];
      const seen = /* @__PURE__ */ new Set();
      while (links2.length) {
        const link = links2.shift();
        if (!link)
          break;
        if (link.toString() === b.toString())
          return true;
        if (bevent.parents.some((p) => link.toString() === p.toString()))
          continue;
        if (seen.has(link.toString()))
          continue;
        seen.add(link.toString());
        const { value: event } = await events.get(link);
        links2.push(...event.parents);
      }
      return false;
    };
    vis = async function* (blocks, head, options = {}) {
      const renderNodeLabel = options.renderNodeLabel ?? ((b) => shortLink(b.cid));
      const events = new EventFetcher(blocks);
      yield "digraph clock {";
      yield '  node [shape=point fontname="Courier"]; head;';
      const hevents = await Promise.all(head.map((link) => events.get(link)));
      const links2 = [];
      const nodes = /* @__PURE__ */ new Set();
      for (const e of hevents) {
        nodes.add(e.cid.toString());
        yield `  node [shape=oval fontname="Courier"]; ${e.cid} [label="${renderNodeLabel(e)}"];`;
        yield `  head -> ${e.cid};`;
        for (const p of e.value.parents) {
          yield `  ${e.cid} -> ${p};`;
        }
        links2.push(...e.value.parents);
      }
      while (links2.length) {
        const link = links2.shift();
        if (!link)
          break;
        if (nodes.has(link.toString()))
          continue;
        nodes.add(link.toString());
        const block = await events.get(link);
        yield `  node [shape=oval]; ${link} [label="${renderNodeLabel(block)}" fontname="Courier"];`;
        for (const p of block.value.parents) {
          yield `  ${link} -> ${p};`;
        }
        links2.push(...block.value.parents);
      }
      yield "}";
    };
    shortLink = (l) => `${String(l).slice(0, 4)}..${String(l).slice(-4)}`;
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base64.js
var base643, base64pad, base64url3, base64urlpad;
var init_base642 = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/bases/base64.js"() {
    init_base();
    base643 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url3 = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/link.js
function isLink(value) {
  if (value == null) {
    return false;
  }
  const withSlash = value;
  if (withSlash["/"] != null && withSlash["/"] === withSlash.bytes) {
    return true;
  }
  const withAsCID = value;
  if (withAsCID.asCID === value) {
    return true;
  }
  return false;
}
function parse4(source, base2) {
  return CID.parse(source, base2);
}
var init_link = __esm({
  "node_modules/.pnpm/multiformats@13.4.2/node_modules/multiformats/dist/src/link.js"() {
    init_cid();
    init_interface();
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/encode.js
function mapSorter3(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix2} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type2.string || keyToken2.type !== Type2.string) {
    throw new Error(`${encodeErrPrefix2} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix2} unexpected duplicate map keys, this is not supported`);
}
function encode12(data, options) {
  options = Object.assign({}, defaultEncodeOptions3, options);
  return encodeCustom2(data, new JSONEncoder(), options);
}
var JSONEncoder, defaultEncodeOptions3;
var init_encode3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/encode.js"() {
    init_token2();
    init_encode2();
    init_common2();
    init_byte_utils2();
    JSONEncoder = class extends Array {
      constructor() {
        super();
        this.inRecursive = [];
      }
      /**
       * @param {Bl} buf
       */
      prefix(buf3) {
        const recurs = this.inRecursive[this.inRecursive.length - 1];
        if (recurs) {
          if (recurs.type === Type2.array) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              buf3.push([44]);
            }
          }
          if (recurs.type === Type2.map) {
            recurs.elements++;
            if (recurs.elements !== 1) {
              if (recurs.elements % 2 === 1) {
                buf3.push([44]);
              } else {
                buf3.push([58]);
              }
            }
          }
        }
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.uint.major](buf3, token) {
        this.prefix(buf3);
        const is3 = String(token.value);
        const isa = [];
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
        }
        buf3.push(isa);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.negint.major](buf3, token) {
        this[Type2.uint.major](buf3, token);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type2.bytes.major](_buf, _token) {
        throw new Error(`${encodeErrPrefix2} unsupported type: Uint8Array`);
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.string.major](buf3, token) {
        this.prefix(buf3);
        const byts = fromString3(JSON.stringify(token.value));
        buf3.push(byts.length > 32 ? asU8A2(byts) : byts);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type2.array.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({ type: Type2.array, elements: 0 });
        buf3.push([91]);
      }
      /**
       * @param {Bl} buf
       * @param {Token} _token
       */
      [Type2.map.major](buf3, _token) {
        this.prefix(buf3);
        this.inRecursive.push({ type: Type2.map, elements: 0 });
        buf3.push([123]);
      }
      /**
       * @param {Bl} _buf
       * @param {Token} _token
       */
      [Type2.tag.major](_buf, _token) {
      }
      /**
       * @param {Bl} buf
       * @param {Token} token
       */
      [Type2.float.major](buf3, token) {
        if (token.type.name === "break") {
          const recurs = this.inRecursive.pop();
          if (recurs) {
            if (recurs.type === Type2.array) {
              buf3.push([93]);
            } else if (recurs.type === Type2.map) {
              buf3.push([125]);
            } else {
              throw new Error("Unexpected recursive type; this should not happen!");
            }
            return;
          }
          throw new Error("Unexpected break; this should not happen!");
        }
        if (token.value === void 0) {
          throw new Error(`${encodeErrPrefix2} unsupported type: undefined`);
        }
        this.prefix(buf3);
        if (token.type.name === "true") {
          buf3.push([116, 114, 117, 101]);
          return;
        } else if (token.type.name === "false") {
          buf3.push([102, 97, 108, 115, 101]);
          return;
        } else if (token.type.name === "null") {
          buf3.push([110, 117, 108, 108]);
          return;
        }
        const is3 = String(token.value);
        const isa = [];
        let dp = false;
        for (let i = 0; i < is3.length; i++) {
          isa[i] = is3.charCodeAt(i);
          if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {
            dp = true;
          }
        }
        if (!dp) {
          isa.push(46);
          isa.push(48);
        }
        buf3.push(isa);
      }
    };
    defaultEncodeOptions3 = { addBreakTokens: true, mapSorter: mapSorter3 };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/decode.js
function decode13(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode11(data, options);
}
var Tokenizer;
var init_decode3 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/decode.js"() {
    init_decode2();
    init_token2();
    init_byte_utils2();
    init_common2();
    Tokenizer = class {
      /**
       * @param {Uint8Array} data
       * @param {DecodeOptions} options
       */
      constructor(data, options = {}) {
        this._pos = 0;
        this.data = data;
        this.options = options;
        this.modeStack = ["value"];
        this.lastToken = "";
      }
      pos() {
        return this._pos;
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this._pos >= this.data.length;
      }
      /**
       * @returns {number}
       */
      ch() {
        return this.data[this._pos];
      }
      /**
       * @returns {string}
       */
      currentMode() {
        return this.modeStack[this.modeStack.length - 1];
      }
      skipWhitespace() {
        let c = this.ch();
        while (c === 32 || c === 9 || c === 13 || c === 10) {
          c = this.data[++this._pos];
        }
      }
      /**
       * @param {number[]} str
       */
      expect(str) {
        if (this.data.length - this._pos < str.length) {
          throw new Error(`${decodeErrPrefix2} unexpected end of input at position ${this._pos}`);
        }
        for (let i = 0; i < str.length; i++) {
          if (this.data[this._pos++] !== str[i]) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`);
          }
        }
      }
      parseNumber() {
        const startPos = this._pos;
        let negative = false;
        let float3 = false;
        const swallow = (chars) => {
          while (!this.done()) {
            const ch = this.ch();
            if (chars.includes(ch)) {
              this._pos++;
            } else {
              break;
            }
          }
        };
        if (this.ch() === 45) {
          negative = true;
          this._pos++;
        }
        if (this.ch() === 48) {
          this._pos++;
          if (this.ch() === 46) {
            this._pos++;
            float3 = true;
          } else {
            return new Token2(Type2.uint, 0, this._pos - startPos);
          }
        }
        swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        if (negative && this._pos === startPos + 1) {
          throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
        }
        if (!this.done() && this.ch() === 46) {
          if (float3) {
            throw new Error(`${decodeErrPrefix2} unexpected token at position ${this._pos}`);
          }
          float3 = true;
          this._pos++;
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
          float3 = true;
          this._pos++;
          if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
            this._pos++;
          }
          swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
        }
        const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos));
        const num = parseFloat(numStr);
        if (float3) {
          return new Token2(Type2.float, num, this._pos - startPos);
        }
        if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
          return new Token2(num >= 0 ? Type2.uint : Type2.negint, num, this._pos - startPos);
        }
        return new Token2(num >= 0 ? Type2.uint : Type2.negint, BigInt(numStr), this._pos - startPos);
      }
      /**
       * @returns {Token}
       */
      parseString() {
        if (this.ch() !== 34) {
          throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}; this shouldn't happen`);
        }
        this._pos++;
        for (let i = this._pos, l = 0; i < this.data.length && l < 65536; i++, l++) {
          const ch = this.data[i];
          if (ch === 92 || ch < 32 || ch >= 128) {
            break;
          }
          if (ch === 34) {
            const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i));
            this._pos = i + 1;
            return new Token2(Type2.string, str, l);
          }
        }
        const startPos = this._pos;
        const chars = [];
        const readu4 = () => {
          if (this._pos + 4 >= this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected end of unicode escape sequence at position ${this._pos}`);
          }
          let u4 = 0;
          for (let i = 0; i < 4; i++) {
            let ch = this.ch();
            if (ch >= 48 && ch <= 57) {
              ch -= 48;
            } else if (ch >= 97 && ch <= 102) {
              ch = ch - 97 + 10;
            } else if (ch >= 65 && ch <= 70) {
              ch = ch - 65 + 10;
            } else {
              throw new Error(`${decodeErrPrefix2} unexpected unicode escape character at position ${this._pos}`);
            }
            u4 = u4 * 16 + ch;
            this._pos++;
          }
          return u4;
        };
        const readUtf8Char = () => {
          const firstByte = this.ch();
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (this._pos + bytesPerSequence > this.data.length) {
            throw new Error(`${decodeErrPrefix2} unexpected unicode sequence at position ${this._pos}`);
          }
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            /* c8 ignore next 6 */
            // this case is dealt with by the caller function
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = this.data[this._pos + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = this.data[this._pos + 1];
              thirdByte = this.data[this._pos + 2];
              fourthByte = this.data[this._pos + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            chars.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          chars.push(codePoint);
          this._pos += bytesPerSequence;
        };
        while (!this.done()) {
          const ch = this.ch();
          let ch1;
          switch (ch) {
            case 92:
              this._pos++;
              if (this.done()) {
                throw new Error(`${decodeErrPrefix2} unexpected string termination at position ${this._pos}`);
              }
              ch1 = this.ch();
              this._pos++;
              switch (ch1) {
                case 34:
                // '"'
                case 39:
                // '\''
                case 92:
                // '\'
                case 47:
                  chars.push(ch1);
                  break;
                case 98:
                  chars.push(8);
                  break;
                case 116:
                  chars.push(9);
                  break;
                case 110:
                  chars.push(10);
                  break;
                case 102:
                  chars.push(12);
                  break;
                case 114:
                  chars.push(13);
                  break;
                case 117:
                  chars.push(readu4());
                  break;
                default:
                  throw new Error(`${decodeErrPrefix2} unexpected string escape character at position ${this._pos}`);
              }
              break;
            case 34:
              this._pos++;
              return new Token2(Type2.string, decodeCodePointsArray2(chars), this._pos - startPos);
            default:
              if (ch < 32) {
                throw new Error(`${decodeErrPrefix2} invalid control character at position ${this._pos}`);
              } else if (ch < 128) {
                chars.push(ch);
                this._pos++;
              } else {
                readUtf8Char();
              }
          }
        }
        throw new Error(`${decodeErrPrefix2} unexpected end of string at position ${this._pos}`);
      }
      /**
       * @returns {Token}
       */
      parseValue() {
        switch (this.ch()) {
          case 123:
            this.modeStack.push("obj-start");
            this._pos++;
            return new Token2(Type2.map, Infinity, 1);
          case 91:
            this.modeStack.push("array-start");
            this._pos++;
            return new Token2(Type2.array, Infinity, 1);
          case 34: {
            return this.parseString();
          }
          case 110:
            this.expect([110, 117, 108, 108]);
            return new Token2(Type2.null, null, 4);
          case 102:
            this.expect([102, 97, 108, 115, 101]);
            return new Token2(Type2.false, false, 5);
          case 116:
            this.expect([116, 114, 117, 101]);
            return new Token2(Type2.true, true, 4);
          case 45:
          // '-'
          case 48:
          // '0'
          case 49:
          // '1'
          case 50:
          // '2'
          case 51:
          // '3'
          case 52:
          // '4'
          case 53:
          // '5'
          case 54:
          // '6'
          case 55:
          // '7'
          case 56:
          // '8'
          case 57:
            return this.parseNumber();
          default:
            throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}`);
        }
      }
      /**
       * @returns {Token}
       */
      next() {
        this.skipWhitespace();
        switch (this.currentMode()) {
          case "value":
            this.modeStack.pop();
            return this.parseValue();
          case "array-value": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          case "array-start": {
            this.modeStack.pop();
            if (this.ch() === 93) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            this.modeStack.push("array-value");
            this.skipWhitespace();
            return this.parseValue();
          }
          // @ts-ignore
          case "obj-key":
            if (this.ch() === 125) {
              this.modeStack.pop();
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            if (this.ch() !== 44) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.skipWhitespace();
          case "obj-start": {
            this.modeStack.pop();
            if (this.ch() === 125) {
              this._pos++;
              this.skipWhitespace();
              return new Token2(Type2.break, void 0, 1);
            }
            const token = this.parseString();
            this.skipWhitespace();
            if (this.ch() !== 58) {
              throw new Error(`${decodeErrPrefix2} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
            }
            this._pos++;
            this.modeStack.push("obj-value");
            return token;
          }
          case "obj-value": {
            this.modeStack.pop();
            this.modeStack.push("obj-key");
            this.skipWhitespace();
            return this.parseValue();
          }
          /* c8 ignore next 2 */
          default:
            throw new Error(`${decodeErrPrefix2} unexpected parse state at position ${this._pos}; this shouldn't happen`);
        }
      }
    };
  }
});

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/json.js
var init_json2 = __esm({
  "node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/json/json.js"() {
    init_encode3();
    init_decode3();
  }
});

// node_modules/.pnpm/@ipld+dag-json@10.2.5/node_modules/@ipld/dag-json/src/index.js
function toByteView2(buf3) {
  if (buf3 instanceof ArrayBuffer) {
    return new Uint8Array(buf3, 0, buf3.byteLength);
  }
  return buf3;
}
function cidEncoder2(obj) {
  if (obj.asCID !== obj && obj["/"] !== obj.bytes) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    // key
    new Token2(Type2.string, cidString, cidString.length),
    // value
    new Token2(Type2.break, void 0, 1)
  ];
}
function bytesEncoder(bytes) {
  const bytesString = base643.encode(bytes).slice(1);
  return [
    new Token2(Type2.map, Infinity, 1),
    new Token2(Type2.string, "/", 1),
    // key
    new Token2(Type2.map, Infinity, 1),
    // value
    new Token2(Type2.string, "bytes", 5),
    // inner key
    new Token2(Type2.string, bytesString, bytesString.length),
    // inner value
    new Token2(Type2.break, void 0, 1),
    new Token2(Type2.break, void 0, 1)
  ];
}
function taBytesEncoder(obj) {
  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
function abBytesEncoder(ab) {
  return bytesEncoder(new Uint8Array(ab));
}
function undefinedEncoder2() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder2(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
var encodeOptions2, DagJsonTokenizer, decodeOptions2, encode13, decode14, format2, utf8Decoder, parse5, utf8Encoder;
var init_src3 = __esm({
  "node_modules/.pnpm/@ipld+dag-json@10.2.5/node_modules/@ipld/dag-json/src/index.js"() {
    init_cborg2();
    init_json2();
    init_src();
    init_base642();
    encodeOptions2 = {
      typeEncoders: {
        Object: cidEncoder2,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder2,
        number: numberEncoder2
      }
    };
    DagJsonTokenizer = class extends Tokenizer {
      /**
       * @param {Uint8Array} data
       * @param {object} [options]
       */
      constructor(data, options) {
        super(data, options);
        this.tokenBuffer = [];
      }
      /**
       * @returns {boolean}
       */
      done() {
        return this.tokenBuffer.length === 0 && super.done();
      }
      /**
       * @returns {Token}
       */
      _next() {
        if (this.tokenBuffer.length > 0) {
          return this.tokenBuffer.pop();
        }
        return super.next();
      }
      /**
       * Implements rules outlined in https://github.com/ipld/specs/pull/356
       *
       * @returns {Token}
       */
      next() {
        const token = this._next();
        if (token.type === Type2.map) {
          const keyToken = this._next();
          if (keyToken.type === Type2.string && keyToken.value === "/") {
            const valueToken = this._next();
            if (valueToken.type === Type2.string) {
              const breakToken = this._next();
              if (breakToken.type !== Type2.break) {
                throw new Error("Invalid encoded CID form");
              }
              this.tokenBuffer.push(valueToken);
              return new Token2(Type2.tag, 42, 0);
            }
            if (valueToken.type === Type2.map) {
              const innerKeyToken = this._next();
              if (innerKeyToken.type === Type2.string && innerKeyToken.value === "bytes") {
                const innerValueToken = this._next();
                if (innerValueToken.type === Type2.string) {
                  for (let i = 0; i < 2; i++) {
                    const breakToken = this._next();
                    if (breakToken.type !== Type2.break) {
                      throw new Error("Invalid encoded Bytes form");
                    }
                  }
                  const bytes = base643.decode(`m${innerValueToken.value}`);
                  return new Token2(Type2.bytes, bytes, innerValueToken.value.length);
                }
                this.tokenBuffer.push(innerValueToken);
              }
              this.tokenBuffer.push(innerKeyToken);
            }
            this.tokenBuffer.push(valueToken);
          }
          this.tokenBuffer.push(keyToken);
        }
        return token;
      }
    };
    decodeOptions2 = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      // this will lead to BigInt for ints outside of
      // safe-integer range, which may surprise users
      strict: true,
      useMaps: false,
      rejectDuplicateMapKeys: true,
      /** @type {import('cborg').TagDecoder[]} */
      tags: []
    };
    decodeOptions2.tags[42] = CID.parse;
    encode13 = (node) => encode12(node, encodeOptions2);
    decode14 = (data) => {
      const buf3 = toByteView2(data);
      const options = Object.assign(decodeOptions2, { tokenizer: new DagJsonTokenizer(buf3, decodeOptions2) });
      return decode13(buf3, options);
    };
    format2 = (node) => utf8Decoder.decode(encode13(node));
    utf8Decoder = new TextDecoder();
    parse5 = (data) => decode14(utf8Encoder.encode(data));
    utf8Encoder = new TextEncoder();
  }
});

// core/gateways/base/fp-envelope-serialize.ts
async function dbMetaEvent2Serialized(sthis, dbEvents) {
  return await Promise.all(
    dbEvents.map(async (dbEvent) => {
      const event = await EventBlock.create(
        {
          dbMeta: sthis.txt.encode(format2(dbEvent.dbMeta))
        },
        dbEvent.parents
      );
      return {
        cid: event.cid.toString(),
        parents: dbEvent.parents.map((i) => i.toString()),
        data: base64pad.encode(event.bytes)
      };
    })
  );
}
function WALState2Serialized(sthis, wal) {
  const serializedWAL = {
    fileOperations: wal.fileOperations.map((fop) => ({
      cid: fop.cid.toString(),
      public: fop.public
    })),
    noLoaderOps: wal.noLoaderOps.map((nop) => ({
      cars: nop.cars.map((i) => i.toString())
    })),
    operations: wal.operations.map((op) => ({
      cars: op.cars.map((i) => i.toString())
    }))
  };
  return serializedWAL;
}
async function fpSerialize(sthis, env, pencoder) {
  const encoder2 = {
    ...defaultEncoder,
    ...pencoder
  };
  switch (env.type) {
    case FPEnvelopeTypes.FILE:
      return encoder2.file(sthis, env.payload);
    case FPEnvelopeTypes.CAR:
      return encoder2.car(sthis, env.payload);
    case FPEnvelopeTypes.WAL:
      return encoder2.wal(sthis, WALState2Serialized(sthis, env.payload));
    case FPEnvelopeTypes.META:
      return encoder2.meta(sthis, await dbMetaEvent2Serialized(sthis, env.payload));
    default:
      throw sthis.logger.Error().Str("type", env.type).Msg("unsupported store").AsError();
  }
}
async function decode2DbMetaEvents(sthis, rserializedMeta) {
  if (rserializedMeta.isErr()) {
    return Result.Err(rserializedMeta.Err());
  }
  const serializedMeta = rserializedMeta.unwrap();
  if (!Array.isArray(serializedMeta)) {
    return sthis.logger.Debug().Any("metaEntries", serializedMeta).Msg("No data in MetaEntries").ResultError();
  }
  return Result.Ok(
    await Promise.all(
      serializedMeta.map(async (metaEntry) => {
        const eventBlock = await decodeEventBlock(base64pad.decode(metaEntry.data));
        const dbMeta = parse5(sthis.txt.decode(eventBlock.value.data.dbMeta));
        return {
          eventCid: eventBlock.cid,
          parents: metaEntry.parents.map((i) => CID.parse(i)),
          dbMeta
        };
      })
    )
  );
}
function toCid(sthis, link) {
  if (typeof link === "string") {
    return CID.parse(link);
  }
  return fromJSON(link);
}
async function decode2WalState(sthis, rserializedWAL) {
  if (rserializedWAL.isErr()) {
    return Result.Err(rserializedWAL.Err());
  }
  const serializedWAL = rserializedWAL.unwrap();
  return Result.Ok({
    fileOperations: (serializedWAL.fileOperations || []).map((fop) => ({
      cid: toCid(sthis, fop.cid),
      public: fop.public
    })),
    noLoaderOps: (serializedWAL.noLoaderOps || []).map((nop) => ({
      cars: (nop.cars || []).map((i) => toCid(sthis, i))
    })),
    operations: (serializedWAL.operations || []).map((op) => ({
      cars: (op.cars || []).map((i) => toCid(sthis, i))
    }))
  });
}
function makeFPEnvelope(type, payload) {
  if (payload.isErr()) {
    return Result.Err(payload.Err());
  }
  return Result.Ok({
    type,
    payload: payload.unwrap()
  });
}
async function fpDeserialize(sthis, url2, intoRaw, pdecoder) {
  const rraw = await coercePromiseIntoUint8(intoRaw);
  if (rraw.isErr()) {
    return Result.Err(rraw.Err());
  }
  const raw = rraw.unwrap();
  const decoder2 = {
    ...defaultDecoder,
    ...pdecoder
  };
  switch (url2.getParam(PARAM.STORE)) {
    case "car":
      return makeFPEnvelope(FPEnvelopeTypes.CAR, await decoder2.car(sthis, raw));
    case "file":
      return makeFPEnvelope(FPEnvelopeTypes.FILE, await decoder2.file(sthis, raw));
    case "wal":
      return makeFPEnvelope(FPEnvelopeTypes.WAL, await decode2WalState(sthis, await decoder2.wal(sthis, raw)));
    case "meta":
      return makeFPEnvelope(FPEnvelopeTypes.META, await decode2DbMetaEvents(sthis, await decoder2.meta(sthis, raw)));
    default:
      return sthis.logger.Error().Str("store", url2.getParam(PARAM.STORE)).Msg("unsupported store").ResultError();
  }
}
var defaultEncoder, defaultDecoder;
var init_fp_envelope_serialize2 = __esm({
  "core/gateways/base/fp-envelope-serialize.ts"() {
    "use strict";
    init_esm();
    init_blockstore();
    init_base2();
    init_clock();
    init_base642();
    init_src();
    init_link();
    init_src3();
    init_runtime2();
    defaultEncoder = {
      car: async (sthis, payload) => Result.Ok(payload),
      file: async (sthis, payload) => Result.Ok(payload),
      meta: async (sthis, payload) => Result.Ok(sthis.txt.encode(JSON.stringify(payload))),
      wal: async (sthis, payload) => Result.Ok(sthis.txt.encode(JSON.stringify(payload)))
    };
    defaultDecoder = {
      car: async (sthis, payload) => Result.Ok(payload),
      file: async (sthis, payload) => Result.Ok(payload),
      meta: async (sthis, payload) => exception2Result(() => JSON.parse(sthis.txt.decode(payload))),
      wal: async (sthis, payload) => exception2Result(() => JSON.parse(sthis.txt.decode(payload)))
    };
  }
});

// core/gateways/base/def-serde-gateway.ts
function wrapRawCallback(sthis, url2, callback, decoder2) {
  return async (raw) => {
    const res = await fpDeserialize(sthis, url2, Result.Ok(raw), decoder2);
    if (res.isErr()) {
      sthis.logger.Error().Err(res).Msg("Failed to deserialize");
      return;
    }
    await callback(res.Ok());
  };
}
function subscribeKeyURL(url2) {
  return url2.build().cleanParams(PARAM.SELF_REFLECT, PARAM.KEY, PARAM.LOCAL_NAME, PARAM.NAME).toString();
}
var subscribeFn, DefSerdeGateway;
var init_def_serde_gateway = __esm({
  "core/gateways/base/def-serde-gateway.ts"() {
    "use strict";
    init_esm();
    init_fp_envelope_serialize2();
    init_blockstore();
    init_base2();
    subscribeFn = /* @__PURE__ */ new Map();
    DefSerdeGateway = class {
      // abstract readonly storeType: StoreType;
      gw;
      constructor(gw) {
        this.gw = gw;
      }
      start({ loader: { sthis } }, baseURL) {
        return this.gw.start(baseURL, sthis);
      }
      async buildUrl({ loader: { sthis } }, baseUrl, key) {
        return this.gw.buildUrl(baseUrl, key, sthis);
      }
      async close({ loader: { sthis } }, uri) {
        return this.gw.close(uri, sthis);
      }
      async put({ loader: { sthis }, encoder: encoder2 }, url2, env) {
        const rUint8 = await fpSerialize(sthis, env, encoder2);
        if (rUint8.isErr()) return rUint8;
        const ret = this.gw.put(url2, rUint8.Ok(), sthis);
        if (env.type === FPEnvelopeTypes.META && url2.hasParam(PARAM.SELF_REFLECT)) {
          const urlWithoutKey = subscribeKeyURL(url2);
          const subFn = subscribeFn.get(urlWithoutKey);
          if (subFn) {
            await Promise.all(Array.from(subFn.values()).map((subFn2) => subFn2(rUint8.Ok())));
          }
        }
        return ret;
      }
      async get({ loader: { sthis }, decoder: decoder2 }, url2) {
        const res = await this.gw.get(url2, sthis);
        if (res.isErr()) return Result.Err(res.Err());
        return fpDeserialize(sthis, url2, res, decoder2);
      }
      async subscribe({ loader: { sthis }, decoder: decoder2 }, url2, callback) {
        const rawCallback = wrapRawCallback(sthis, url2, callback, decoder2);
        let realUnreg = Result.Ok(() => {
        });
        if (this.gw.subscribe) {
          realUnreg = await this.gw.subscribe(url2, rawCallback, sthis);
          if (realUnreg.isErr()) {
            return realUnreg;
          }
        }
        if (url2.hasParam(PARAM.SELF_REFLECT)) {
          const urlWithoutKey = subscribeKeyURL(url2);
          const fns = subscribeFn.get(urlWithoutKey) ?? /* @__PURE__ */ new Map();
          subscribeFn.set(urlWithoutKey, fns);
          const key = sthis.nextId().str;
          fns.set(key, rawCallback);
          return Result.Ok(() => {
            const f = subscribeFn.get(urlWithoutKey);
            if (!f) {
              return;
            }
            f.delete(key);
            if (f.size === 0) {
              subscribeFn.delete(urlWithoutKey);
            }
            realUnreg.Ok()();
          });
        }
        return realUnreg;
      }
      async delete({ loader: { sthis } }, url2) {
        return this.gw.delete(url2, sthis);
      }
      async destroy({ loader: { sthis } }, baseURL) {
        return this.gw.destroy(baseURL, sthis);
      }
      async getPlain({ loader: { sthis } }, iurl, key) {
        return this.gw.getPlain(iurl, key, sthis);
      }
    };
  }
});

// core/gateways/base/interceptor-gateway.ts
var PassThroughGateway, passThrougthGateway, InterceptorGateway;
var init_interceptor_gateway = __esm({
  "core/gateways/base/interceptor-gateway.ts"() {
    "use strict";
    init_esm();
    PassThroughGateway = class {
      async buildUrl(ctx, url2, key) {
        const op = { url: url2, key };
        return Result.Ok({ op });
      }
      async start(ctx, url2) {
        const op = { url: url2 };
        return Result.Ok({ op });
      }
      async close(ctx, url2) {
        const op = { url: url2 };
        return Result.Ok({ op });
      }
      async delete(ctx, url2) {
        const op = { url: url2 };
        return Result.Ok({ op });
      }
      async destroy(ctx, url2) {
        const op = { url: url2 };
        return Result.Ok({ op });
      }
      async put(ctx, url2, body) {
        const op = { url: url2, body };
        return Result.Ok({ op });
      }
      async get(ctx, url2) {
        const op = { url: url2 };
        return Result.Ok({ op });
      }
      async subscribe(ctx, url2, callback) {
        const op = { url: url2, callback };
        return Result.Ok({ op });
      }
    };
    passThrougthGateway = new PassThroughGateway();
    InterceptorGateway = class {
      innerGW;
      interceptor;
      constructor(sthis, innerGW, interceptor) {
        this.innerGW = innerGW;
        this.interceptor = interceptor || passThrougthGateway;
      }
      async buildUrl(ctx, baseUrl, key) {
        const rret = await this.interceptor.buildUrl(ctx, baseUrl, key);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.buildUrl(ctx, ret.op.url, ret.op.key);
      }
      async destroy(ctx, iurl) {
        const rret = await this.interceptor.destroy(ctx, iurl);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.destroy(ctx, ret.op.url);
      }
      async start(ctx, url2) {
        const rret = await this.interceptor.start(ctx, url2);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return await this.innerGW.start(ctx, ret.op.url);
      }
      async close(ctx, url2) {
        const rret = await this.interceptor.close(ctx, url2);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return await this.innerGW.close(ctx, ret.op.url);
      }
      async put(ctx, url2, fpEnv) {
        const rret = await this.interceptor.put(ctx, url2, fpEnv);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.put(ctx, ret.op.url, ret.op.body);
      }
      async get(ctx, url2) {
        const rret = await this.interceptor.get(ctx, url2);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.get(ctx, ret.op.url);
      }
      async subscribe(ctx, url2, callback) {
        if (!this.innerGW.subscribe) {
          return Result.Err(ctx.loader.sthis.logger.Error().Url(url2).Msg("subscribe not supported").AsError());
        }
        const rret = await this.interceptor.subscribe(ctx, url2, callback);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.subscribe(ctx, ret.op.url, ret.op.callback);
      }
      async delete(ctx, url2) {
        const rret = await this.interceptor.delete(ctx, url2);
        if (rret.isErr()) {
          return Result.Err(rret.Err());
        }
        const ret = rret.unwrap();
        if (ret.stop && ret.value) {
          return ret.value;
        }
        return this.innerGW.delete(ctx, url2);
      }
      async getPlain(ctx, url2, key) {
        return this.innerGW.getPlain(ctx, url2, key);
      }
    };
  }
});

// core/gateways/base/uri-interceptor.ts
var URIInterceptor;
var init_uri_interceptor = __esm({
  "core/gateways/base/uri-interceptor.ts"() {
    "use strict";
    init_interceptor_gateway();
    URIInterceptor = class _URIInterceptor extends PassThroughGateway {
      static withMapper(mapper) {
        return new _URIInterceptor().addMapper(mapper);
      }
      #uriMapper = /* @__PURE__ */ new Set();
      addMapper(mapper) {
        this.#uriMapper.add(mapper);
        return this;
      }
      async #map(uri) {
        let ret = uri;
        for (const mapper of this.#uriMapper) {
          ret = await mapper(ret);
        }
        return ret;
      }
      async buildUrl(ctx, url2, key) {
        const ret = await super.buildUrl(ctx, await this.#map(url2), key);
        return ret;
      }
      async start(ctx, url2) {
        const ret = await super.start(ctx, await this.#map(url2));
        return ret;
      }
      async close(ctx, url2) {
        const ret = await super.close(ctx, await this.#map(url2));
        return ret;
      }
      async delete(ctx, url2) {
        const ret = await super.delete(ctx, await this.#map(url2));
        return ret;
      }
      async destroy(ctx, url2) {
        const ret = await super.destroy(ctx, await this.#map(url2));
        return ret;
      }
      async put(ctx, url2, body) {
        const ret = await super.put(ctx, await this.#map(url2), body);
        return ret;
      }
      async get(ctx, url2) {
        const ret = await super.get(ctx, await this.#map(url2));
        return ret;
      }
      async subscribe(ctx, url2, callback) {
        const ret = await super.subscribe(ctx, await this.#map(url2), callback);
        return ret;
      }
    };
  }
});

// core/gateways/base/utils.ts
function getPath(url2, sthis) {
  const basePath = url2.pathname;
  const name2 = url2.getParam("name");
  if (name2) {
    return sthis.pathOps.join(basePath, name2);
  }
  return sthis.pathOps.join(basePath);
}
function getFileName(url2, sthis) {
  const key = url2.getParam("key");
  if (!key) throw sthis.logger.Error().Url(url2).Msg(`key not found`).AsError();
  const res = getStore(url2, sthis, (...a) => a.join("-"));
  switch (res.fromUrl) {
    case "file":
      return sthis.pathOps.join(res.name, key);
    case "car":
      return sthis.pathOps.join(res.name, key + ".car");
    case "wal":
    case "meta":
      return sthis.pathOps.join(res.name, key + ".json");
    default:
      throw sthis.logger.Error().Url(url2).Msg(`unsupported store type`).AsError();
  }
}
var init_utils2 = __esm({
  "core/gateways/base/utils.ts"() {
    "use strict";
    init_runtime2();
  }
});

// core/gateways/base/indexeddb-version.ts
var INDEXEDDB_VERSION;
var init_indexeddb_version = __esm({
  "core/gateways/base/indexeddb-version.ts"() {
    "use strict";
    INDEXEDDB_VERSION = "v0.19-indexeddb";
  }
});

// core/gateways/base/meta-key-hack.ts
async function V2SerializedMetaKeyExtractKey(ctx, v2) {
  const kb = await ctx.loader.keyBag();
  if (!kb) {
    return Promise.resolve(Result.Err(new Error("missing keybag")));
  }
  const dataUrl = await ctx.loader.attachedStores.local().active.car.url();
  const keyName = dataUrl.getParam(PARAM.STORE_KEY);
  if (!keyName) {
    ctx.loader.sthis.logger.Warn().Url(dataUrl).Msg("missing store key");
  } else {
    const rKey = await kb.getNamedKey(keyName);
    if (rKey.isErr()) {
      ctx.loader.sthis.logger.Warn().Str("keyName", keyName).Msg("did not found a extractable key");
    } else {
      for (const keyStr of v2.keys) {
        const res = await rKey.Ok().upsert(keyStr, { def: false });
        if (res.isErr()) {
          ctx.loader.sthis.logger.Warn().Str("keyStr", keyStr).Msg("failed to upsert key");
        }
      }
    }
  }
  return Promise.resolve(Result.Ok(v2.metas));
}
async function wrapEncode(ctx, payload, fn) {
  const carStore = ctx.loader.attachedStores.local().active.car;
  const kb = await ctx.loader.keyBag();
  if (!kb) {
    return Promise.resolve(Result.Err(new Error("missing keybag")));
  }
  const keyName = carStore.url().getParam(PARAM.STORE_KEY) ?? "";
  const rKex = await kb.getNamedKey(keyName);
  if (rKex.isErr()) {
    return Promise.resolve(Result.Err(rKex.Err()));
  }
  const keyMaterials = await rKex.Ok().asV2StorageKeyItem().then((i) => Object.values(i.keys).map((i2) => i2.key));
  return Promise.resolve(Result.Ok(fn(payload, keyMaterials)));
}
function encodeAsV2SerializedMetaKey(ctx, payload) {
  return wrapEncode(
    ctx,
    payload,
    (payload2, keyM) => ({
      metas: payload2,
      keys: keyM
    })
  );
}
var init_meta_key_hack = __esm({
  "core/gateways/base/meta-key-hack.ts"() {
    "use strict";
    init_esm();
    init_base2();
    init_def_serde_gateway();
  }
});

// core/gateways/base/index.ts
var init_base3 = __esm({
  "core/gateways/base/index.ts"() {
    "use strict";
    init_fp_envelope_serialize2();
    init_def_serde_gateway();
    init_interceptor_gateway();
    init_uri_interceptor();
    init_utils2();
    init_indexeddb_version();
    init_meta_key_hack();
  }
});

// node_modules/.pnpm/idb@8.0.3/node_modules/idb/build/index.js
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
function promisifyRequest(request) {
  const promise2 = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success2);
      request.removeEventListener("error", error48);
    };
    const success2 = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error48 = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success2);
    request.addEventListener("error", error48);
  });
  reverseTransformCache.set(promise2, request);
  return promise2;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error48);
      tx.removeEventListener("abort", error48);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error48 = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error48);
    tx.addEventListener("abort", error48);
  });
  transactionDoneMap.set(tx, done);
}
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(this.request);
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
async function* iterate(...args) {
  let cursor = this;
  if (!(cursor instanceof IDBCursor)) {
    cursor = await cursor.openCursor(...args);
  }
  if (!cursor)
    return;
  cursor = cursor;
  const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
  ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
  reverseTransformCache.set(proxiedCursor, unwrap(cursor));
  while (cursor) {
    yield proxiedCursor;
    cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
    advanceResults.delete(proxiedCursor);
  }
}
function isIteratorProp(target, prop) {
  return prop === Symbol.asyncIterator && instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor]) || prop === "iterate" && instanceOfAny(target, [IDBIndex, IDBObjectStore]);
}
var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, transactionDoneMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap, readMethods, writeMethods, cachedMethods, advanceMethodProps, methodMap, advanceResults, ittrProxiedCursorToOriginalProxy, cursorIteratorTraps;
var init_build = __esm({
  "node_modules/.pnpm/idb@8.0.3/node_modules/idb/build/index.js"() {
    instanceOfAny = (object2, constructors) => constructors.some((c) => object2 instanceof c);
    transactionDoneMap = /* @__PURE__ */ new WeakMap();
    transformCache = /* @__PURE__ */ new WeakMap();
    reverseTransformCache = /* @__PURE__ */ new WeakMap();
    idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    unwrap = (value) => reverseTransformCache.get(value);
    readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    writeMethods = ["put", "add", "delete", "clear"];
    cachedMethods = /* @__PURE__ */ new Map();
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
    advanceMethodProps = ["continue", "continuePrimaryKey", "advance"];
    methodMap = {};
    advanceResults = /* @__PURE__ */ new WeakMap();
    ittrProxiedCursorToOriginalProxy = /* @__PURE__ */ new WeakMap();
    cursorIteratorTraps = {
      get(target, prop) {
        if (!advanceMethodProps.includes(prop))
          return target[prop];
        let cachedFunc = methodMap[prop];
        if (!cachedFunc) {
          cachedFunc = methodMap[prop] = function(...args) {
            advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
          };
        }
        return cachedFunc;
      }
    };
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get(target, prop, receiver) {
        if (isIteratorProp(target, prop))
          return iterate;
        return oldTraps.get(target, prop, receiver);
      },
      has(target, prop) {
        return isIteratorProp(target, prop) || oldTraps.has(target, prop);
      }
    }));
  }
});

// core/gateways/indexeddb/key-bag-indexeddb.ts
var KeyBagProviderIndexedDB;
var init_key_bag_indexeddb = __esm({
  "core/gateways/indexeddb/key-bag-indexeddb.ts"() {
    "use strict";
    init_build();
    init_esm();
    init_base3();
    KeyBagProviderIndexedDB = class {
      _db = new ResolveOnce();
      dbName;
      url;
      logger;
      sthis;
      constructor(url2, sthis) {
        this.sthis = sthis;
        this.logger = sthis.logger;
        this.url = url2;
        this.dbName = getPath(this.url, this.sthis);
      }
      async _prepare() {
        return this._db.once(async () => {
          return await openDB(this.dbName, 1, {
            upgrade(db) {
              ["bag"].map((store) => {
                db.createObjectStore(store, {
                  autoIncrement: false
                });
              });
            }
          });
        });
      }
      async del(id) {
        const db = await this._prepare();
        const tx = db.transaction(["bag"], "readwrite");
        await tx.objectStore("bag").delete(id);
        await tx.done;
      }
      async get(id) {
        const db = await this._prepare();
        const tx = db.transaction(["bag"], "readonly");
        const keyItem = await tx.objectStore("bag").get(id);
        await tx.done;
        if (!keyItem) {
          return void 0;
        }
        return keyItem;
      }
      async set(id, item) {
        const db = await this._prepare();
        const tx = db.transaction(["bag"], "readwrite");
        await tx.objectStore("bag").put(item, id);
        await tx.done;
      }
    };
  }
});

// core/gateways/indexeddb/dummy-idb.ts
var ReadDummyIDBPObjectStore, ReadDummyIDBPDatabase;
var init_dummy_idb = __esm({
  "core/gateways/indexeddb/dummy-idb.ts"() {
    "use strict";
    ReadDummyIDBPObjectStore = class {
      //   readonly indexNames: TypedDOMStringList<string> = undefined as unknown as TypedDOMStringList<string>;
      //   readonly transaction: IDBPTransaction<unknown, ArrayLike<string>, "readonly">;
      name;
      autoIncrement = false;
      keyPath = [];
      transaction;
      constructor(name2, transaction) {
        this.transaction = transaction;
        this.name = name2;
      }
      indexNames = void 0;
      add = ((_value, _key) => {
        throw new Error("add not implemented.");
      });
      //   = (_value: StoreValue<DBTypes, StoreName>, _key?: IDBKeyRange | StoreKey<DBTypes, StoreName> | undefined) => {
      //     throw new Error("add not implemented.");
      //   } as unknown as AddType<DBTypes, StoreName, Mode>;
      clear = void 0;
      createIndex = void 0;
      delete = (async (_key) => {
        throw new Error("delete not implemented.");
      });
      put = void 0;
      get(_query) {
        return Promise.resolve(void 0);
      }
      getAll(_query, _count) {
        return Promise.resolve([]);
      }
      getAllKeys(_query, _count) {
        return Promise.resolve([]);
      }
      getKey(_query) {
        return Promise.resolve(void 0);
      }
      index(_name) {
        throw new Error("Method not implemented.");
      }
      openCursor(_query, _direction) {
        throw new Error("Method not implemented.");
      }
      openKeyCursor(_query, _direction) {
        throw new Error("Method not implemented.");
      }
      iterate(_query, _direction) {
        throw new Error("Method not implemented.");
      }
      [Symbol.asyncIterator]() {
        throw new Error("Method not implemented.");
      }
      deleteIndex(_name) {
        throw new Error("Method not implemented.");
      }
      count(_key) {
        throw new Error("count not implemented.");
      }
    };
    ReadDummyIDBPDatabase = class {
      get objectStoreNames() {
        throw new Error("objectStoreNames not implemented.");
      }
      version;
      name;
      constructor(name2, version2 = 666) {
        this.name = name2;
        this.version = version2;
      }
      createObjectStore(_name, _optionalParameters) {
        throw new Error("createObjectStore not implemented.");
      }
      deleteObjectStore(_name) {
        throw new Error("deleteObjectStore not implemented.");
      }
      transaction(_storeNames, _mode, _options) {
        return {
          done: Promise.resolve(),
          objectStore: function(storeName) {
            return new ReadDummyIDBPObjectStore(storeName, this);
          }
        };
      }
      add(_storeName, _value, _key) {
        throw new Error("add not implemented.");
      }
      clear(_name) {
        throw new Error("clear not implemented.");
      }
      count(_storeName, _key) {
        throw new Error("count not implemented.");
      }
      countFromIndex(_storeName, _indexName, _key) {
        throw new Error("countFromIndex not implemented.");
      }
      delete(_storeName, _key) {
        return Promise.resolve();
      }
      get(_storeName, _query) {
        throw new Error("get not implemented.");
      }
      getFromIndex(_storeName, _indexName, _query) {
        throw new Error("getFromIndex not implemented.");
      }
      getAll(_storeName, _query, _count) {
        return Promise.resolve([]);
      }
      getAllFromIndex(_storeName, _indexName, _query, _count) {
        return Promise.resolve([]);
      }
      getAllKeys(_storeName, _query, _count) {
        return Promise.resolve([]);
      }
      getAllKeysFromIndex(_storeName, _indexName, _query, _count) {
        return Promise.resolve([]);
      }
      getKey(_storeName, _query) {
        return Promise.resolve(void 0);
      }
      getKeyFromIndex(_storeName, _indexName, _query) {
        return Promise.resolve(void 0);
      }
      put(_storeName, _value, _key) {
        throw new Error("put not implemented.");
      }
      onabort = null;
      onclose = null;
      onerror = null;
      onversionchange = null;
      close() {
        throw new Error("close not implemented.");
      }
      addEventListener(_type, _listener, _options) {
        throw new Error("addEventListener not implemented.");
      }
      removeEventListener(_type, _listener, _options) {
        throw new Error("removeEventListener not implemented.");
      }
      dispatchEvent(_event) {
        throw new Error("dispatchEvent not implemented.");
      }
    };
  }
});

// core/gateways/indexeddb/gateway-impl.ts
function ensureVersion(url2) {
  return url2.build().defParam(PARAM.VERSION, INDEXEDDB_VERSION).URI();
}
function sanitzeKey(key) {
  if (key.length === 1) {
    key = key[0];
  }
  return key;
}
function onceCreateDB(dbName, url2, sthis) {
  return async () => {
    const db = await openDB(dbName.fullDb, 1, {
      upgrade(db2) {
        ["version", "data", "wal", "meta", "idx.data", "idx.wal", "idx.meta"].map((store) => {
          db2.createObjectStore(store, {
            autoIncrement: false
          });
        });
      }
    });
    listDatabases.reset();
    const found = await db.get("version", "version");
    const version2 = ensureVersion(url2).getParam(PARAM.VERSION);
    if (!found) {
      await db.put("version", { version: version2 }, "version");
    } else if (found.version !== version2) {
      sthis.logger.Warn().Url(url2).Str("version", version2).Str("found", found.version).Msg("version mismatch");
    }
    return { db, dbName, version: version2, url: url2 };
  };
}
async function connectIdb(style, url2, sthis) {
  const dbName = getIndexedDBName(url2, sthis);
  if (style === "close") {
    if (onceIndexedDB.has(dbName.fullDb)) {
      const ic = await onceIndexedDB.get(dbName.fullDb).once(() => Promise.reject(new Error("not open")));
      ic.db.close();
      onceIndexedDB.unget(dbName.fullDb);
    }
    return void 0;
  }
  if (style === "read" || style === "delete") {
    if (!onceIndexedDB.has(dbName.fullDb)) {
      const dbs = await listDatabases.once(() => indexedDB.databases());
      if (!dbs.find((i) => i.name === dbName.fullDb)) {
        const verUrl = ensureVersion(url2);
        return {
          db: new ReadDummyIDBPDatabase(dbName.fullDb),
          dbName,
          version: verUrl.getParam(PARAM.VERSION, INDEXEDDB_VERSION),
          url: verUrl
        };
      }
    }
  }
  return onceIndexedDB.get(dbName.fullDb).once(onceCreateDB(dbName, url2, sthis));
}
function joinDBName(...names) {
  return names.map((i) => i.replace(/^[^a-zA-Z0-9]+/g, "").replace(/[^a-zA-Z0-9-]+/g, "_")).filter((i) => i.length).join(".");
}
function getIndexedDBName(iurl, sthis) {
  const url2 = ensureVersion(iurl);
  const fullDb = url2.pathname.replace(/^\/+/, "").replace(/\?.*$/, "");
  const dbName = url2.getParam(PARAM.NAME);
  if (!dbName) throw sthis.logger.Error().Str("url", url2.toString()).Msg(`name not found`).AsError();
  const result = joinDBName(fullDb, dbName);
  const objStore = getStore(url2, sthis, joinDBName).name;
  const connectionKey = [result, objStore].join(":");
  return {
    fullDb: result,
    objStore,
    connectionKey,
    dbName
  };
}
var onceIndexedDB, listDatabases, IndexedDBGateway;
var init_gateway_impl = __esm({
  "core/gateways/indexeddb/gateway-impl.ts"() {
    "use strict";
    init_build();
    init_esm();
    init_base3();
    init_base2();
    init_runtime2();
    init_dummy_idb();
    onceIndexedDB = new KeyedResolvOnce();
    listDatabases = new ResolveOnce();
    IndexedDBGateway = class {
      async start(baseURL, sthis) {
        return exception2Result(async () => {
          await sthis.start();
          sthis.logger.Debug().Url(baseURL).Msg("starting");
          const ic = await connectIdb("read", baseURL, sthis);
          sthis.logger.Debug().Url(ic.url).Msg("started");
          return baseURL.build().setParam(PARAM.VERSION, ic.version).URI();
        });
      }
      async close(url2, sthis) {
        await connectIdb("close", url2, sthis);
        return Result.Ok(void 0);
      }
      async destroy(baseUrl, sthis) {
        return exception2Result(async () => {
          const type = getStore(baseUrl, sthis, joinDBName).name;
          const idb = await connectIdb("write", baseUrl, sthis);
          const trans = idb.db.transaction(type, "readwrite");
          const object_store = trans.objectStore(type);
          const toDelete = [];
          for (let cursor = await object_store.openCursor(); cursor; cursor = await cursor.continue()) {
            toDelete.push(cursor.primaryKey);
          }
          for (const key of toDelete) {
            await trans.db.delete(type, key);
          }
          await trans.done;
        });
      }
      buildUrl(baseUrl, key) {
        return Promise.resolve(Result.Ok(baseUrl.build().setParam(PARAM.KEY, key).URI()));
      }
      async get(url2, sthis) {
        return exceptionWrapper(async () => {
          const key = getKey(url2, sthis.logger);
          const store = getStore(url2, sthis, joinDBName).name;
          sthis.logger.Debug().Url(url2).Str("key", key).Str("store", store).Msg("getting");
          const idb = await connectIdb("read", url2, sthis);
          const tx = idb.db.transaction([store], "readonly");
          const bytes = await tx.objectStore(store).get(sanitzeKey(key));
          await tx.done;
          if (!bytes) {
            return Result.Err(new NotFoundError(`missing ${key} ${url2.toString()}`));
          }
          return Promise.resolve(Result.Ok(bytes));
        });
      }
      async put(url2, bytes, sthis) {
        return exception2Result(async () => {
          const key = getKey(url2, sthis.logger);
          const store = getStore(url2, sthis, joinDBName).name;
          sthis.logger.Debug().Url(url2).Str("key", key).Str("store", store).Msg("putting");
          const idb = await connectIdb("write", url2, sthis);
          const tx = idb.db.transaction([store], "readwrite");
          await tx.objectStore(store).put(bytes, sanitzeKey(key));
          await tx.done;
        });
      }
      async delete(url2, sthis) {
        return exception2Result(async () => {
          const key = getKey(url2, sthis.logger);
          const store = getStore(url2, sthis, joinDBName).name;
          sthis.logger.Debug().Url(url2).Str("key", key).Str("store", store).Msg("deleting");
          const idb = await connectIdb("delete", url2, sthis);
          const tx = idb.db.transaction([store], "readwrite");
          await tx.objectStore(store).delete(sanitzeKey(key));
          await tx.done;
          return Result.Ok(void 0);
        });
      }
      async getPlain(url2, key, sthis) {
        const ic = await connectIdb("read", url2, sthis);
        const store = getStore(ic.url, sthis, joinDBName).name;
        sthis.logger.Debug().Str("key", key).Str("store", store).Msg("getting");
        let bytes = await ic.db.get(store, sanitzeKey(key));
        sthis.logger.Debug().Str("key", key).Str("store", store).Int("len", bytes.length).Msg("got");
        if (typeof bytes === "string") {
          bytes = sthis.txt.encode(bytes);
        }
        return Result.Ok(bytes);
      }
    };
  }
});

// core/gateways/indexeddb/index.ts
var indexeddb_exports = {};
__export(indexeddb_exports, {
  GatewayImpl: () => IndexedDBGateway,
  KeyBagProviderImpl: () => KeyBagProviderIndexedDB,
  KeyBagProviderIndexedDB: () => KeyBagProviderIndexedDB
});
var init_indexeddb = __esm({
  "core/gateways/indexeddb/index.ts"() {
    "use strict";
    init_key_bag_indexeddb();
    init_key_bag_indexeddb();
    init_gateway_impl();
  }
});

// node_modules/.pnpm/ws@8.18.3_bufferutil@4.1.0_utf-8-validate@5.0.10/node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/ws@8.18.3_bufferutil@4.1.0_utf-8-validate@5.0.10/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// use-fireproof/clerk/dist/npm/use-fireproof-clerk.js
import { useCallback as useCallback5, useEffect as useEffect7, useState as useState7, useRef as useRef5 } from "react";

// core/base/ledger.ts
init_esm();

// core/base/write-queue.ts
init_runtime2();
init_base2();
init_esm();
var WriteQueueImpl = class {
  opts;
  queue = [];
  worker;
  isProcessing = false;
  logger;
  constructor(sthis, worker, opts) {
    this.logger = ensureLogger(sthis, "WriteQueueImpl");
    this.worker = worker;
    this.opts = defaultWriteQueueOpts(opts);
  }
  waitForEmptyQueue;
  testEmptyQueue() {
    if (this.waitForEmptyQueue && this.queue.length === 0) {
      this.waitForEmptyQueue.resolve();
    }
  }
  async process() {
    if (this.isProcessing || this.queue.length === 0) {
      this.testEmptyQueue();
      return;
    }
    this.isProcessing = true;
    try {
      this.logger.Debug().Any("opts", this.opts).Len(this.queue).Msg("Processing tasks");
      const tasksToProcess = this.queue.splice(0, this.opts.chunkSize);
      const updates = tasksToProcess.map((item) => item.tasks).filter((item) => item);
      const promises = updates.map(async (update, index2) => {
        try {
          const result = await this.worker(update);
          tasksToProcess[index2].resolve(result);
        } catch (error48) {
          tasksToProcess[index2].reject(this.logger.Error().Err(error48).Msg("Error processing task").AsError());
        }
      });
      await Promise.allSettled(promises);
      this.logger.Debug().Any("opts", this.opts).Len(this.queue).Msg("Processed tasks");
    } catch (error48) {
      this.logger.Error().Err(error48).Msg("Error processing tasks");
    } finally {
      this.isProcessing = false;
      setTimeout(() => this.process(), 0);
    }
  }
  bulk(tasks) {
    return new Promise((resolve, reject) => {
      this.queue.push({ tasks, resolve, reject });
      this.process();
    });
  }
  push(task) {
    return this.bulk([task]);
  }
  close() {
    this.waitForEmptyQueue = new Future();
    this.testEmptyQueue();
    return this.waitForEmptyQueue.asPromise();
  }
};
function writeQueue(sthis, worker, opts) {
  return new WriteQueueImpl(sthis, worker, opts);
}

// core/base/ledger.ts
init_base2();
init_runtime2();

// core/base/indexer.ts
init_base2();

// core/base/indexer-helpers.ts
init_sha2_browser();
init_src2();
var import_charwise = __toESM(require_charwise(), 1);

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js
init_block();

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/utils.js
var readUInt32LE = (buffer3) => {
  const offset = buffer3.byteLength - 4;
  return (buffer3[offset] | buffer3[offset + 1] << 8 | buffer3[offset + 2] << 16) + buffer3[offset + 3] * 16777216;
};
var MAX_UINT32 = 4294967295;
var bf = (factor) => {
  const threshold = Math.floor(MAX_UINT32 / factor);
  return async (entry) => {
    const identity = await entry.identity();
    if (typeof identity !== "number") {
      throw new Error("Identity must be a number");
    }
    if (identity <= threshold) {
      return true;
    }
    return false;
  };
};
var simpleCompare = (a, b) => {
  if (a === b)
    return 0;
  if (a > b)
    return 1;
  return -1;
};
var CIDCounter = class {
  constructor() {
    this._cids = /* @__PURE__ */ new Set();
  }
  add(node) {
    if (!node.address) {
      throw new Error("Cannot add node without address");
    }
    if (node.address.then) {
      const p = node.address.then((cid) => this._cids.add(cid.toString()));
      this._cids.add(p);
      p.then(() => this._cids.delete(p));
    } else {
      this._cids.add(node.address.toString());
    }
  }
  async all() {
    await Promise.all([...this._cids]);
    return this._cids;
  }
};

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js
var Entry = class {
  constructor({ key, address }, opts = {}) {
    this.key = key;
    this.address = address;
    this.codec = opts.codec;
    this.hasher = opts.hasher;
  }
  get isEntry() {
    return true;
  }
};
var EntryList = class {
  constructor({ entries: entries4, closed }) {
    if (typeof closed !== "boolean")
      throw new Error('Missing required argument "closed"');
    this.entries = entries4;
    this.closed = closed;
    this.startKey = entries4[0].key;
  }
  find(key, compare5) {
    const { entries: entries4 } = this;
    for (let i = entries4.length - 1; i > -1; i--) {
      const entry = entries4[i];
      const comp = compare5(key, entry.key);
      if (comp > -1) {
        return [
          i,
          entry
        ];
      }
    }
    return null;
  }
  findMany(keys, compare5, sorted = false, strict = false) {
    const { entries: entries4 } = this;
    const results = /* @__PURE__ */ new Map();
    if (!sorted) {
      keys = keys.sort(compare5);
    } else {
      keys = [...keys];
    }
    for (let i = entries4.length - 1; i > -1; i--) {
      if (!keys.length)
        break;
      const entry = entries4[i];
      const found = [];
      while (keys.length) {
        let key = keys[keys.length - 1];
        key = key.key ? key.key : key;
        const comp = compare5(key, entry.key);
        if (!strict) {
          if (comp > -1) {
            found.push(keys.pop());
          } else {
            break;
          }
        } else {
          if (comp === 0) {
            found.push(keys.pop());
          } else if (comp > 0) {
            keys.pop();
          } else {
            break;
          }
        }
      }
      if (found.length) {
        results.set(i, [
          entry,
          found
        ]);
      }
    }
    return results;
  }
  findRange(start, end, compare5) {
    const { entries: entries4 } = this;
    let last;
    let first = 0;
    for (let i = entries4.length - 1; i > -1; i--) {
      const entry = entries4[i];
      const comp = compare5(end, entry.key);
      if (comp > 0) {
        last = i;
        break;
      }
    }
    for (let i = 0; i < entries4.length; i++) {
      const entry = entries4[i];
      const comp = compare5(start, entry.key);
      if (comp === 0) {
        first = i;
        break;
      } else if (comp < 0) {
        break;
      }
      first = i;
    }
    return {
      first,
      last,
      entries: entries4.slice(first, last + 1)
    };
  }
};
var stringKey = (key) => typeof key === "string" ? key : JSON.stringify(key);
function sortBulk(bulk, opts) {
  return bulk.sort(({ key: a }, { key: b }) => opts.compare(a, b));
}
async function filterLeftmostInserts(first, bulk, compare5) {
  const inserts = [];
  for (const b of bulk) {
    const { key, del: del2 } = b;
    if (compare5(key, first) < 0) {
      if (!del2)
        inserts.push(b);
    } else {
      break;
    }
  }
  return inserts;
}
async function generateNewLeaves(inserts, opts, { chunker, compare: compare5 }) {
  return await Node.from({
    entries: inserts.map((insert) => new opts.LeafEntryClass(insert, opts)).sort((a, b) => compare5(a.key, b.key)),
    chunker,
    NodeClass: opts.LeafClass,
    distance: 0,
    opts
  });
}
async function generateBranchEntries(that, newLeaves, results, opts) {
  return await Promise.all(newLeaves.map(async (node) => {
    const block = await node.encode();
    results.blocks.push({
      block,
      node
    });
    that.cache.set(node);
    const newBranchEntry = new opts.BranchEntryClass({
      key: node.key,
      address: await node.address
    }, opts);
    return newBranchEntry;
  }));
}
async function processRoot(that, results, bulk, nodeOptions) {
  const root2 = results.root;
  results.blocks.push({
    block: await root2.encode(),
    node: root2
  });
  that.cache.set(root2);
  const opts = nodeOptions.opts;
  const distance = root2.distance;
  const first = root2.entryList.startKey;
  const inserts = await filterLeftmostInserts(first, bulk, that.compare);
  if (inserts.length) {
    const newLeaves = await generateNewLeaves(inserts, opts, that);
    const branchEntries = await generateBranchEntries(that, newLeaves, results, opts);
    const firstRootEntry = new opts.BranchEntryClass({
      key: root2.entryList.startKey,
      address: await root2.address
    }, opts);
    const newBranchEntries = [
      firstRootEntry,
      ...branchEntries
    ].sort(({ key: a }, { key: b }) => opts.compare(a, b));
    let newBranches = await Node.from({
      ...nodeOptions,
      entries: newBranchEntries,
      chunker: that.chunker,
      NodeClass: opts.BranchClass,
      distance: distance + 1
    });
    let allBranches = [...newBranches];
    while (newBranches.length > 1) {
      const newBranchEntries2 = await Promise.all(newBranches.map(async (l) => new opts.BranchEntryClass({
        key: l.key,
        address: await l.address
      }, opts)));
      newBranches = await Node.from({
        ...nodeOptions,
        entries: newBranchEntries2.sort(({ key: a }, { key: b }) => opts.compare(a, b)),
        chunker: that.chunker,
        NodeClass: opts.BranchClass,
        distance: distance + 1
      });
      allBranches = [
        ...allBranches,
        ...newBranches
      ];
    }
    await Promise.all(allBranches.map(async (m) => {
      const block = await m.encode();
      that.cache.set(m);
      results.blocks.push({
        block,
        node: m
      });
    }));
    results.root = newBranches[0];
    results.nodes = [
      ...results.nodes,
      ...allBranches
    ];
  }
}
var Node = class _Node {
  constructor({ entryList, chunker, distance, getNode, compare: compare5, cache: cache3 }) {
    this.entryList = entryList;
    this.chunker = chunker;
    this.distance = distance;
    this.getNode = getNode;
    this.compare = compare5;
    this.cache = cache3;
  }
  get closed() {
    return this.entryList.closed;
  }
  get key() {
    return this.entryList.startKey;
  }
  async getEntry(key, cids = new CIDCounter()) {
    const result = await this._getEntry(key, cids);
    return {
      result,
      cids
    };
  }
  async _getEntry(key, cids) {
    cids.add(this);
    let node = this;
    while (!node.isLeaf) {
      const result2 = node.entryList.find(key, this.compare);
      if (result2 === null)
        throw new Error("Not found");
      const [, entry2] = result2;
      node = await this.getNode(await entry2.address);
      cids.add(node);
    }
    const result = node.entryList.find(key, this.compare);
    if (result === null || result[1].key.toString() !== key.toString())
      throw new Error("Not found");
    const [, entry] = result;
    return entry;
  }
  async getAllEntries(cids = new CIDCounter()) {
    const result = await this._getAllEntries(cids);
    return {
      result,
      cids
    };
  }
  _getAllEntries(cids) {
    cids.add(this);
    if (this.isLeaf) {
      return this.entryList.entries;
    } else {
      const { entries: entries4 } = this.entryList;
      const mapper = async (entry) => this.getNode(await entry.address).then((node) => node._getAllEntries(cids)).catch(async (err) => {
        throw err;
      });
      return Promise.all(entries4.map(mapper)).then((results) => results.flat());
    }
  }
  async *vis(cids = /* @__PURE__ */ new Set()) {
    const renderNodeLabel = async (node) => {
      if (node.isLeaf) {
        const entries4 = node.entryList.entries.map((e) => `[${e.key},${JSON.stringify(e.value).replace(/"/g, "'")}]`).join(", ");
        return `Leaf [${entries4}]`;
      } else {
        const entries4 = node.entryList.entries.map((e) => `[${e.key}]`).join(", ");
        return `Branch [${entries4}]`;
      }
    };
    const shortCid = (cid) => cid.toString().slice(0, 4) + cid.toString().slice(-4);
    const visit3 = async function* (node, parentId, cids2) {
      const nodeId = await node.address;
      if (!cids2.has(nodeId)) {
        cids2.add(nodeId);
        const nodeLabel = await renderNodeLabel(node);
        yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(nodeId)} [label="${nodeLabel}"];`;
        yield `  ${shortCid(parentId)} -> ${shortCid(nodeId)};`;
        for (const entry of node.entryList.entries) {
          if (entry.address) {
            const entryId = await entry.address;
            try {
              const childNode = await node.getNode(entryId);
              yield* await visit3(childNode, nodeId, cids2);
            } catch (err) {
              yield `  ${shortCid(nodeId)} -> ${shortCid(entryId)};`;
              yield `  node [shape=ellipse fontname="Courier"]; ${shortCid(entryId)} [label="Error: ${err.message}"];`;
            }
          }
        }
      }
    };
    yield "digraph tree {";
    yield '  node [shape=ellipse fontname="Courier"]; rootnode;';
    for await (const line of visit3(this, "rootnode", cids)) {
      yield line;
    }
    yield "}";
  }
  async getEntries(keys, sorted = false, cids = new CIDCounter()) {
    const result = await this._getEntries(keys, sorted, cids);
    return {
      result,
      cids
    };
  }
  async _getEntries(keys, sorted, cids) {
    cids.add(this);
    if (!sorted)
      keys = keys.sort(this.compare);
    const results = this.entryList.findMany(keys, this.compare, true, this.isLeaf);
    if (this.isLeaf) {
      return [...results.values()].map(([entry]) => entry);
    }
    let entries4 = [];
    for (const [entry, keys2] of [...results.values()].reverse()) {
      const p = this.getNode(await entry.address);
      entries4.push(p.then((node) => node._getEntries(keys2.reverse(), true, cids)));
    }
    entries4 = await Promise.all(entries4);
    return entries4.flat();
  }
  async getRangeEntries(start, end, cids = new CIDCounter()) {
    const result = await this._getRangeEntries(start, end, cids);
    return {
      result,
      cids
    };
  }
  _getRangeEntries(start, end, cids) {
    cids.add(this);
    const { entries: entries4 } = this.entryList.findRange(start, end, this.compare);
    if (this.isLeaf) {
      return entries4.filter((entry) => {
        const s = this.compare(start, entry.key);
        const e = this.compare(end, entry.key);
        if (s <= 0 && e >= 0)
          return true;
        return false;
      });
    }
    if (!entries4.length)
      return [];
    const thenRange = async (entry) => this.getNode(await entry.address).then((node) => node._getRangeEntries(start, end, cids));
    const results = [thenRange(entries4.shift())];
    if (!entries4.length)
      return results[0];
    const last = thenRange(entries4.pop());
    while (entries4.length) {
      const thenAll = async (entry) => this.getNode(await entry.address).then(async (node) => node._getAllEntries(cids));
      results.push(thenAll(entries4.shift()));
    }
    results.push(last);
    return Promise.all(results).then((results2) => results2.flat());
  }
  async transaction(bulk, opts = {}) {
    opts = {
      codec: this.codec,
      hasher: this.hasher,
      getNode: this.getNode,
      compare: this.compare,
      cache: this.cache,
      ...opts
    };
    const nodeOptions = {
      chunker: this.chunker,
      opts
    };
    const results = this.entryList.findMany(bulk, opts.compare, true, this.isLeaf);
    if (this.isLeaf) {
      return await this.transactionLeaf(bulk, opts, nodeOptions, results);
    } else {
      return await this.transactionBranch(bulk, opts, nodeOptions, results);
    }
  }
  async transactionLeaf(bulk, opts, nodeOptions, results) {
    const { LeafClass: LeafClass2, LeafEntryClass } = opts;
    const { entries: entries4, previous } = this.processLeafEntries(bulk, results, LeafEntryClass, opts);
    const _opts = {
      ...nodeOptions,
      entries: entries4,
      NodeClass: LeafClass2,
      distance: 0
    };
    const nodes = await _Node.from(_opts);
    return {
      nodes,
      previous,
      blocks: await Promise.all(nodes.map(async (n) => {
        const block = await n.encode();
        this.cache.set(n);
        return {
          block,
          node: n
        };
      })),
      distance: 0
    };
  }
  processLeafEntries(bulk, results, LeafEntryClass, opts) {
    const previous = [];
    let entries4 = [];
    const changes = {};
    const deletes = /* @__PURE__ */ new Map();
    for (const { key, del: del2, value } of bulk) {
      const skey = stringKey(key);
      if (del2) {
        if (typeof changes[skey] === "undefined")
          deletes.set(skey, null);
      } else {
        changes[skey] = {
          key,
          value
        };
        deletes.delete(skey);
      }
    }
    entries4 = [...this.entryList.entries];
    for (const [i, [entry]] of results) {
      previous.push(entry);
      const skey = stringKey(entry.key);
      if (deletes.has(skey)) {
        deletes.set(skey, i);
      } else {
        entries4[i] = new LeafEntryClass(changes[skey], opts);
        delete changes[skey];
      }
    }
    let count = 0;
    for (const [, i] of deletes) {
      if (i !== null)
        entries4.splice(i - count++, 1);
    }
    const appends = Object.values(changes).map((obj) => new LeafEntryClass(obj, opts));
    entries4 = entries4.concat(appends).sort(({ key: a }, { key: b }) => opts.compare(a, b));
    return {
      entries: entries4,
      previous
    };
  }
  async transactionBranch(bulk, opts, nodeOptions, results) {
    const { BranchClass: BranchClass2, BranchEntryClass } = opts;
    let distance = 0;
    for (const [i, [entry, keys]] of results) {
      const p = this.getNode(await entry.address).then((node) => node.transaction(keys.reverse(), {
        ...opts,
        sorted: true
      })).then((r) => ({
        entry,
        keys,
        distance,
        ...r
      }));
      results.set(i, p);
    }
    let entries4 = [...this.entryList.entries];
    const final = {
      previous: [],
      blocks: [],
      nodes: []
    };
    for (const [i, p] of results) {
      const {
        nodes,
        previous,
        blocks,
        distance: _distance
      } = await p;
      distance = _distance;
      entries4[i] = nodes;
      if (previous.length)
        final.previous = final.previous.concat(previous);
      if (blocks.length)
        final.blocks = final.blocks.concat(blocks);
      if (nodes.length)
        final.nodes = final.nodes.concat(nodes);
    }
    entries4 = entries4.flat();
    const newEntries = await this.handlePrepend(entries4, opts, nodeOptions, final, distance);
    distance++;
    const toEntry = async (branch) => {
      if (branch.isEntry)
        return branch;
      const block = await branch.encode();
      final.blocks.push({
        block,
        node: branch
      });
      this.cache.set(branch);
      return new BranchEntryClass(branch, opts);
    };
    entries4 = await Promise.all(newEntries.map(toEntry));
    const _opts = {
      ...nodeOptions,
      entries: entries4,
      NodeClass: BranchClass2,
      distance
    };
    const newNodes = await _Node.from(_opts);
    await Promise.all(newNodes.map(async (n) => {
      const block = await n.encode();
      final.blocks.push({
        block,
        node: n
      });
      this.cache.set(n);
    }));
    final.nodes = newNodes;
    return {
      ...final,
      distance
    };
  }
  async handlePrepend(entries4, opts, nodeOptions, final, distance) {
    const { BranchClass: BranchClass2, LeafClass: LeafClass2 } = opts;
    let newEntries = [];
    let prepend = null;
    for (const entry of entries4) {
      if (prepend) {
        const mergeEntries = await this.mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance);
        prepend = null;
        const NodeClass = !mergeEntries[0].address ? LeafClass2 : BranchClass2;
        const _opts = {
          ...nodeOptions,
          entries: mergeEntries.sort(({ key: a }, { key: b }) => opts.compare(a, b)),
          NodeClass,
          distance
        };
        const nodes = await _Node.from(_opts);
        if (!nodes[nodes.length - 1].closed) {
          prepend = nodes.pop();
        }
        if (nodes.length) {
          newEntries = newEntries.concat(nodes);
        }
      } else {
        if (!entry.isEntry && !entry.closed) {
          prepend = entry;
        } else {
          newEntries.push(entry);
        }
      }
    }
    if (prepend) {
      newEntries.push(prepend);
    }
    return newEntries;
  }
  async getNodeFirstFromBlocks(blocks, addr) {
    for (const { block, node } of blocks) {
      if (await block.cid === addr)
        return node;
    }
    return await this.getNode(addr);
  }
  async mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance) {
    const opts = nodeOptions.opts;
    const { LeafClass: LeafClass2, BranchClass: BranchClass2, BranchEntryClass } = opts;
    if (entry.isEntry) {
      const addr = await entry.address;
      entry = await this.getNodeFirstFromBlocks(final.blocks, addr);
    }
    const es = entry.entryList.entries;
    if (!es.length)
      throw new Error("unreachable no entries");
    const basicMerge = (entries1, entries22) => {
      return entries1.concat(entries22);
    };
    const processNodesAndCreateEntries = async (nodes, final2, opts2) => {
      return await Promise.all(nodes.map(async (l) => {
        final2.blocks.push({
          block: await l.encode(),
          node: l
        });
        this.cache.set(l);
        return new BranchEntryClass({
          key: l.key,
          address: await l.address
        }, opts2);
      }));
    };
    if (es[0].constructor.name === prepend.entryList.entries[0].constructor.name) {
      return await basicMerge(prepend.entryList.entries, es);
    } else {
      const leftEntry = es.shift();
      if (!leftEntry)
        throw new Error("unreachable no left entry");
      if (!leftEntry.address)
        throw new Error("unreachable existing leaf, no leftEntry.address");
      const mergeLeftEntries = await this.mergeFirstLeftEntries(leftEntry, prepend, nodeOptions, final, distance - 1);
      const esf = es.shift();
      if (!esf) {
        return mergeLeftEntries;
      }
      if (!esf.address)
        throw new Error("unreachable existing leaf, no esf.address");
      const oldFront = await this.getNodeFirstFromBlocks(final.blocks, await esf.address);
      if (!oldFront.entryList.entries[0].address) {
        const leftLeafEntries = await basicMerge(mergeLeftEntries, oldFront.entryList.entries);
        const leftLeafNodes = await _Node.from({
          ...nodeOptions,
          entries: leftLeafEntries.sort(({ key: a }, { key: b }) => opts.compare(a, b)),
          NodeClass: LeafClass2,
          distance
        });
        const leftBranches = await processNodesAndCreateEntries(leftLeafNodes, final, opts);
        return await basicMerge(leftBranches, es);
      } else {
        if (mergeLeftEntries[0].address) {
          return mergeLeftEntries.concat(oldFront.entryList.entries);
        } else {
          const mergeLeftNodes = await _Node.from({
            ...nodeOptions,
            entries: mergeLeftEntries.sort(({ key: a }, { key: b }) => opts.compare(a, b)),
            NodeClass: LeafClass2,
            distance
          });
          const mergeLeftBranchEntries = await processNodesAndCreateEntries(mergeLeftNodes, final, opts);
          const newFirstNodes = await _Node.from({
            ...nodeOptions,
            entries: [
              ...oldFront.entryList.entries,
              ...mergeLeftBranchEntries,
              ...es
            ].sort(({ key: a }, { key: b }) => opts.compare(a, b)),
            NodeClass: BranchClass2,
            distance
          });
          const newBranchEntries = await processNodesAndCreateEntries(newFirstNodes, final, opts);
          return newBranchEntries;
        }
      }
    }
  }
  async bulk(bulk, opts = {}, isRoot = true) {
    const { BranchClass: BranchClass2 } = opts;
    opts = {
      codec: this.codec,
      hasher: this.hasher,
      getNode: this.getNode,
      compare: this.compare,
      cache: this.cache,
      ...opts
    };
    if (!opts.sorted) {
      bulk = sortBulk(bulk, opts);
      opts.sorted = true;
    }
    const nodeOptions = {
      chunker: this.chunker,
      opts
    };
    const results = await this.transaction(bulk, opts);
    while (results.nodes.length > 1) {
      const newDistance = results.nodes[0].distance + 1;
      const branchEntries = await Promise.all(results.nodes.map(async (node) => {
        const block = await node.encode();
        results.blocks.push({
          block,
          node
        });
        this.cache.set(node);
        return new opts.BranchEntryClass(node, opts);
      }));
      const newNodes = await _Node.from({
        ...nodeOptions,
        entries: branchEntries,
        NodeClass: BranchClass2,
        distance: newDistance
      });
      await Promise.all(newNodes.map(async (node) => {
        const block = await node.encode();
        this.cache.set(node);
        results.blocks.push({
          block,
          node
        });
      }));
      results.nodes = newNodes;
    }
    results.root = results.nodes[0];
    if (isRoot && results.root) {
      await processRoot(this, results, bulk, nodeOptions);
    }
    results.blocks = results.blocks.map(({ block }) => block);
    return results;
  }
  static async from({ entries: entries4, chunker, NodeClass, distance, opts }) {
    if (!entries4.every((entry) => entry.constructor.name === entries4[0].constructor.name))
      throw new Error("all entries must be of the same type");
    const parts = [];
    let chunk = [];
    for (const entry of entries4) {
      chunk.push(entry);
      if (await chunker(entry, distance)) {
        parts.push(new EntryList({
          entries: chunk,
          closed: true
        }));
        chunk = [];
      }
    }
    if (chunk.length) {
      parts.push(new EntryList({
        entries: chunk,
        closed: false
      }));
    }
    return parts.map((entryList) => new NodeClass({
      entryList,
      chunker,
      distance,
      ...opts
    }));
  }
};
var IPLDNode = class extends Node {
  constructor({ codec: codec2, hasher, block, ...opts }) {
    super(opts);
    this.codec = codec2;
    this.hasher = hasher;
    if (!block) {
      this.block = this.encode();
      this.address = this.block.then((block2) => block2.cid);
    } else {
      this.block = block;
      this.address = block.cid;
    }
  }
  async get(key) {
    const {
      result: entry,
      cids
    } = await this.getEntry(key);
    return {
      result: entry.key,
      cids
    };
  }
  async encode() {
    if (this.block)
      return this.block;
    const value = await this.encodeNode();
    const opts = {
      codec: this.codec,
      hasher: this.hasher,
      value
    };
    this.block = await encode8(opts);
    return this.block;
  }
};
var IPLDBranch = class extends IPLDNode {
  async encodeNode() {
    const { entries: entries4 } = this.entryList;
    const mapper = async (entry) => {
      if (!entry.address)
        throw new Error("entry.address required");
      return [
        entry.key,
        await entry.address
      ];
    };
    const list = await Promise.all(entries4.map(mapper));
    return {
      branch: [
        this.distance,
        list
      ],
      closed: this.closed
    };
  }
  get isBranch() {
    return true;
  }
};
var IPLDLeaf = class extends IPLDNode {
  async encodeNode() {
    const list = await Promise.all(this.entryList.entries.map(async (entry) => await entry.encodeNode()));
    return {
      leaf: list,
      closed: this.closed
    };
  }
  get isLeaf() {
    return true;
  }
};
var create2 = async function* (obj) {
  let { LeafClass: LeafClass2, LeafEntryClass, BranchClass: BranchClass2, BranchEntryClass, list, chunker, compare: compare5, ...opts } = obj;
  list = list.map((value) => new LeafEntryClass(value, opts));
  opts.compare = compare5;
  let nodes = await Node.from({
    entries: list,
    chunker,
    NodeClass: LeafClass2,
    distance: 0,
    opts
  });
  yield* nodes;
  let distance = 1;
  while (nodes.length > 1) {
    const mapper = async (node) => new BranchEntryClass({
      key: node.key,
      address: await node.address
    }, opts);
    const entries4 = await Promise.all(nodes.map(mapper));
    nodes = await Node.from({
      entries: entries4,
      chunker,
      NodeClass: BranchClass2,
      distance,
      opts
    });
    yield* nodes;
    distance++;
  }
};

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/map.js
var MapEntry = class extends Entry {
  async identity() {
    const encoded = await this.codec.encode(await this.encodeNode());
    const hash2 = await this.hasher.encode(encoded);
    return readUInt32LE(hash2);
  }
};
var MapLeafEntry = class extends MapEntry {
  constructor(node, opts) {
    super(node, opts);
    this.value = node.value;
  }
  encodeNode() {
    return [
      this.key,
      this.value
    ];
  }
};
var MapBranchEntry = class extends MapEntry {
  constructor(node, opts) {
    if (!node.address)
      throw new Error("Cannot create MapBranchEntry without address");
    super(node, opts);
  }
  async encodeNode() {
    return [
      this.key,
      await this.address
    ];
  }
};
var getValue = async (node, key) => {
  const {
    result: entry,
    cids
  } = await node.getEntry(key);
  return {
    result: entry.value,
    cids
  };
};
var getManyValues = async (node, keys) => {
  const {
    result: entries4,
    cids
  } = await node.getEntries(keys);
  return {
    result: entries4.map((entry) => entry.value),
    cids
  };
};
var MapLeaf = class extends IPLDLeaf {
  get(key) {
    return getValue(this, key);
  }
  getMany(keys) {
    return getManyValues(this, keys);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes,
      ...opts
    }, isRoot);
  }
};
var MapBranch = class extends IPLDBranch {
  get(key) {
    return getValue(this, key);
  }
  getMany(keys) {
    return getManyValues(this, keys);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes,
      ...opts
    }, isRoot);
  }
};
var classes = {
  LeafClass: MapLeaf,
  LeafEntryClass: MapLeafEntry,
  BranchClass: MapBranch,
  BranchEntryClass: MapBranchEntry
};
var createGetNode = (get4, cache3, chunker, codec2, hasher, compare5, opts) => {
  const LeafClass2 = opts.LeafClass || MapLeaf;
  const LeafEntryClass = opts.LeafEntryClass || MapLeafEntry;
  const BranchClass2 = opts.BranchClass || MapBranch;
  const BranchEntryClass = opts.BranchEntryClass || MapBranchEntry;
  const getNode = async (cid) => {
    if (cache3.has(cid))
      return cache3.get(cid);
    return get4(cid).then((block) => decoder2(block));
  };
  const decoder2 = makeDecoder({
    chunker,
    cache: cache3,
    getNode,
    codec: codec2,
    hasher,
    compare: compare5,
    LeafEntryClass,
    LeafClass: LeafClass2,
    BranchEntryClass,
    BranchClass: BranchClass2
  });
  return getNode;
};
var create3 = ({ get: get4, cache: cache3, chunker, list, codec: codec2, hasher, sorted, compare: compare5, ...opts }) => {
  if (!sorted)
    list = list.sort(({ key: a }, { key: b }) => compare5(a, b));
  const getNode = createGetNode(get4, cache3, chunker, codec2, hasher, compare5, opts);
  const _opts = {
    list,
    codec: codec2,
    hasher,
    chunker,
    getNode,
    sorted,
    compare: compare5,
    cache: cache3,
    LeafClass: opts.LeafClass || MapLeaf,
    LeafEntryClass: opts.LeafEntryClass || MapLeafEntry,
    BranchClass: opts.BranchClass || MapBranch,
    BranchEntryClass: opts.BranchEntryClass || MapBranchEntry
  };
  return create2(_opts);
};
var load = ({ cid, get: get4, cache: cache3, chunker, codec: codec2, hasher, compare: compare5, ...opts }) => {
  const getNode = createGetNode(get4, cache3, chunker, codec2, hasher, compare5, opts);
  return getNode(cid);
};
function makeDecoder({ chunker, cache: cache3, getNode, codec: codec2, hasher, compare: compare5, LeafEntryClass, LeafClass: LeafClass2, BranchEntryClass, BranchClass: BranchClass2 }) {
  const entryOpts = {
    codec: codec2,
    hasher
  };
  return (block) => {
    const { value } = block;
    const opts = {
      chunker,
      cache: cache3,
      block,
      getNode,
      codec: codec2,
      hasher,
      compare: compare5
    };
    let entries4;
    let CLS;
    if (value.leaf) {
      entries4 = value.leaf.map(([key, value2]) => new LeafEntryClass({
        key,
        value: value2
      }, entryOpts));
      CLS = LeafClass2;
    } else if (value.branch) {
      const [distance, _entries] = value.branch;
      opts.distance = distance;
      entries4 = _entries.map(([key, address]) => new BranchEntryClass({
        key,
        address
      }, entryOpts));
      CLS = BranchClass2;
    } else {
      throw new Error("Unknown block data, does not match schema");
    }
    const entryList = new EntryList({
      entries: entries4,
      closed: value.closed
    });
    const node = new CLS({
      entryList,
      ...opts
    });
    cache3.set(node);
    return node;
  };
}

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/db-index.js
var compare3 = (a, b) => {
  const [aKey, aRef] = a;
  const [bKey, bRef] = b;
  const comp = simpleCompare(aKey, bKey);
  if (comp !== 0)
    return comp;
  return refCompare(aRef, bRef);
};
var refCompare = (aRef, bRef) => {
  if (Number.isNaN(aRef))
    return -1;
  if (Number.isNaN(bRef))
    throw new Error("ref may not be Infinity or NaN");
  if (!Number.isFinite(aRef))
    return 1;
  return simpleCompare(aRef, bRef);
};
var getIndex = async (node, key) => {
  const start = [
    key,
    NaN
  ];
  const end = [
    key,
    Infinity
  ];
  const {
    result: entries4,
    cids
  } = await node.getRangeEntries(start, end);
  return {
    result: entries4.map((entry) => {
      const [key2, id] = entry.key;
      return {
        id,
        key: key2,
        row: entry.value
      };
    }),
    cids
  };
};
var getRange = async (node, start, end) => {
  start = [
    start,
    NaN
  ];
  end = [
    end,
    Infinity
  ];
  const {
    result: entries4,
    cids
  } = await node.getRangeEntries(start, end);
  const result = entries4.map((entry) => {
    const [key, id] = entry.key;
    return {
      id,
      key,
      row: entry.value
    };
  });
  return {
    result,
    cids
  };
};
var DBIndexLeaf = class extends MapLeaf {
  get(key) {
    return getIndex(this, key);
  }
  range(start, end) {
    return getRange(this, start, end);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes2,
      ...opts
    }, isRoot);
  }
};
var DBIndexBranch = class extends MapBranch {
  get(key) {
    return getIndex(this, key);
  }
  range(start, end) {
    return getRange(this, start, end);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes2,
      ...opts
    }, isRoot);
  }
};
var LeafClass = DBIndexLeaf;
var BranchClass = DBIndexBranch;
var classes2 = {
  LeafClass,
  BranchClass,
  LeafEntryClass: MapLeafEntry,
  BranchEntryClass: MapBranchEntry
};
var defaults = {
  ...classes2,
  compare: compare3
};
var create4 = (opts) => {
  opts = {
    ...defaults,
    ...opts
  };
  return create3(opts);
};
var load2 = (opts) => {
  opts = {
    ...defaults,
    ...opts
  };
  return load(opts);
};

// node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/cache.js
var nocache = {
  has: () => false,
  get: () => {
    throw new Error("Cannot ask for entries from nocache");
  },
  set: () => {
  }
};

// core/blockstore/store-factory.ts
init_esm();

// core/blockstore/store.ts
init_esm();
init_blockstore();
init_base2();

// node_modules/.pnpm/yocto-queue@1.2.2/node_modules/yocto-queue/index.js
var Node2 = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
};
var Queue = class {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    const node = new Node2(value);
    if (this.#head) {
      this.#tail.next = node;
      this.#tail = node;
    } else {
      this.#head = node;
      this.#tail = node;
    }
    this.#size++;
  }
  dequeue() {
    const current = this.#head;
    if (!current) {
      return;
    }
    this.#head = this.#head.next;
    this.#size--;
    if (!this.#head) {
      this.#tail = void 0;
    }
    return current.value;
  }
  peek() {
    if (!this.#head) {
      return;
    }
    return this.#head.value;
  }
  clear() {
    this.#head = void 0;
    this.#tail = void 0;
    this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
  *drain() {
    while (this.#head) {
      yield this.dequeue();
    }
  }
};

// vendor/p-limit/index.js
function pLimit(concurrency) {
  validateConcurrency(concurrency);
  const queue = new Queue();
  let activeCount = 0;
  const resumeNext = () => {
    if (activeCount < concurrency && queue.size > 0) {
      queue.dequeue()();
      activeCount++;
    }
  };
  const next = () => {
    activeCount--;
    resumeNext();
  };
  const run = async (function_, resolve, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  };
  const enqueue = (function_, resolve, arguments_) => {
    new Promise((internalResolve) => {
      queue.enqueue(internalResolve);
    }).then(run.bind(void 0, function_, resolve, arguments_));
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency) {
        resumeNext();
      }
    })();
  };
  const generator = (function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  });
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    },
    concurrency: {
      get: () => concurrency,
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue.size > 0) {
            resumeNext();
          }
        });
      }
    }
  });
  return generator;
}
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/decoder.js
init_src2();
init_cid();
init_digest();

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/decoder-common.js
var import_varint2 = __toESM(require_varint(), 1);
var CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
var V2_HEADER_LENGTH = (
  /* characteristics */
  16 + 8 + 8 + 8
);
function decodeVarint(bytes, seeker) {
  if (!bytes.length) {
    throw new Error("Unexpected end of data");
  }
  const i = import_varint2.default.decode(bytes);
  seeker.seek(
    /** @type {number} */
    import_varint2.default.decode.bytes
  );
  return i;
}
function decodeV2Header(bytes) {
  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    /** @type {[bigint, bigint]} */
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  return header;
}
function getMultihashLength(bytes) {
  import_varint2.default.decode(bytes);
  const codeLength = (
    /** @type {number} */
    import_varint2.default.decode.bytes
  );
  const length2 = import_varint2.default.decode(bytes.subarray(import_varint2.default.decode.bytes));
  const lengthLength = (
    /** @type {number} */
    import_varint2.default.decode.bytes
  );
  const mhLength = codeLength + lengthLength + length2;
  return mhLength;
}

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/header-validator.js
var Kinds = {
  Null: (
    /**
     * @param obj
     * @returns {undefined|null}
     */
    (obj) => obj === null ? obj : void 0
  ),
  Int: (
    /**
     * @param obj
     * @returns {undefined|number}
     */
    (obj) => Number.isInteger(obj) ? obj : void 0
  ),
  Float: (
    /**
     * @param obj
     * @returns {undefined|number}
     */
    (obj) => typeof obj === "number" && Number.isFinite(obj) ? obj : void 0
  ),
  String: (
    /**
     * @param obj
     * @returns {undefined|string}
     */
    (obj) => typeof obj === "string" ? obj : void 0
  ),
  Bool: (
    /**
     * @param obj
     * @returns {undefined|boolean}
     */
    (obj) => typeof obj === "boolean" ? obj : void 0
  ),
  Bytes: (
    /**
     * @param obj
     * @returns {undefined|Uint8Array}
     */
    (obj) => obj instanceof Uint8Array ? obj : void 0
  ),
  Link: (
    /**
     * @param obj
     * @returns {undefined|object}
     */
    (obj) => obj !== null && typeof obj === "object" && obj.asCID === obj ? obj : void 0
  ),
  List: (
    /**
     * @param obj
     * @returns {undefined|Array<any>}
     */
    (obj) => Array.isArray(obj) ? obj : void 0
  ),
  Map: (
    /**
     * @param obj
     * @returns {undefined|object}
     */
    (obj) => obj !== null && typeof obj === "object" && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : void 0
  )
};
var Types = {
  "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
  "CarV1HeaderOrV2Pragma > roots (anon)": (
    /**
     * @param obj
     * @returns {undefined|any}
     */
    (obj) => {
      if (Kinds.List(obj) === void 0) {
        return void 0;
      }
      for (let i = 0; i < obj.length; i++) {
        let v = obj[i];
        v = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
        if (v === void 0) {
          return void 0;
        }
        if (v !== obj[i]) {
          const ret = obj.slice(0, i);
          for (let j = i; j < obj.length; j++) {
            let v2 = obj[j];
            v2 = Types["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
            if (v2 === void 0) {
              return void 0;
            }
            ret.push(v2);
          }
          return ret;
        }
      }
      return obj;
    }
  ),
  Int: Kinds.Int,
  CarV1HeaderOrV2Pragma: (
    /**
     * @param obj
     * @returns {undefined|any}
     */
    (obj) => {
      if (Kinds.Map(obj) === void 0) {
        return void 0;
      }
      const entries4 = Object.entries(obj);
      let ret = obj;
      let requiredCount = 1;
      for (let i = 0; i < entries4.length; i++) {
        const [key, value] = entries4[i];
        switch (key) {
          case "roots":
            {
              const v = Types["CarV1HeaderOrV2Pragma > roots (anon)"](obj[key]);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries4[j][0]] = entries4[j][1];
                  }
                }
                ret.roots = v;
              }
            }
            break;
          case "version":
            {
              requiredCount--;
              const v = Types.Int(obj[key]);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries4[j][0]] = entries4[j][1];
                  }
                }
                ret.version = v;
              }
            }
            break;
          default:
            return void 0;
        }
      }
      if (requiredCount > 0) {
        return void 0;
      }
      return ret;
    }
  )
};
var Reprs = {
  "CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)": Kinds.Link,
  "CarV1HeaderOrV2Pragma > roots (anon)": (
    /**
     * @param obj
     * @returns {undefined|any}
     */
    (obj) => {
      if (Kinds.List(obj) === void 0) {
        return void 0;
      }
      for (let i = 0; i < obj.length; i++) {
        let v = obj[i];
        v = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v);
        if (v === void 0) {
          return void 0;
        }
        if (v !== obj[i]) {
          const ret = obj.slice(0, i);
          for (let j = i; j < obj.length; j++) {
            let v2 = obj[j];
            v2 = Reprs["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](v2);
            if (v2 === void 0) {
              return void 0;
            }
            ret.push(v2);
          }
          return ret;
        }
      }
      return obj;
    }
  ),
  Int: Kinds.Int,
  CarV1HeaderOrV2Pragma: (
    /**
     * @param obj
     * @returns {undefined|any}
     */
    (obj) => {
      if (Kinds.Map(obj) === void 0) {
        return void 0;
      }
      const entries4 = Object.entries(obj);
      let ret = obj;
      let requiredCount = 1;
      for (let i = 0; i < entries4.length; i++) {
        const [key, value] = entries4[i];
        switch (key) {
          case "roots":
            {
              const v = Reprs["CarV1HeaderOrV2Pragma > roots (anon)"](value);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries4[j][0]] = entries4[j][1];
                  }
                }
                ret.roots = v;
              }
            }
            break;
          case "version":
            {
              requiredCount--;
              const v = Reprs.Int(value);
              if (v === void 0) {
                return void 0;
              }
              if (v !== value || ret !== obj) {
                if (ret === obj) {
                  ret = {};
                  for (let j = 0; j < i; j++) {
                    ret[entries4[j][0]] = entries4[j][1];
                  }
                }
                ret.version = v;
              }
            }
            break;
          default:
            return void 0;
        }
      }
      if (requiredCount > 0) {
        return void 0;
      }
      return ret;
    }
  )
};
var CarV1HeaderOrV2Pragma = {
  toTyped: Types.CarV1HeaderOrV2Pragma,
  toRepresentation: Reprs.CarV1HeaderOrV2Pragma
};

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/decoder.js
async function readHeader(reader, strictVersion) {
  const length2 = decodeVarint(await reader.upTo(8), reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length2, true);
  const block = decode12(header);
  if (CarV1HeaderOrV2Pragma.toTyped(block) === void 0) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  if (block.version === 1) {
    if (!Array.isArray(block.roots)) {
      throw new Error("Invalid CAR header format");
    }
    return block;
  }
  if (block.roots !== void 0) {
    throw new Error("Invalid CAR header format");
  }
  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true));
  reader.seek(v2Header.dataOffset - reader.pos);
  const v1Header = await readHeader(reader, 1);
  return Object.assign(v1Header, v2Header);
}
async function readCid(reader) {
  const first = await reader.exactly(2, false);
  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {
    const bytes2 = await reader.exactly(34, true);
    const multihash2 = decode5(bytes2);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = decodeVarint(await reader.upTo(8), reader);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec2 = decodeVarint(await reader.upTo(8), reader);
  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true);
  const multihash = decode5(bytes);
  return CID.create(version2, codec2, multihash);
}
async function readBlockHead(reader) {
  const start = reader.pos;
  let length2 = decodeVarint(await reader.upTo(8), reader);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader.pos - start;
  const cid = await readCid(reader);
  const blockLength2 = length2 - Number(reader.pos - start);
  return { cid, length: length2, blockLength: blockLength2 };
}
async function readBlock(reader) {
  const { cid, blockLength: blockLength2 } = await readBlockHead(reader);
  const bytes = await reader.exactly(blockLength2, true);
  return { bytes, cid };
}
async function readBlockIndex(reader) {
  const offset = reader.pos;
  const { cid, length: length2, blockLength: blockLength2 } = await readBlockHead(reader);
  const index2 = { cid, length: length2, blockLength: blockLength2, offset, blockOffset: reader.pos };
  reader.seek(index2.blockLength);
  return index2;
}
function createDecoder(reader) {
  const headerPromise = (async () => {
    const header = await readHeader(reader);
    if (header.version === 2) {
      const v1length = reader.pos - header.dataOffset;
      reader = limitReader(reader, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader(bytes) {
  let pos = 0;
  return {
    async upTo(length2) {
      const out = bytes.subarray(pos, pos + Math.min(length2, bytes.length - pos));
      return out;
    },
    async exactly(length2, seek = false) {
      if (length2 > bytes.length - pos) {
        throw new Error("Unexpected end of data");
      }
      const out = bytes.subarray(pos, pos + length2);
      if (seek) {
        pos += length2;
      }
      return out;
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = (
      /** @type {Uint8Array<ArrayBufferLike>[]} */
      [currentChunk.subarray(offset)]
    );
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2, seek = false) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      const out = currentChunk.subarray(offset, offset + length2);
      if (seek) {
        pos += length2;
        offset += length2;
      }
      return out;
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length2) {
      let bytes = await reader.upTo(length2);
      if (bytes.length + bytesRead > byteLimit) {
        bytes = bytes.subarray(0, byteLimit - bytesRead);
      }
      return bytes;
    },
    async exactly(length2, seek = false) {
      const bytes = await reader.exactly(length2, seek);
      if (bytes.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      if (seek) {
        bytesRead += length2;
      }
      return bytes;
    },
    seek(length2) {
      bytesRead += length2;
      reader.seek(length2);
    },
    get pos() {
      return reader.pos;
    }
  };
}

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/reader-browser.js
var CarReader = class {
  /**
   * @constructs CarReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */
  constructor(header, blocks) {
    this._header = header;
    this._blocks = blocks;
    this._keys = blocks.map((b) => b.cid.toString());
  }
  /**
   * @property
   * @memberof CarReader
   * @instance
   */
  get version() {
    return this._header.version;
  }
  /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */
  async getRoots() {
    return this._header.roots;
  }
  /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<boolean>}
   */
  async has(key) {
    return this._keys.indexOf(key.toString()) > -1;
  }
  /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<Block | undefined>}
   */
  async get(key) {
    const index2 = this._keys.indexOf(key.toString());
    return index2 > -1 ? this._blocks[index2] : void 0;
  }
  /**
   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<Block>}
   */
  async *blocks() {
    for (const block of this._blocks) {
      yield block;
    }
  }
  /**
   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
   * the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<CID>}
   */
  async *cids() {
    for (const block of this._blocks) {
      yield block.cid;
    }
  }
  /**
   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {Uint8Array} bytes
   * @returns {Promise<CarReader>}
   */
  static async fromBytes(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeReaderComplete(bytesReader(bytes));
  }
  /**
   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * This performs a decode fully in memory and maintains the decoded state in
   * memory for full access to the data via the `CarReader` API.
   *
   * Care should be taken for large archives; this API may not be appropriate
   * where memory is a concern or the archive is potentially larger than the
   * amount of memory that the runtime can handle.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarReader>}
   */
  static async fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeReaderComplete(asyncIterableReader(asyncIterable));
  }
};
async function decodeReaderComplete(reader) {
  const decoder2 = createDecoder(reader);
  const header = await decoder2.header();
  const blocks = [];
  for await (const block of decoder2.blocks()) {
    blocks.push(block);
  }
  return new CarReader(header, blocks);
}

// core/blockstore/loader.ts
init_esm();
init_blockstore();

// core/keybag/key-bag-fingerprint-item.ts
init_esm();

// core/keybag/internal-keys-by-fingerprint.ts
init_esm();
init_runtime2();
init_base2();

// core/keybag/key-with-fingerprint.ts
init_esm();
init_base58();
function coerceMaterial(kb, material) {
  let keyMaterial;
  if (typeof material === "string") {
    keyMaterial = base58btc.decode(material);
  } else if (material instanceof Uint8Array) {
    keyMaterial = material;
  } else {
    throw kb.logger.Error().Msg("material must be string or Uint8Array").AsError();
  }
  return {
    key: keyMaterial,
    keyStr: base58btc.encode(keyMaterial)
  };
}
async function toKeyWithFingerPrint(keybag, material, def) {
  const key = await keybag.subtleKey(material.key);
  const fpr = base58btc.encode(new Uint8Array(await keybag.rt.crypto.digestSHA256(material.key)));
  return Result.Ok(
    new InternalKeyWithFingerPrint({
      fingerPrint: fpr,
      key,
      material,
      default: def
    })
  );
}
function coerceFingerPrint(kb, fingerPrint) {
  if (fingerPrint instanceof Uint8Array) {
    fingerPrint = base58btc.encode(fingerPrint);
  }
  return fingerPrint;
}
var InternalKeyWithFingerPrint = class {
  default;
  fingerPrint;
  key;
  #material;
  constructor(opt) {
    this.fingerPrint = opt.fingerPrint;
    this.default = opt.default;
    this.key = opt.key;
    this.#material = opt.material;
  }
  setDefault(def) {
    this.default = def;
  }
  extract() {
    if (this.key.extractable) {
      return Promise.resolve(this.#material);
    }
    throw new Error("Key is not extractable");
  }
  async asKeysItem() {
    return {
      default: this.default,
      fingerPrint: this.fingerPrint,
      key: this.#material.keyStr
    };
  }
};

// core/keybag/internal-keys-by-fingerprint.ts
init_base58();

// core/keybag/coerce-keyed-item.ts
init_base2();
async function toV2KeysItem(ctx, ki) {
  if (!ki.name) {
    throw ctx.logger.Error().Msg("toV2KeysItem: name is missing").AsError();
  }
  if ("key" in ki && ki.key && ki.name) {
    const fpr = (await toKeyWithFingerPrint(ctx.keybag, coerceMaterial(ctx.keybag, ki.key), true)).Ok().fingerPrint;
    return {
      modified: true,
      id: ki.name,
      clazz: "V2StorageKeyItem",
      item: {
        name: ki.name,
        keys: {
          [fpr]: {
            key: ki.key,
            fingerPrint: fpr,
            default: true
          }
        }
      }
    };
  }
  let defKI;
  let foundDefKI = false;
  let result;
  if ("keys" in ki && ki.keys) {
    result = {
      name: ki.name,
      keys: ki.keys
    };
  } else {
    result = {
      name: ki.name,
      keys: {}
    };
  }
  for (const i of Object.entries(result.keys)) {
    if (i[0] !== i[1].fingerPrint) {
      delete result.keys[i[0]];
      result.keys[i[1].fingerPrint] = i[1];
      ctx.logger.Warn().Str("name", ki.name).Msg("fingerPrint mismatch fixed");
    }
    if (defKI === void 0) {
      defKI = i[1];
    }
    if (!foundDefKI && i[1].default) {
      defKI = i[1];
      foundDefKI = true;
    } else {
      i[1].default = false;
    }
  }
  return {
    id: result.name,
    clazz: "V2StorageKeyItem",
    item: result
  };
}
async function coerceKeyedItem(ctx, item) {
  if (!item) {
    return void 0;
  }
  if ("clazz" in item) {
    const r = KeyedItemSchema.safeParse(item);
    return r.success ? item : void 0;
  }
  function isV1StorageKeyItem(item2) {
    if (!item2) {
      return false;
    }
    const r = V1StorageKeyItemSchema.safeParse(item2);
    return r.success;
  }
  function isV2StorageKeysItem(item2) {
    return !!item2.keys;
  }
  if (isV1StorageKeyItem(item)) {
    return toV2KeysItem(ctx, item);
  }
  if (isV2StorageKeysItem(item)) {
    return {
      id: item.name,
      clazz: "V2StorageKeyItem",
      item
    };
  }
  return void 0;
}

// core/keybag/internal-keys-by-fingerprint.ts
init_v4();
function isInternalKeyUpsertResult(i) {
  return i.result.isOk() && isKeyUpsertResultModified(i.result.Ok());
}
var InternalKeysByFingerprint = class _InternalKeysByFingerprint {
  keybag;
  name;
  id;
  // readonly lookUp = new KeyedResolvOnce<InternalKeyWithFingerPrint>();
  lookup = /* @__PURE__ */ new Map();
  // readonly keysItem: InternalKeysItem;
  logger;
  async ensureMaterial(materialStrOrUint8, opts) {
    if (!materialStrOrUint8) {
      return Result.Ok(this);
    }
    const r = await this.upsert(materialStrOrUint8, opts);
    if (r.isErr()) {
      return Result.Err(r);
    }
    return Result.Ok(this);
  }
  // implicit migration from V1 to V2
  async toKeysItem(ki) {
    return Promise.all(
      Array.from(Object.values(ki.keys)).map(async (i) => ({
        keyMaterial: i.key,
        keyWithFingerPrint: new InternalKeyWithFingerPrint({
          fingerPrint: i.fingerPrint,
          key: await this.keybag.subtleKey(i.key),
          material: { key: base58btc.decode(i.key), keyStr: i.key },
          default: i.default || false
        })
      }))
      // [
      //   i.fingerPrint,
      //   await this.keybag.subtleKey(i.key),
      //   { key: base58btc.decode(i.key), keyStr: i.key },
      //   i.default || false,
      // ] satisfies [string, CTCryptoKey, KeyMaterial, boolean],
    );
  }
  // is assuming it will not called concurrent or multiple per name
  async load(opts) {
    const oProvKeysResult = await this.keybag.getRawObj(this.name);
    if (oProvKeysResult.IsNone() && opts.failIfNotFound) {
      return this.logger.Debug().Msg("failIfNotFound getRawObj").ResultError();
    }
    if (oProvKeysResult.IsSome() && !oProvKeysResult.unwrap().success) {
      const tsHelp = oProvKeysResult.unwrap();
      if (!tsHelp.success) {
        return this.logger.Error().Any({ error: external_exports.formatError(tsHelp.error) }).Msg("not LegacyKeyItem").ResultError();
      }
    }
    let loadedMaterial = void 0;
    let doNotWrite = false;
    if (oProvKeysResult.IsSome()) {
      const provKeysResult = oProvKeysResult.unwrap();
      const cki = await coerceKeyedItem(this, provKeysResult.data);
      if (!cki) {
        return this.logger.Error().Any({ item: provKeysResult.data }).Msg("coerce error").ResultError();
      }
      const v2StorageResult = KeyedV2StorageKeyItemSchema.safeParse(cki);
      if (!v2StorageResult.success) {
        return this.logger.Error().Any({ name: this.name, item: provKeysResult.data, error: external_exports.formatError(v2StorageResult.error) }).Msg("not V2KeysItems").ResultError();
      }
      doNotWrite = true;
      const kis = await this.toKeysItem(v2StorageResult.data.item).then(
        (items) => items.map(
          async ({ keyMaterial, keyWithFingerPrint }, idx) => Promise.resolve({
            keyMaterial,
            result: await this.upsert(keyMaterial, {
              def: keyWithFingerPrint.default,
              modified: cki.modified && idx === items.length - 1,
              doNotWrite
            })
          })
        )
      ).then((items) => Promise.all(items)).then((items) => items.filter((i) => isInternalKeyUpsertResult(i)));
      if (kis.length !== 0) {
        const defaultKey = kis.find((i) => i.result.Ok().kfp.default);
        if (defaultKey) {
          loadedMaterial = defaultKey.keyMaterial;
        }
      }
    }
    return this.ensureMaterial(
      opts.materialStrOrUint8 ?? loadedMaterial ?? this.keybag.rt.crypto.randomBytes(this.keybag.rt.keyLength),
      { def: true, doNotWrite }
    );
  }
  static async from(kbo) {
    const kbf = new _InternalKeysByFingerprint(kbo.keybag, kbo.name);
    return kbf.load(kbo.opts);
  }
  constructor(keyBag, name2) {
    this.id = keyBag.rt.sthis.nextId().str;
    this.logger = ensureLogger(keyBag.rt.sthis, `InternalKeysByFingerprint:${name2}:${this.id}`);
    this.keybag = keyBag;
    this.name = name2;
  }
  async get(fingerPrint) {
    fingerPrint = coerceFingerPrint(this.keybag, fingerPrint) || "*";
    const ret = this.lookup.get(fingerPrint);
    if (!ret) {
      this.keybag.logger.Warn().Any({ fprs: Array.from(this.lookup.values()).map((i) => i.fingerPrint), fpr: fingerPrint }).Msg("keysByFingerprint:get: not found");
    }
    return ret;
  }
  async upsert(materialStrOrUint8, { def, doNotWrite, modified } = {}) {
    const rKur = await this.upsertNoStore(materialStrOrUint8, def);
    if (rKur.isErr()) {
      return Result.Err(rKur);
    }
    if (!doNotWrite && (rKur.Ok().modified || modified)) {
      await this.keybag.setRawObj({
        id: this.name,
        clazz: "V2StorageKeyItem",
        item: await this.asV2StorageKeyItem()
      });
    }
    return rKur;
  }
  async upsertNoStore(materialStrOrUint8, def) {
    if (!materialStrOrUint8) {
      return Result.Ok({
        modified: false
      });
    }
    const material = coerceMaterial(this.keybag, materialStrOrUint8);
    def = !!def;
    const rKfp = await toKeyWithFingerPrint(this.keybag, material, def);
    if (rKfp.isErr()) {
      return Result.Err(rKfp);
    }
    const kfp = rKfp.Ok();
    const preHash = hashObjectSync(await this.asV2StorageKeyItem());
    let found = this.lookup.get(kfp.fingerPrint);
    if (found) {
      if (found.default === def) {
        return Result.Ok({
          modified: false,
          kfp: found
        });
      }
    } else {
      found = new InternalKeyWithFingerPrint({
        default: def,
        fingerPrint: kfp.fingerPrint,
        key: kfp.key,
        material
      });
    }
    this.lookup.set(found.fingerPrint, found);
    const keyItems = Array.from(this.lookup.values());
    if (def) {
      for (const i of keyItems) {
        if (i.default && i.fingerPrint !== kfp.fingerPrint) {
          i.setDefault(false);
        }
      }
    }
    if (def || keyItems.length === 0) {
      found.setDefault(true);
      this.lookup.set("*", found);
    }
    const postHash = hashObjectSync(await this.asV2StorageKeyItem());
    return Result.Ok({
      modified: preHash !== postHash,
      kfp: found
    });
  }
  async asV2StorageKeyItem() {
    const kis = await Promise.all(
      Array.from(this.lookup.entries()).filter(([i]) => i !== "*").map(([_, v]) => v.asKeysItem())
    );
    return Promise.resolve({
      name: this.name,
      keys: kis.reduce(
        (acc, i) => {
          acc[i.fingerPrint] = i;
          return acc;
        },
        {}
      )
    });
  }
  // async extract() {
  //   const ext = new Uint8Array((await this.rt.crypto.exportKey("raw", named.key)) as ArrayBuffer);
  //   return {
  //     key: ext,
  //     keyStr: base58btc.encode(ext),
  //   };
  // }
};

// core/keybag/key-bag-fingerprint-item.ts
var InternalKeyBagFingerprintItem = class {
  name;
  keybag;
  keysByFingerprint = new ResolveOnce();
  constructor(keybag, name2) {
    this.keybag = keybag;
    this.name = name2;
  }
  async getNamedKey(opts) {
    return this.keysByFingerprint.once(async () => {
      return InternalKeysByFingerprint.from({ keybag: this.keybag, opts, name: this.name });
    }).then((r) => {
      if (r.isErr()) {
        this.keysByFingerprint.reset();
        return r;
      }
      return r.Ok().ensureMaterial(opts.materialStrOrUint8, {});
    });
  }
};

// core/keybag/key-bag-memory.ts
var memoryKeyBag = /* @__PURE__ */ new Map();
var KeyBagProviderMemory = class {
  url;
  sthis;
  constructor(url2, sthis) {
    this.url = url2;
    this.sthis = sthis;
  }
  key(id) {
    return `${this.url.pathname}/${id}`;
  }
  // async _prepare(id: string): Promise<KeyBagCtx> {
  //   await this.sthis.start();
  //   const sysFS = await sysFileSystemFactory(this.url);
  //   const dirName = this.url.pathname;
  //   await sysFS.mkdir(dirName, { recursive: true });
  //   return {
  //     dirName,
  //     sysFS,
  //     fName: this.sthis.pathOps.join(dirName, `${id.replace(/[^a-zA-Z0-9]/g, "_")}.json`),
  //   };
  // }
  del(id) {
    const key = this.key(id);
    if (memoryKeyBag.has(key)) {
      memoryKeyBag.delete(key);
    }
    return Promise.resolve();
  }
  async get(id) {
    const binKeyItem = memoryKeyBag.get(this.key(id));
    if (binKeyItem) {
      try {
        const ki = JSON.parse(this.sthis.txt.decode(binKeyItem));
        return ki;
      } catch (e) {
      }
    }
    return void 0;
  }
  async set(id, item) {
    const p = this.sthis.txt.encode(JSON.stringify(item, null, 2));
    memoryKeyBag.set(this.key(id), p);
  }
};

// core/keybag/key-bag-setup.ts
init_esm();

// core/gateways/file/key-bag-file.ts
init_base2();

// core/gateways/file/sys-file-system-factory.ts
init_esm();
function sysFileSystemFactory(uri) {
  const rt = runtimeFn();
  switch (true) {
    case rt.isNodeIsh:
      return Promise.resolve().then(() => (init_file_node(), file_node_exports)).then((m) => m.getSysFileSystem(uri));
    case rt.isDeno:
      return Promise.resolve().then(() => (init_file_deno(), file_deno_exports)).then((m) => m.getSysFileSystem(uri));
    default:
      throw new Error(`unsupported runtime:${rt}`);
  }
}

// core/gateways/file/key-bag-file.ts
var KeyBagProviderFile = class {
  async _prepare(id) {
    await this.sthis.start();
    const sysFS = await sysFileSystemFactory(this.url);
    const dirName = this.url.pathname;
    await sysFS.mkdir(dirName, { recursive: true });
    return {
      dirName,
      sysFS,
      fName: this.sthis.pathOps.join(dirName, `${id.replace(/[^a-zA-Z0-9]/g, "_")}.json`)
    };
  }
  url;
  logger;
  sthis;
  constructor(url2, sthis) {
    this.url = url2;
    this.sthis = sthis;
    this.logger = sthis.logger;
  }
  async del(id) {
    const ctx = await this._prepare(id);
    try {
      await ctx.sysFS.unlink(ctx.fName);
    } catch (e) {
      if (isNotFoundError(e)) {
        return;
      }
      throw this.logger.Error().Err(e).Any("file", ctx).Msg("delete bag failed").AsError();
    }
  }
  async get(id) {
    const ctx = await this._prepare(id);
    try {
      const p = await ctx.sysFS.readfile(ctx.fName);
      const ki = JSON.parse(this.sthis.txt.decode(p));
      return ki;
    } catch (e) {
      if (isNotFoundError(e)) {
        return void 0;
      }
      throw this.logger.Error().Err(e).Any("file", ctx).Msg("read bag failed").AsError();
    }
  }
  async set(id, item) {
    const ctx = await this._prepare(id);
    const p = this.sthis.txt.encode(JSON.stringify(item, null, 2));
    await ctx.sysFS.writefile(ctx.fName, p);
  }
};

// core/gateways/file/version.ts
var FILESTORE_VERSION = "v0.19-file";

// core/gateways/file/gateway-impl.ts
init_esm();
init_base3();
init_base2();
init_runtime2();
var versionFiles = new KeyedResolvOnce();
var FileGateway = class {
  // abstract readonly storeType: StoreType;
  fs;
  constructor(sthis, fs) {
    this.fs = fs;
  }
  async getVersionFromFile(path, sthis) {
    return versionFiles.get(path).once(async () => {
      await this.fs.mkdir(path, { recursive: true });
      const vFile = sthis.pathOps.join(path, "version");
      const vFileStat = await this.fs.stat(vFile).catch(() => void 0);
      if (!vFileStat) {
        await this.fs.writefile(sthis.pathOps.join(path, "version"), FILESTORE_VERSION);
        return FILESTORE_VERSION;
      } else if (!vFileStat.isFile()) {
        throw sthis.logger.Error().Str("file", vFile).Msg(`version file is a directory`).AsError();
      }
      const v = await this.fs.readfile(vFile);
      const vStr = sthis.txt.decode(v);
      if (vStr !== FILESTORE_VERSION) {
        sthis.logger.Warn().Str("file", vFile).Str("from", vStr).Str("expected", FILESTORE_VERSION).Msg(`version mismatch`);
      }
      return vStr;
    });
  }
  start(baseURL, sthis) {
    return exception2Result(async () => {
      await this.fs.start();
      const url2 = baseURL.build();
      url2.defParam(PARAM.VERSION, FILESTORE_VERSION);
      const dbUrl = await this.buildUrl(url2.URI(), "dummy");
      const dbdirFile = this.getFilePath(dbUrl.Ok(), sthis);
      await this.fs.mkdir(sthis.pathOps.dirname(dbdirFile), { recursive: true });
      const dbroot = sthis.pathOps.dirname(dbdirFile);
      sthis.logger.Debug().Url(url2.URI()).Str("dbroot", dbroot).Msg("start");
      url2.setParam(PARAM.VERSION, await this.getVersionFromFile(dbroot, sthis));
      return url2.URI();
    });
  }
  async buildUrl(baseUrl, key) {
    return Result.Ok(baseUrl.build().setParam(PARAM.KEY, key).URI());
  }
  async close() {
    return Result.Ok(void 0);
  }
  getFilePath(url2, sthis) {
    const key = url2.getParam(PARAM.KEY);
    if (!key) throw sthis.logger.Error().Url(url2).Msg(`key not found`).AsError();
    return sthis.pathOps.join(getPath(url2, sthis), getFileName(url2, sthis));
  }
  async put(url2, bytes, sthis) {
    return exception2Result(async () => {
      const file2 = await this.getFilePath(url2, sthis);
      sthis.logger.Debug().Str("url", url2.toString()).Str("file", file2).Msg("put");
      await this.fs.writefile(file2, bytes);
    });
  }
  async get(url2, sthis) {
    return exceptionWrapper(async () => {
      const file2 = this.getFilePath(url2, sthis);
      try {
        sthis.logger.Debug().Url(url2).Str("file", file2).Msg("get");
        const res = await this.fs.readfile(file2);
        return Result.Ok(res);
      } catch (e) {
        if (isNotFoundError(e)) {
          return Result.Err(new NotFoundError(`file not found: ${file2}`));
        }
        return Result.Err(e);
      }
    });
  }
  async delete(url2, sthis) {
    return exception2Result(async () => {
      await this.fs.unlink(this.getFilePath(url2, sthis));
    });
  }
  async destroy(baseURL, sthis) {
    const url2 = await this.buildUrl(baseURL, "x");
    if (url2.isErr()) return url2;
    const filepath = sthis.pathOps.dirname(this.getFilePath(url2.Ok(), sthis));
    let files = [];
    try {
      files = await this.fs.readdir(filepath);
    } catch (e) {
      if (!isNotFoundError(e)) {
        throw sthis.logger.Error().Err(e).Str("dir", filepath).Msg("destroy:readdir").AsError();
      }
    }
    for (const file2 of files) {
      const pathed = sthis.pathOps.join(filepath, file2);
      try {
        await this.fs.unlink(pathed);
      } catch (e) {
        if (!isNotFoundError(e)) {
          throw sthis.logger.Error().Err(e).Str("file", pathed).Msg("destroy:unlink").AsError();
        }
      }
    }
    return Result.Ok(void 0);
  }
  async getPlain(iurl, key, sthis) {
    const url2 = iurl.build().setParam(PARAM.KEY, key).URI();
    const dbFile = sthis.pathOps.join(getPath(url2, sthis), getFileName(url2, sthis));
    sthis.logger.Debug().Url(url2).Str("dbFile", dbFile).Msg("get");
    const buffer3 = await this.fs.readfile(dbFile);
    sthis.logger.Debug().Url(url2).Str("dbFile", dbFile).Len(buffer3).Msg("got");
    return Result.Ok(buffer3);
  }
};

// core/keybag/key-bag-setup.ts
init_runtime2();
init_base2();

// core/keybag/key-bag.ts
init_esm();
init_runtime2();
init_base2();
init_base58();
init_webapi();
var deviceIdKey = hashStringSync("FIREProof:deviceId");
var NamedKeyItem = class {
  seq = new ResolveSeq();
  namedItem;
  constructor(namedItem) {
    this.namedItem = namedItem;
  }
};
var namedKeyItemsPerUrl = /* @__PURE__ */ new Map();
var KeyBag = class _KeyBag {
  logger;
  rt;
  #namedKeyItems;
  static async create(rt) {
    const urlHash = await hashStringAsync(rt.url.toJSON());
    const namedKeyItems = namedKeyItemsPerUrl.get(urlHash) ?? new KeyedResolvOnce();
    return new _KeyBag(rt, namedKeyItems);
  }
  constructor(rt, namedKeyItems) {
    this.logger = ensureLogger(rt.sthis, "KeyBag");
    this.rt = rt;
    this.#namedKeyItems = namedKeyItems;
  }
  hash() {
    return this.rt.id();
  }
  _warnOnce = new ResolveOnce();
  async subtleKey(materialStrOrUint8) {
    const extractable = this.rt.url.getParam(PARAM.EXTRACTKEY) === "_deprecated_internal_api";
    if (extractable) {
      this._warnOnce.once(() => {
        this.logger.Warn().Msg("extractKey is enabled via _deprecated_internal_api --- handle keys safely!!!");
      });
    }
    let material;
    if (typeof materialStrOrUint8 === "string") {
      material = base58btc.decode(materialStrOrUint8);
    } else {
      material = materialStrOrUint8;
    }
    return await this.rt.crypto.importKey(
      "raw",
      // raw or jwk
      material,
      // hexStringToUint8Array(key), // raw data
      "AES-GCM",
      extractable,
      ["encrypt", "decrypt"]
    );
  }
  async ensureKeyFromUrl(url2, keyFactory) {
    const storeKey = url2.getParam(PARAM.STORE_KEY);
    if (storeKey === "insecure") {
      return Result.Ok(url2);
    }
    if (!storeKey) {
      const keyName = `@${keyFactory()}@`;
      const ret = await this.getNamedKey(keyName);
      if (ret.isErr()) {
        return Result.Err(ret);
      }
      const urb = url2.build().setParam(PARAM.STORE_KEY, keyName);
      return Result.Ok(urb.URI());
    }
    if (storeKey.startsWith("@") && storeKey.endsWith("@")) {
      const ret = await this.getNamedKey(storeKey);
      if (ret.isErr()) {
        return Result.Err(ret);
      }
    }
    return Result.Ok(url2);
  }
  async getDeviceId() {
    const id = deviceIdKey;
    return this.#namedKeyItems.get(id).once(async () => {
      const raw = await this.provider().then((p) => p.get(id));
      const r = KeyedDeviceIdKeyBagItemSchema.safeParse(raw);
      let error48 = void 0;
      if (!r.success) {
        error48 = r.error;
        return {
          deviceId: Option.None(),
          cert: Option.None(),
          error: error48
        };
      }
      return {
        deviceId: Option.Some(r.data.item.deviceId),
        cert: Option.From(r.data.item.cert),
        error: error48
      };
    });
  }
  async setDeviceId(_deviceId, _cert) {
    const id = deviceIdKey;
    this.#namedKeyItems.unget(id);
    return this.#namedKeyItems.get(id).once(async () => {
      await this.provider().then(
        (p) => p.set(id, {
          id,
          clazz: "DeviceIdKeyBagItem",
          item: {
            deviceId: _deviceId,
            cert: _cert
          }
        })
      );
      const ret = {
        deviceId: Option.Some(_deviceId),
        cert: Option.From(_cert)
      };
      return ret;
    });
  }
  setJwt(name2, jwtStr) {
    return this.#namedKeyItems.get(name2).once(() => {
      return exception2Result(
        () => this.provider().then((prov) => {
          const item = {
            id: name2,
            clazz: "JwtKeyBagItem",
            item: {
              jwtStr
            }
          };
          return prov.set(name2, item).then((_) => item);
        })
      );
    });
  }
  async getJwt(name2, key, opts) {
    if (this.#namedKeyItems.has(name2)) {
      const ret = await this.#namedKeyItems.get(name2).once(() => {
        throw new Error("Should never called");
      });
      const p = KeyedJwtKeyBagItemSchema.safeParse(ret.Ok());
      if (!p.success) {
        return Result.Err(p.error);
      }
      let claims = void 0;
      try {
        if (key) {
          claims = await jwtVerify(p.data.item.jwtStr, key, opts);
        } else {
          claims = decodeJwt(p.data.item.jwtStr);
        }
      } catch (e) {
      }
      return Result.Ok({
        key: name2,
        jwt: p.data.item.jwtStr,
        claims
      });
    }
    return this.logger.Error().Str("name", name2).Msg("not found").ResultError();
  }
  async delete(name2) {
    if (this.#namedKeyItems.has(name2)) {
      await this.provider().then((p) => p.del(name2));
      this.#namedKeyItems.unget(name2);
      return true;
    }
    return false;
  }
  provider = Lazy(() => this.rt.getBagProvider());
  // getNamedKey(name: string, failIfNotFound?: boolean, material?: string | Uint8Array): Promise<Result<KeysByFingerprint>>;
  async getNamedKey(name2, failIfNotFound = false, materialStrOrUint8) {
    const kItem = await this.#namedKeyItems.get(name2).once(() => new NamedKeyItem(new InternalKeyBagFingerprintItem(this, name2)));
    return kItem.seq.add(() => kItem.namedItem.getNamedKey({ failIfNotFound, materialStrOrUint8 }));
  }
  async getRawObj(name2) {
    const rawObj = await this.provider().then((p) => p.get(name2));
    if (!rawObj) {
      return Option.None();
    }
    return Option.Some(LegacyKeyedItemSchema.safeParse(rawObj));
  }
  async setRawObj(k) {
    const r = KeyedItemSchema.safeParse(k);
    if (!r.success) {
      return Result.Err(r.error);
    }
    return exception2Result(() => this.provider().then((p) => p.set(r.data.id, r.data).then((_) => r.data)));
  }
};

// core/keybag/key-bag-setup.ts
var keyBagProviderFactories = new Map(
  [
    {
      protocol: "file:",
      factory: async (url2, sthis) => {
        return new KeyBagProviderFile(url2, sthis);
      }
    },
    {
      protocol: "indexeddb:",
      factory: async (url2, sthis) => {
        const { KeyBagProviderImpl } = await Promise.resolve().then(() => (init_indexeddb(), indexeddb_exports));
        return new KeyBagProviderImpl(url2, sthis);
      }
    },
    {
      protocol: "memory:",
      factory: async (url2, sthis) => {
        return new KeyBagProviderMemory(url2, sthis);
      }
    }
  ].map((i) => [i.protocol, i])
);
function defaultKeyBagOpts(sthis, kbo) {
  kbo = kbo || {};
  if (kbo.keyRuntime) {
    return kbo.keyRuntime;
  }
  const logger = ensureLogger(sthis, "KeyBag");
  let url2;
  if (kbo.url) {
    url2 = URI.from(kbo.url);
    logger.Debug().Url(url2).Msg("from opts");
  } else {
    let bagFnameOrUrl = sthis.env.get("FP_KEYBAG_URL");
    if (runtimeFn().isBrowser) {
      url2 = URI.from(bagFnameOrUrl || "indexeddb://fp-keybag");
    } else {
      if (!bagFnameOrUrl) {
        const home = sthis.env.get("HOME");
        bagFnameOrUrl = `${home}/.fireproof/keybag`;
        url2 = URI.from(`file://${bagFnameOrUrl}`);
      } else {
        url2 = URI.from(bagFnameOrUrl);
      }
    }
    logger.Debug().Url(url2).Msg("from env");
  }
  const kitem = keyBagProviderFactories.get(url2.protocol);
  if (!kitem) {
    throw logger.Error().Url(url2).Msg("unsupported protocol").AsError();
  }
  if (url2.hasParam("masterkey")) {
    throw logger.Error().Url(url2).Msg("masterkey is not supported").AsError();
  }
  return {
    url: url2,
    crypto: kbo.crypto || toCryptoRuntime({}),
    sthis,
    logger,
    keyLength: kbo.keyLength || 16,
    getBagProvider: () => kitem.factory(url2, sthis),
    id: () => {
      return url2.toString();
    }
  };
}
var _keyBags = new KeyedResolvOnce();
async function getKeyBag(sthis, kbo = {}) {
  await sthis.start();
  const rt = defaultKeyBagOpts(sthis, kbo);
  return _keyBags.get(rt.id()).once(() => KeyBag.create(rt));
}

// core/blockstore/loader-helpers.ts
init_sha2_browser();
init_src2();
init_block();
init_esm();
init_blockstore();
init_runtime2();
var FPBlockImpl = class _FPBlockImpl {
  cid;
  bytes;
  item;
  static async fromBlockItem(item) {
    const block = await asyncBlockEncode({ value: item.value, hasher: sha256, codec: src_exports });
    return new _FPBlockImpl(block.cid, block.bytes, item);
  }
  static async fromAnyBlock(cid, bytes) {
    const rcontent = await exception2Result(
      async () => await decode9({ bytes, hasher: sha256, codec: src_exports })
    );
    if (rcontent.isErr()) {
      return new FileFPBlock(cid, bytes);
    }
    const content = rcontent.Ok();
    switch (true) {
      case "doc" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "doc",
          status: "ready",
          value: content.value
        });
      case "entries" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "entries",
          status: "ready",
          value: content.value
        });
      case "fp" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "fp",
          status: "ready",
          value: content.value
        });
      case "data" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "data",
          status: "ready",
          value: content.value
        });
      case "del" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "del",
          status: "ready",
          value: content.value
        });
      // leaf,closed
      case "leaf" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "leaf",
          status: "ready",
          value: content.value
        });
      case "branch" in content.value:
        return _FPBlockImpl.fromBlockItem({
          type: "branch",
          status: "ready",
          value: content.value
        });
      default:
        return _FPBlockImpl.fromBlockItem({
          type: "unknown",
          status: "ready",
          value: content.value
        });
    }
  }
  constructor(cid, bytes, item) {
    this.cid = cid;
    this.bytes = bytes;
    this.item = item;
  }
};
var FileFPBlock = class {
  cid;
  bytes;
  get item() {
    throw new Error("FileFPBlock: item not available");
  }
  constructor(cid, bytes) {
    this.cid = cid;
    this.bytes = bytes;
  }
};
function fileBlock2FPBlock(value) {
  return new FileFPBlock(value.cid, value.bytes);
}
function anyBlock2FPBlock(fp) {
  return FPBlockImpl.fromAnyBlock(fp.cid, fp.bytes);
}
async function doc2FPBlock(doc) {
  const block = await asyncBlockEncode({ value: doc, hasher: sha256, codec: src_exports });
  return anyBlock2FPBlock(block);
}
async function carHeader2FPBlock(fp) {
  return anyBlock2FPBlock(
    await asyncBlockEncode({
      value: { fp },
      hasher: sha256,
      codec: src_exports
    })
  );
}
async function parseCarFile(reader, logger) {
  const roots = await reader.item.value.car.roots;
  const header = reader.item.value.car.blocks.find((i) => i.cid.equals(roots[0]));
  if (!header) throw logger.Error().Msg("missing header block").AsError();
  if (!isFPBlockItem(header)) {
    throw logger.Error().Msg("missing fp").AsError();
  }
  return header.item.value.fp;
}

// core/blockstore/transaction.ts
init_blockstore();
init_base2();
init_esm();
init_runtime2();
var CarTransactionImpl = class {
  parent;
  #memblock = /* @__PURE__ */ new Map();
  // new MemoryBlockstore();
  #hackUnshift;
  constructor(parent, opts = { add: true, noLoader: false }) {
    if (opts.add) {
      parent.transactions.add(this);
    }
    this.parent = parent;
  }
  async get(cid) {
    const sg = await this.superGet(cid);
    if (sg) return sg;
    return await this.parent.get(cid);
  }
  async superGet(cid) {
    return this.#memblock.get(cid.toString());
  }
  async put(fb) {
    return this.putSync(fb);
  }
  putSync(fb) {
    this.#memblock.set(fb.cid.toString(), fb);
  }
  unshift(fb) {
    if (this.#hackUnshift) {
      throw new Error("unshift already called");
    }
    this.#hackUnshift = fb;
  }
  async *entries() {
    if (this.#hackUnshift) {
      yield this.#hackUnshift;
    }
    for await (const blk of this.#memblock.values()) {
      yield blk;
    }
  }
};
function defaultedBlockstoreRuntime(sthis, opts, component, ctx) {
  const logger = ensureLogger(sthis, component, ctx);
  return {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    applyMeta: (meta3, snap) => {
      return Promise.resolve();
    },
    compactStrategy: getCompactStrategyThrow("no-op"),
    autoCompact: 100,
    public: false,
    // name: undefined,
    threshold: 1e3 * 1e3,
    ...opts,
    logger,
    keyBag: opts.keyBag || {},
    crypto: toCryptoRuntime(opts.crypto),
    storeUrls: opts.storeUrls,
    taskManager: {
      removeAfter: 3,
      retryTimeout: 50,
      ...opts.taskManager
    },
    // storeEnDeFile: ensureStoreEnDeFile(opts.storeEnDeFile),
    // store,
    storeRuntime: toStoreRuntime(sthis, ensureStoreEnDeFile(opts.storeEnDeFile))
  };
}
var BaseBlockstoreImpl = class {
  transactions = /* @__PURE__ */ new Set();
  ebOpts;
  sthis;
  crdtParent;
  loader;
  // readonly name?: string;
  // ready: Promise<void>;
  ready() {
    return Promise.resolve();
  }
  async close() {
  }
  async destroy() {
  }
  async compact() {
  }
  logger;
  constructor(ebOpts, crdt) {
    this.sthis = ensureSuperThis(ebOpts);
    this.crdtParent = crdt;
    this.ebOpts = defaultedBlockstoreRuntime(this.sthis, ebOpts, "BaseBlockstore");
    this.logger = this.ebOpts.logger;
    this.loader = new Loader(this.sthis, ebOpts, this);
  }
  async get(cid) {
    if (!cid) throw this.logger.Error().Msg("required cid").AsError();
    for (const f of this.transactions) {
      const v = await f.superGet(cid);
      if (v) return v;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async put(fp) {
    throw this.logger.Error().Msg("use a transaction to put").AsError();
  }
  lastTxMeta;
  // TransactionMeta
  async transaction(fn, _opts) {
    this.logger.Debug().Msg("enter transaction");
    const t = new CarTransactionImpl(this, _opts);
    this.logger.Debug().Msg("post CarTransaction");
    const done = await fn(t);
    this.logger.Debug().Msg("post fn");
    this.lastTxMeta = done;
    return { t, meta: done };
  }
  openTransaction(opts = { add: true, noLoader: false }) {
    return new CarTransactionImpl(this, opts);
  }
  async commitTransaction(t, done, opts) {
    if (!this.loader) throw this.logger.Error().Msg("loader required to commit").AsError();
    const cars = await this.loader.commit(t, done, opts);
    if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {
      setTimeout(() => void this.compact(), 10);
    }
    if (cars) {
      this.transactions.delete(t);
      return { meta: done, cars, t };
    }
    throw this.logger.Error().Msg("failed to commit car files").AsError();
  }
  async *entries() {
    const seen = /* @__PURE__ */ new Set();
    for (const t of this.transactions) {
      for await (const blk of t.entries()) {
        if (seen.has(blk.cid.toString())) continue;
        seen.add(blk.cid.toString());
        yield blk;
      }
    }
  }
};
var EncryptedBlockstore = class extends BaseBlockstoreImpl {
  // readonly name: string;
  ready() {
    return this.loader.ready();
  }
  close() {
    return this.loader.close();
  }
  destroy() {
    return this.loader.destroy();
  }
  compacting = false;
  logger;
  constructor(sthis, ebOpts, crdt) {
    super(ebOpts, crdt);
    this.logger = ensureLogger(this.sthis, "EncryptedBlockstore", {
      this: 1
    });
  }
  async get(cid) {
    const got = await super.get(cid);
    if (got) return got;
    const ret = await this.loader.getBlock(cid, this.loader.attachedStores.local());
    return ret;
  }
  async transaction(fn, opts = { noLoader: false }) {
    this.logger.Debug().Msg("enter transaction");
    const { t, meta: done } = await super.transaction(fn);
    this.logger.Debug().Msg("post super.transaction");
    const cars = await this.loader.commit(t, done, opts);
    this.logger.Debug().Msg("post this.loader.commit");
    if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {
      setTimeout(() => void this.compact(), 10);
    }
    if (cars) {
      this.transactions.delete(t);
      return { meta: done, cars, t };
    }
    throw this.logger.Error().Msg("failed to commit car files").AsError();
  }
  async getFile(car, cid) {
    await this.ready();
    if (!this.loader) throw this.logger.Error().Msg("loader required to get file, ledger must be named").AsError();
    const reader = await this.loader.loadFileCar(car, this.loader.attachedStores.local());
    if (!isCarBlockItemReady(reader)) {
      throw this.logger.Error().Str("cid", car.toString()).Msg("car not ready").AsError();
    }
    const block = await reader.item.value.car.blocks.find((i) => i.cid.equals(cid));
    if (!block) throw this.logger.Error().Str("cid", cid.toString()).Msg(`Missing block`).AsError();
    return block.bytes;
  }
  async compact() {
    await this.ready();
    if (!this.loader) throw this.logger.Error().Msg("loader required to compact").AsError();
    if (this.loader.carLog.length < 2) return;
    if (this.compacting) return;
    const blockLog = new CompactionFetcher(this);
    this.compacting = true;
    try {
      const resMeta = await exception2Result(async () => this.ebOpts.compactStrategy.compact(blockLog));
      if (resMeta.isErr()) {
        this.logger.Error().Err(resMeta).Any({
          carLogLen: this.loader.carLog.length,
          carLogCids: this.loader.carLog.asArray().flat().map((cid) => cid.toString())
        }).Msg("compact inner fn threw");
        return;
      }
      await this.loader.commit(blockLog.loggedBlocks, resMeta.Ok(), {
        compact: true,
        noLoader: true
      });
    } finally {
      this.compacting = false;
      this.logger.Debug().Uint64("carLogLen_after", this.loader.carLog.length).Msg("compact() \u2013 finished");
    }
  }
  async *entries() {
    for await (const blk of this.loader.entries()) {
      yield blk;
    }
  }
};
var CompactionFetcher = class {
  transactions;
  clock;
  lastTxMeta;
  loader;
  logger;
  blockstore;
  // loader: Loader | null = null
  loggedBlocks;
  constructor(blocks) {
    this.transactions = blocks.transactions;
    this.logger = blocks.logger;
    this.loader = blocks.loader;
    this.clock = blocks.crdtParent?.clock;
    this.blockstore = blocks;
    this.loggedBlocks = new CarTransactionImpl(blocks);
  }
  async get(cid) {
    const block = await this.blockstore.get(cid);
    if (block) this.loggedBlocks.putSync(block);
    return falsyToUndef(block);
  }
};

// core/blockstore/loader.ts
init_runtime2();
init_base2();

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/buffer-writer.js
init_src2();
init_cborg2();

// node_modules/.pnpm/cborg@4.3.0/node_modules/cborg/lib/length.js
init_encode2();
init_jump2();
var cborEncoders3 = makeCborEncoders2();
var defaultEncodeOptions4 = {
  float64: false,
  quickEncodeToken: quickEncodeToken2
};
function tokensToLength(tokens, encoders = cborEncoders3, options = defaultEncodeOptions4) {
  if (Array.isArray(tokens)) {
    let len = 0;
    for (const token of tokens) {
      len += tokensToLength(token, encoders, options);
    }
    return len;
  } else {
    const encoder2 = encoders[tokens.type.major];
    if (encoder2.encodedSize === void 0 || typeof encoder2.encodedSize !== "function") {
      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
    }
    return encoder2.encodedSize(tokens, options);
  }
}

// node_modules/.pnpm/@ipld+car@5.4.2/node_modules/@ipld/car/src/buffer-writer.js
var import_varint3 = __toESM(require_varint(), 1);
var CarBufferWriter = class {
  /**
   * @param {Uint8Array} bytes
   * @param {number} headerSize
   */
  constructor(bytes, headerSize) {
    this.bytes = bytes;
    this.byteOffset = headerSize;
    this.roots = [];
    this.headerSize = headerSize;
  }
  /**
   * Add a root to this writer, to be used to create a header when the CAR is
   * finalized with {@link CarBufferWriter.close `close()`}
   *
   * @param {CID} root
   * @param {{resize?:boolean}} [options]
   * @returns {CarBufferWriter}
   */
  addRoot(root2, options) {
    addRoot(this, root2, options);
    return this;
  }
  /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   * Throws if there is not enough capacity.
   *
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {CarBufferWriter}
   */
  write(block) {
    addBlock(this, block);
    return this;
  }
  /**
   * Finalize the CAR and return it as a `Uint8Array`.
   *
   * @param {object} [options]
   * @param {boolean} [options.resize]
   * @returns {Uint8Array}
   */
  close(options) {
    return close(this, options);
  }
};
var addRoot = (writer, root2, options = {}) => {
  const { resize = false } = options;
  const { bytes, headerSize, byteOffset, roots } = writer;
  writer.roots.push(root2);
  const size = headerLength(writer);
  if (size > headerSize) {
    if (size - headerSize + byteOffset < bytes.byteLength) {
      if (resize) {
        resizeHeader(writer, size);
      } else {
        roots.pop();
        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root2}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
      }
    } else {
      roots.pop();
      throw new RangeError(`Buffer has no capacity for a new root ${root2}`);
    }
  }
};
var blockLength = ({ cid, bytes }) => {
  const size = cid.bytes.byteLength + bytes.byteLength;
  return import_varint3.default.encodingLength(size) + size;
};
var addBlock = (writer, { cid, bytes }) => {
  const byteLength = cid.bytes.byteLength + bytes.byteLength;
  const size = import_varint3.default.encode(byteLength);
  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
    throw new RangeError("Buffer has no capacity for this block");
  } else {
    writeBytes(writer, size);
    writeBytes(writer, cid.bytes);
    writeBytes(writer, bytes);
  }
};
var close = (writer, options = {}) => {
  const { resize = false } = options;
  const { roots, bytes, byteOffset, headerSize } = writer;
  const headerBytes = encode11({ version: 1, roots });
  const varintBytes = import_varint3.default.encode(headerBytes.length);
  const size = varintBytes.length + headerBytes.byteLength;
  const offset = headerSize - size;
  if (offset === 0) {
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, byteOffset);
  } else if (resize) {
    resizeHeader(writer, size);
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, writer.byteOffset);
  } else {
    throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
  }
};
var resizeHeader = (writer, byteLength) => {
  const { bytes, headerSize } = writer;
  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
  writer.byteOffset += byteLength - headerSize;
  writer.headerSize = byteLength;
};
var writeBytes = (writer, bytes) => {
  writer.bytes.set(bytes, writer.byteOffset);
  writer.byteOffset += bytes.length;
};
var writeHeader = ({ bytes }, varint4, header) => {
  bytes.set(varint4);
  bytes.set(header, varint4.length);
};
var headerPreludeTokens = [
  new Token2(Type2.map, 2),
  new Token2(Type2.string, "version"),
  new Token2(Type2.uint, 1),
  new Token2(Type2.string, "roots")
];
var CID_TAG = new Token2(Type2.tag, 42);
var calculateHeaderLength = (rootLengths) => {
  const tokens = [...headerPreludeTokens];
  tokens.push(new Token2(Type2.array, rootLengths.length));
  for (const rootLength of rootLengths) {
    tokens.push(CID_TAG);
    tokens.push(new Token2(Type2.bytes, { length: rootLength + 1 }));
  }
  const length2 = tokensToLength(tokens);
  return import_varint3.default.encodingLength(length2) + length2;
};
var headerLength = ({ roots }) => calculateHeaderLength(roots.map((cid) => cid.bytes.byteLength));
var createWriter = (buffer3, options = {}) => {
  const {
    roots = [],
    byteOffset = 0,
    byteLength = buffer3.byteLength,
    headerSize = headerLength({ roots })
  } = options;
  const bytes = new Uint8Array(buffer3, byteOffset, byteLength);
  const writer = new CarBufferWriter(bytes, headerSize);
  for (const root2 of roots) {
    writer.addRoot(root2);
  }
  return writer;
};

// core/blockstore/commitor.ts
init_sha2_browser();
init_runtime2();
async function encodeCarFile(roots, t, codec2) {
  let size = 0;
  const headerSize = headerLength({ roots });
  size += headerSize;
  for await (const { cid, bytes } of t.entries()) {
    size += blockLength({ cid, bytes });
  }
  const buffer3 = new Uint8Array(size);
  const writer = createWriter(buffer3.buffer, { headerSize });
  for (const r of roots) {
    writer.addRoot(r);
  }
  for await (const { cid, bytes } of t.entries()) {
    writer.write({ cid, bytes });
  }
  writer.close();
  return await asyncBlockEncode({ value: writer.bytes, hasher: sha256, codec: codec2 });
}
async function createCarFile(encoder2, cid, t) {
  return encodeCarFile([cid], t, encoder2);
}
async function commitFiles(fileStore, walStore, t, done) {
  const { files: roots } = makeFileCarHeader(done);
  const cids = [];
  const codec2 = await fileStore.keyedCrypto().then((i) => i.codec());
  const cars = await prepareCarFilesFiles(codec2, roots, t);
  for (const car of cars) {
    const { cid, bytes } = car;
    await fileStore.save({ cid, bytes });
    await walStore.enqueueFile(
      cid
      /*, !!opts.public*/
    );
    cids.push(cid);
  }
  return cids;
}
function makeFileCarHeader(result) {
  const files = [];
  for (const [, meta3] of Object.entries(result.files || {})) {
    if (typeof meta3 === "object" && meta3 !== null && "cid" in meta3) {
      files.push(meta3.cid);
    }
  }
  return { ...result, files };
}
async function prepareCarFilesFiles(encoder2, roots, t) {
  return [await encodeCarFile(roots, t, encoder2)];
}
function makeCarHeader(meta3, cars, compact = false) {
  const coreHeader = compact ? { cars: [], compact: cars.asArray() } : { cars: cars.asArray(), compact: [] };
  return { ...coreHeader, meta: meta3 };
}
async function encodeCarHeader(fp) {
  return carHeader2FPBlock(fp);
}
async function commit(params, t, done, opts = { noLoader: false, compact: false }) {
  const fp = makeCarHeader(done, params.carLog, !!opts.compact);
  const rootBlock = await encodeCarHeader(fp);
  const cars = await prepareCarFiles(params.encoder, params.threshold, rootBlock, t);
  const cids = await Promise.all(
    cars.map(async (car) => {
      await params.writeCar(car);
      return car.cid;
    })
  );
  await Promise.all([params.writeWAL(cids), params.writeMeta(cids)]);
  return { cgrp: cids, header: fp };
}
async function prepareCarFiles(encoder2, threshold, rootBlock, t) {
  const carFiles = [];
  threshold = threshold || 16 * 65536;
  let clonedt = new CarTransactionImpl(t.parent, { add: false, noLoader: false });
  clonedt.putSync(rootBlock);
  let newsize = blockLength({ cid: rootBlock.cid, bytes: rootBlock.bytes });
  let cidRootBlock = rootBlock;
  for await (const fpblock of t.entries()) {
    newsize += blockLength({ cid: fpblock.cid, bytes: fpblock.bytes });
    if (newsize >= threshold) {
      carFiles.push(await createCarFile(encoder2, cidRootBlock.cid, clonedt));
      clonedt = new CarTransactionImpl(t.parent, { add: false, noLoader: false });
      clonedt.putSync(fpblock);
      cidRootBlock = fpblock;
      newsize = blockLength({ cid: fpblock.cid, bytes: fpblock.bytes });
    } else {
      clonedt.putSync(fpblock);
    }
  }
  carFiles.push(await createCarFile(encoder2, cidRootBlock.cid, clonedt));
  return carFiles;
}

// core/blockstore/loader.ts
init_sha2_browser();

// core/blockstore/attachable-store.ts
init_esm();
init_blockstore();
init_runtime2();
init_base2();
var AttachedImpl = class {
  keyed;
  gatewayUrls;
  stores;
  attachCtx;
  constructor(keyed, gws, stores, actx) {
    this.keyed = keyed;
    this.gatewayUrls = gws;
    this.stores = new DataAndMetaAndWalAndBaseStore(stores);
    this.attachCtx = {
      detach: async () => {
      },
      ctx: new AppContext(),
      ...actx
    };
  }
  async detach() {
    const toClose = [this.stores.car.close(), this.stores.file.close(), this.stores.meta.close()];
    if (this.stores.wal) {
      toClose.push(this.stores.wal.close());
    }
    await Promise.all(toClose);
    this.attachCtx.detach();
  }
  ctx() {
    return this.attachCtx.ctx;
  }
  status() {
    return "attached";
  }
};
var FileActiveStoreImpl = class extends FileActiveStore {
  ref;
  active;
  attached;
  constructor(ref, active, attached) {
    super();
    this.ref = ref;
    this.active = active;
    this.attached = attached;
  }
  local() {
    return this.attached.local();
  }
  remotes() {
    return this.attached.remotes();
  }
};
var CarActiveStoreImpl = class extends CarActiveStore {
  ref;
  active;
  attached;
  constructor(ref, active, attached) {
    super();
    this.ref = ref;
    this.active = active;
    this.attached = attached;
  }
  local() {
    return this.attached.local();
  }
  remotes() {
    return [this.active, ...this.attached.remotes().filter((i) => i !== this.active)];
  }
};
var CarAttachedStoresImpl = class {
  attached;
  constructor(attached) {
    this.attached = attached;
  }
  local() {
    return this.attached.local().active.car;
  }
  remotes() {
    return this.attached.remotes().map(({ active }) => active.car);
  }
};
var FileAttachedStoresImpl = class {
  attached;
  constructor(attached) {
    this.attached = attached;
  }
  local() {
    return this.attached.local().active.file;
  }
  remotes() {
    return this.attached.remotes().map(({ active }) => active.file);
  }
};
var MetaActiveStoreImpl = class extends MetaActiveStore {
  ref;
  active;
  attached;
  constructor(ref, active, attached) {
    super();
    this.ref = ref;
    this.active = active;
    this.attached = attached;
  }
  local() {
    return this.attached.local();
  }
  remotes() {
    return [this.active, ...this.attached.remotes().filter((i) => i !== this.active)];
  }
};
var MetaAttachedStoresImpl = class {
  attached;
  constructor(attached) {
    this.attached = attached;
  }
  local() {
    return this.attached.local().active.meta;
  }
  remotes() {
    return this.attached.remotes().map(({ active }) => active.meta);
  }
};
var WALActiveStoreImpl = class extends WALActiveStore {
  ref;
  active;
  attached;
  constructor(ref, active, attached) {
    super();
    this.ref = ref;
    this.active = active;
    this.attached = attached;
  }
  local() {
    return this.attached.local();
  }
  remotes() {
    return this.attached.remotes();
  }
};
var WALAttachedStoresImpl = class {
  attached;
  constructor(attached) {
    this.attached = attached;
  }
  local() {
    return this.attached.local().active.wal;
  }
  remotes() {
    return this.attached.remotes().filter(({ active }) => active.wal).map(({ active }) => active.wal);
  }
};
var ActiveStoreImpl = class {
  active;
  attached;
  constructor(active, attached) {
    this.active = active;
    this.attached = attached;
  }
  local() {
    return this.attached.local();
  }
  remotes() {
    return this.attached.remotes();
  }
  baseStores() {
    const bs = [this.active.car, this.active.file, this.active.meta];
    if (this.active.wal) {
      bs.push(this.active.wal);
    }
    return bs;
  }
  carStore() {
    return new CarActiveStoreImpl(this, this.active.car, new CarAttachedStoresImpl(this.attached));
  }
  fileStore() {
    return new FileActiveStoreImpl(this, this.active.file, new FileAttachedStoresImpl(this.attached));
  }
  metaStore() {
    return new MetaActiveStoreImpl(this, this.active.meta, new MetaAttachedStoresImpl(this.attached));
  }
  walStore() {
    if (!this.active.wal) {
      throw this.attached.loadable.sthis.logger.Error().Msg("wal store not set").AsError();
    }
    return new WALActiveStoreImpl(this, this.active.wal, new WALAttachedStoresImpl(this.attached));
  }
};
function isLoadable(unknown2) {
  return !!unknown2.sthis && !!unknown2.attachedStores;
}
async function createAttachedStores(urlOrGup, arOrLoadable, name2 = "local") {
  let ar;
  if (!isLoadable(arOrLoadable)) {
    ar = arOrLoadable;
  } else {
    ar = arOrLoadable.attachedStores;
  }
  let gup;
  if (!urlOrGup) {
    throw new Error("urlOrGup is required");
  }
  if (isCoerceURI(urlOrGup)) {
    const url2 = urlOrGup;
    gup = {
      car: { url: url2 },
      file: { url: url2 },
      meta: { url: url2 },
      wal: { url: url2 }
    };
  } else {
    gup = urlOrGup;
  }
  const cfgId = hashObjectSync(gup);
  return await ar.attach(
    {
      name: name2,
      configHash: () => cfgId,
      prepare: async () => gup
    },
    (at) => Promise.resolve(at)
  );
}
var AttachedRemotesImpl = class {
  _remotes = new KeyedResolvOnce();
  loadable;
  // readonly attactedFileStore: DataStore;
  // readonly attactedCarStore: DataStore;
  // readonly attactedMetaStore: MetaStore;
  _local;
  id;
  constructor(loadable) {
    this.loadable = loadable;
    this.id = loadable.sthis.nextId().str;
  }
  forRemotes(action) {
    return Promise.all(this.remotes().map((i) => action(i))).then(() => void 0);
  }
  remotes() {
    return this._remotes.values().filter(({ value }) => value.isOk() && !value.Ok().stores.wal).map(({ value }) => value.Ok().stores).map((i) => this.activate(i));
  }
  local() {
    if (!this._local) {
      throw this.loadable.sthis.logger.Error().Msg("local store not set").AsError();
    }
    return new ActiveStoreImpl(this._local.stores, this);
  }
  activate(store) {
    if (isCoerceURI(store)) {
      const activateUrl = URI.from(store);
      let maxScore = 0;
      let maxStore;
      for (const { value } of this._remotes.values()) {
        if (value.isErr()) {
          continue;
        }
        for (const url2 of value.Ok().stores.baseStores.map((i) => i.url())) {
          const mr = url2.match(activateUrl);
          if (mr.score > maxScore) {
            maxScore = mr.score;
            maxStore = value.Ok().stores;
          }
        }
      }
      if (!maxStore) {
        throw this.loadable.sthis.logger.Error().Url(activateUrl).Msg("no store found").AsError();
      }
      store = maxStore;
    }
    return new ActiveStoreImpl(store, this);
  }
  async detach() {
    await Promise.all(
      this._remotes.values().map(async ({ value: rvalue }) => {
        if (rvalue.isOk()) {
          await rvalue.Ok().detach();
        }
      })
    );
  }
  // needed for React Statemanagement
  _keyedAttachable = new KeyedResolvOnce();
  async attach(attachable, onAttach) {
    const keyed = attachable.configHash(this.loadable.blockstoreParent?.crdtParent?.ledgerParent);
    const ret = await this._keyedAttachable.get(keyed).once(async () => {
      const gwp = await attachable.prepare(this.loadable.blockstoreParent?.crdtParent?.ledgerParent);
      const gws = {
        car: {
          ...gwp.car,
          url: ensureURIDefaults(
            this.loadable.sthis,
            { name: attachable.name, localURI: this._local?.gatewayUrls.car.url },
            void 0,
            URI.from(gwp.car.url),
            "car"
          )
        },
        file: {
          ...gwp.file,
          url: ensureURIDefaults(
            this.loadable.sthis,
            { name: attachable.name, localURI: this._local?.gatewayUrls.file.url },
            void 0,
            URI.from(gwp.file.url),
            "file",
            { file: true }
          )
        },
        meta: {
          ...gwp.meta,
          url: ensureURIDefaults(
            this.loadable.sthis,
            { name: attachable.name, localURI: this._local?.gatewayUrls.meta.url },
            void 0,
            URI.from(gwp.meta.url),
            "meta"
          )
        },
        wal: gwp.wal ? {
          ...gwp.wal,
          url: ensureURIDefaults(
            this.loadable.sthis,
            { name: attachable.name, localURI: this._local?.gatewayUrls.wal?.url },
            void 0,
            URI.from(gwp.wal.url),
            "wal"
          )
        } : void 0
      };
      const key = JSON.stringify(
        toSortedArray({
          carUrl: gws.car.url.toString(),
          filesUrl: gws.file.url.toString(),
          metaUrl: gws.meta.url.toString(),
          walUrl: gws.wal?.url.toString()
        })
      );
      const ret2 = await this._remotes.get(key).once(async () => {
        const rt = toStoreRuntime(this.loadable.sthis);
        const result = new AttachedImpl(
          keyed,
          gws,
          await rt.makeStores({
            byStore: gws,
            loader: this.loadable
          }),
          {
            detach: async () => this._remotes.unget(key),
            ctx: gwp.ctx
          }
        );
        if (result.stores.wal) {
          if (this._local) {
            throw this.loadable.sthis.logger.Error().Any({ urls: result.gatewayUrls }).Msg("local store could only set once").AsError();
          }
          this._local = result;
        }
        return result;
      });
      const rex = await onAttach?.(ret2);
      return rex;
    });
    return ret;
  }
};

// core/blockstore/loader.ts
function carLogIncludesGroup(list, cids) {
  const cidSet = cids.map((cid) => cid.toString()).sort().join(",");
  return list.some(
    (arr) => cidSet === arr.map((cid) => cid.toString()).sort().join(",")
  );
}
function uniqueCids(list, remove = new LRUSet()) {
  const byString = /* @__PURE__ */ new Map();
  for (const cid of list) {
    if (remove.has(cid.toString())) continue;
    byString.set(cid.toString(), cid);
  }
  return [...byString.values()];
}
var CommitAction = class {
  carLog;
  encoder;
  threshold;
  attached;
  opts;
  commitQueue;
  logger;
  constructor(logger, carLog, commitQueue, encoder2, attached, threshold, opts) {
    this.logger = logger;
    this.carLog = carLog;
    this.commitQueue = commitQueue;
    this.attached = attached;
    this.encoder = encoder2;
    this.threshold = threshold;
    this.opts = opts;
  }
  async writeCar(block) {
    await this.attached.local().active.car.save(block);
    this.attached.remotes().forEach((r) => {
      this.commitQueue.enqueue(async () => {
        this.logger.Debug().Url(r.active.car.url()).Msg("remote-writeCar");
        await r.active.car.save(block);
        return [];
      });
    });
  }
  async writeMeta(cids) {
    const meta3 = { cars: cids };
    await this.attached.local().active.meta.save(meta3);
    this.attached.remotes().forEach((r) => {
      this.commitQueue.enqueue(async () => {
        this.logger.Debug().Url(r.active.meta.url()).Msg("remote-writeMeta");
        await r.active.meta.save(meta3);
        return [];
      });
    });
  }
  async writeWAL(cids) {
    await this.attached.local().active.wal.enqueue({ cars: cids }, this.opts);
  }
};
var Loader = class {
  // readonly name: string;
  blockstoreParent;
  ebOpts;
  logger;
  commitQueue;
  isCompacting = false;
  cidCache;
  maxConcurrentCarReader;
  maxConcurrentWrite = pLimit(1);
  seenCompacted;
  // readonly processedCars: Set<string> = new Set<string>();
  sthis;
  taskManager;
  carLog = new CarLog();
  // key?: string;
  // keyId?: string;
  // remoteMetaStore?: MetaStore;
  // remoteCarStore?: DataStore;
  // remoteFileStore?: DataStore;
  attachedStores;
  async tryToLoadStaleCars(store) {
    const staleLoadcars = [];
    for (const { value: rvalue } of this.cidCache.values()) {
      if (rvalue.isErr()) {
        this.logger.Error().Err(rvalue).Msg("error loading car");
        return;
      }
      const value = rvalue.Ok();
      if (isCarBlockItemStale(value)) {
        this.cidCache.unget(value.cid.toString());
        const x = this.loadCar(value.cid, store).then((fpcar) => {
          if (isCarBlockItemStale(fpcar)) {
            this.logger.Warn().Any({ cid: value.cid.toString(), type: value.item.type }).Msg("is stale");
          }
          return Promise.resolve(fpcar);
        }).catch((e) => {
          this.logger.Warn().Err(e).Any({
            cid: value.cid.toString()
          }).Msg("error loading car");
          return Promise.reject(e);
        });
        staleLoadcars.push(x);
      }
    }
    await Promise.allSettled(staleLoadcars);
  }
  async attach(attachable) {
    const ret = await this.attachedStores.attach(attachable, async (at) => {
      if (!at.stores.wal) {
        try {
          const store = this.attachedStores.activate(at.stores);
          await this.tryToLoadStaleCars(store);
          const localDbMeta = this.currentMeta;
          const remoteDbMeta = store.active.meta.stream();
          await this.waitFirstMeta(remoteDbMeta.getReader(), store, { origin: store.active.meta.url() });
          if (localDbMeta) {
            await this.ensureAttachedStore(store, localDbMeta);
          }
          await this.blockstoreParent.commitTransaction(
            new CarTransactionImpl(this.blockstoreParent),
            {
              head: this.blockstoreParent?.crdtParent?.clock.head
            },
            {
              add: false,
              noLoader: false
            }
          );
        } catch (e) {
          await at.detach();
          throw this.logger.Error().Err(e).Msg("error attaching store").AsError();
        }
      }
      return at;
    });
    return ret;
  }
  async ensureAttachedStore(store, localDbMeta) {
    const localCarStore = store.local().carStore();
    const codec2 = (await localCarStore.active.keyedCrypto()).codec();
    const ancestorDbMetas = /* @__PURE__ */ new Map();
    const myCids = new Set(localDbMeta.map((i) => i.toString()));
    await Promise.allSettled(
      localDbMeta.map(async (carId) => {
        const car = await this.storesLoadCar(carId, localCarStore);
        const rStore = await exception2Result(
          async () => await store.active.car.save({
            cid: carId,
            bytes: await codec2.encode(car.bytes)
          })
        );
        if (rStore.isErr()) {
          this.logger.Warn().Err(rStore).Str("cid", carId.toString()).Msg("error putting car");
        }
        if (car.item.value) {
          const ancestorBlocks = car.item.value.car.blocks.filter((i) => isFPBlockItem(i));
          for (const ancestorFp of ancestorBlocks) {
            if (!isFPBlockItem(ancestorFp)) {
              continue;
            }
            const ancestorCars = ancestorFp.item.value.fp.cars;
            ancestorCars.forEach((aCids) => {
              aCids.forEach((aCid) => {
                const aCidStr = aCid.toString();
                if (myCids.has(aCidStr)) {
                  return;
                }
                ancestorDbMetas.set(aCidStr, aCid);
              });
            });
          }
        }
      })
    );
    if (ancestorDbMetas.size > 0) {
      await this.ensureAttachedStore(store, Array.from(ancestorDbMetas.values()));
    }
  }
  // private getBlockCache = new Map<string, AnyBlock>();
  seenMeta;
  keyBag() {
    return getKeyBag(this.sthis, this.ebOpts.keyBag);
  }
  onceReady = new ResolveOnce();
  metaStreamReader;
  async ready() {
    return this.onceReady.once(async () => {
      await createAttachedStores(
        {
          car: { url: this.ebOpts.storeUrls.car, gatewayInterceptor: this.ebOpts.gatewayInterceptor },
          file: { url: this.ebOpts.storeUrls.file, gatewayInterceptor: this.ebOpts.gatewayInterceptor },
          meta: { url: this.ebOpts.storeUrls.meta, gatewayInterceptor: this.ebOpts.gatewayInterceptor },
          wal: { url: this.ebOpts.storeUrls.wal, gatewayInterceptor: this.ebOpts.gatewayInterceptor }
        },
        this.attachedStores,
        this.blockstoreParent?.crdtParent?.ledgerParent?.name
      );
      const local = this.attachedStores.local();
      this.metaStreamReader = local.active.meta.stream().getReader();
      await this.waitFirstMeta(this.metaStreamReader, local, { meta: this.ebOpts.meta, origin: local.active.car.url() });
    });
  }
  currentMeta = [];
  waitFirstMeta(reader, local, opts) {
    return new Promise((resolve) => {
      this.handleMetaStream(reader, local, {
        ...opts,
        first: () => {
          resolve(this.currentMeta);
        },
        error: (e) => {
          this.logger.Error().Err(e).Msg("error waiting for first meta");
          resolve(this.currentMeta);
        }
      });
    });
  }
  handleMetaStream(reader, local, opts) {
    reader.read().then((o) => {
      const { done, value } = o;
      if (done) {
        return;
      }
      let pHandle;
      if (opts?.meta) {
        pHandle = this.handleDbMetasFromStore([opts?.meta, ...value || []], local);
      } else if (value) {
        pHandle = this.handleDbMetasFromStore(value, local);
      }
      if (pHandle) {
        pHandle.then((dbMeta) => {
          if (!dbMeta.length) {
            return;
          }
          this.currentMeta = dbMeta;
        }).catch((e) => {
          this.logger.Error().Err(e).Msg("error handling meta stream");
        }).finally(() => {
          opts?.first(this.currentMeta ?? []);
          this.handleMetaStream(reader, local);
        });
      } else {
        this.handleMetaStream(reader, local);
      }
    }).catch((e) => {
      opts?.error(e);
    });
  }
  async close() {
    await this.commitQueue.waitIdle();
    await this.attachedStores.detach();
    await this.metaStreamReader?.cancel("close");
  }
  async destroy() {
    await Promise.all(
      this.attachedStores.local().baseStores().map((store) => store.destroy())
    );
  }
  id;
  constructor(sthis, ebOpts, blockstore) {
    this.sthis = sthis;
    this.id = sthis.nextId().str;
    this.commitQueue = new CommitQueue(ebOpts);
    this.blockstoreParent = blockstore;
    this.ebOpts = defaultedBlockstoreRuntime(
      sthis,
      {
        ...ebOpts
        // name,
      },
      "Loader"
    );
    this.logger = ensureLogger(sthis, "Loader");
    this.cidCache = new KeyedResolvOnce({
      lru: {
        maxEntries: parseInt(this.ebOpts.storeUrls.car.getParam(PARAM.CAR_CACHE_SIZE, "1000000"), 10)
      }
    });
    this.seenMeta = new LRUSet({
      maxEntries: parseInt(this.ebOpts.storeUrls.meta.getParam(PARAM.CAR_META_CACHE_SIZE, "1000"), 10)
    });
    this.seenCompacted = new LRUSet({
      maxEntries: parseInt(this.ebOpts.storeUrls.car.getParam(PARAM.CAR_COMPACT_CACHE_SIZE, "1000"), 10)
    });
    this.maxConcurrentCarReader = pLimit(parseInt(this.ebOpts.storeUrls.car.getParam(PARAM.CAR_PARALLEL, "10"), 10));
    this.taskManager = new TaskManager(
      sthis,
      async (dbMeta, activeStore) => {
        await this.handleDbMetasFromStore([dbMeta], activeStore);
      },
      this.ebOpts.taskManager
    );
    this.attachedStores = new AttachedRemotesImpl(this);
  }
  // async snapToCar(carCid: AnyLink | string) {
  //   await this.ready
  //   if (typeof carCid === 'string') {
  //     carCid = CID.parse(carCid)
  //   }
  //   const carHeader = await this.loadCarHeaderFromMeta({ car: carCid, key: this.key || null })
  //   this.carLog = [carCid, ...carHeader.cars]
  //   await this.getMoreReaders(carHeader.cars)
  //   await this._applyCarHeader(carHeader, true)
  // }
  async handleDbMetasFromStore(metas, activeStore) {
    const cgs = [];
    for (const meta3 of metas) {
      await this.maxConcurrentWrite(async () => {
        cgs.push(...(await this.mergeDbMetaIntoClock(meta3, activeStore)).flat(2));
      });
    }
    return cgs;
  }
  async mergeDbMetaIntoClock(meta3, activeStore) {
    if (this.isCompacting) {
      throw this.logger.Error().Msg("cannot merge while compacting").AsError();
    }
    try {
      this.isCompacting = true;
      const metaKey = meta3.cars.map((i) => i.toString()).sort().join(",");
      if (this.seenMeta.has(metaKey)) return [];
      this.seenMeta.add(metaKey);
      if (carLogIncludesGroup(this.carLog.asArray(), meta3.cars)) {
        return [];
      }
      const carHeader = await this.loadCarHeaderFromMeta(meta3, activeStore);
      carHeader.compact.map((c) => c.toString()).forEach((k) => this.seenCompacted.add(k), this.seenCompacted);
      const warns = await this.getMoreReaders(carHeader.cars.flat(), activeStore).then((res) => res.filter((r) => r.isErr()));
      if (warns.length > 0) {
        this.logger.Warn().Any("warns", warns).Msg("error getting more readers");
      }
      const cgs = uniqueCids([meta3.cars, ...this.carLog.asArray(), ...carHeader.cars], this.seenCompacted);
      this.carLog.update(cgs);
      await this.ebOpts.applyMeta(carHeader.meta);
      return cgs;
    } finally {
      this.isCompacting = false;
    }
  }
  // protected async ingestKeyFromMeta(meta: DbMeta): Promise<void> {
  //   const { key } = meta;
  //   if (key) {
  //     await this.setKey(key);
  //   }
  // }
  async loadCarHeaderFromMeta(dbm, astore) {
    const reader = await this.loadCar(dbm.cars[0], astore);
    if (isCarBlockItemStale(reader)) {
      this.logger.Warn().Str("cid", dbm.cars[0].toString()).Msg("stale loadCarHeaderFromMeta");
    } else if (isCarBlockItemReady(reader)) {
      return await parseCarFile(reader, this.logger);
    }
    return {
      cars: [],
      compact: [],
      meta: {}
    };
  }
  // async _getKey(): Promise<string | undefined> {
  //   if (this.key) return this.key;
  //   // generate a random key
  //   if (!this.ebOpts.public) {
  //     await this.setKey(toHexString(this.ebOpts.crypto.randomBytes(32)));
  //   }
  //   return this.key || undefined;
  // }
  async commitFiles(t, done) {
    await this.ready();
    const fstore = this.attachedStores.local().active.file;
    const wstore = this.attachedStores.local().active.wal;
    return this.commitQueue.enqueue(() => commitFiles(fstore, wstore, t, done));
  }
  async loadFileCar(cid, store) {
    return await this.storesLoadCar(cid, store.fileStore());
  }
  async commit(t, done, opts = { noLoader: false, compact: false }) {
    await this.ready();
    const carStore = this.attachedStores.local().active.car;
    const caction = new CommitAction(
      this.logger,
      this.carLog,
      this.commitQueue,
      await carStore.keyedCrypto().then((c) => c.codec()),
      this.attachedStores,
      this.ebOpts.threshold,
      opts
    );
    return this.commitQueue.enqueue(async () => {
      await this.cacheTransaction(t);
      const ret = await commit(caction, t, done, opts);
      await this.updateCarLog(ret.cgrp, ret.header, !!opts.compact);
      return ret.cgrp;
    });
  }
  async updateCarLog(cids, cHeader, compact) {
    if (compact) {
      const previousCompactCid = cHeader.compact[cHeader.compact.length - 1];
      cHeader.compact.map((c) => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted);
      this.carLog.update(uniqueCids([...this.carLog.asArray(), ...cHeader.cars, cids], this.seenCompacted));
      await this.removeCidsForCompact(previousCompactCid[0], this.attachedStores.local()).catch((e) => e);
    } else {
      this.carLog.unshift(cids);
    }
  }
  async cacheTransaction(t) {
    for await (const block of t.entries()) {
      const sBlock = block.cid.toString();
      this.cidCache.get(sBlock).once(
        () => block
        // ({
        //   type: "block",
        //   status: "ready",
        //   cid: block.cid,
        //   blocks: [block],
        //   roots: [],
        // }) satisfies CarBlockItem,
      );
    }
  }
  // /**
  //  *
  //  * @returns the list of blocks which was read from the car file
  //  */
  // private async readCar(reader: CarReader): Promise<AnyBlock[]> {
  //   const blocks: AnyBlock[] = [];
  //   for await (const block of reader.blocks()) {
  //     const sBlock = block.cid.toString();
  //     this.cidCache.get(sBlock).once(() => {
  //       blocks.push(block);
  //       return [block];
  //     });
  //   }
  //   return blocks;
  // }
  async removeCidsForCompact(cid, store) {
    const carHeader = await this.loadCarHeaderFromMeta(
      {
        cars: [cid]
      },
      store
    );
    for (const cids of carHeader.compact) {
      for (const cid2 of cids) {
        await this.attachedStores.local().active.car.remove(cid2);
      }
    }
  }
  // async flushCars() {
  //   await this.ready
  //   // for each cid in car log, make a dbMeta
  //   for (const cid of this.carLog) {
  //     const dbMeta = { car: cid, key: this.key || null } as DbMeta
  //     await this.remoteWAL!.enqueue(dbMeta, { public: false })
  //   }
  // }
  async *entries() {
    await this.ready();
    const seen = /* @__PURE__ */ new Set();
    for (const carCids of this.carLog.asArray()) {
      for (const carCid of carCids) {
        const reader = await this.loadCar(carCid, this.attachedStores.local());
        if (isCarBlockItemStale(reader)) {
          this.logger.Warn().Any({
            cid: carCid.toString(),
            url: this.attachedStores.local().carStore().active.url()
          }).Err(reader.item.statusCause).Msg("entries-stale car");
          continue;
        }
        if (!isCarBlockItemReady(reader)) {
          throw this.logger.Error().Any({
            cid: carCid.toString(),
            item: reader.item
          }).Msg("missing car reader").AsError();
        }
        for (const block of reader.item.value.car.blocks) {
          const cidStr = block.cid.toString();
          if (seen.has(cidStr)) continue;
          seen.add(cidStr);
          yield block;
        }
      }
    }
  }
  async getBlock(cid) {
    await this.ready();
    const got = this.cidCache.get(cid.toString());
    return got.value;
  }
  async getCompactCarCids(carCid, store) {
    const sCid = carCid.toString();
    const reader = await this.loadCar(carCid, store);
    if (isCarBlockItemStale(reader)) {
      this.logger.Warn().Str("cid", sCid).Err(reader.item.statusCause).Msg("stale getCompactCarCids");
      return;
    }
    if (!isCarBlockItemReady(reader)) {
      this.logger.Warn().Str("cid", sCid).Msg("is not ready");
      return;
    }
    const header = await parseCarFile(reader, this.logger);
    const compacts = header.compact;
    const got = await Promise.allSettled(compacts.map((compact) => compact.map((cid) => this.loadCar(cid, store)).flat()));
    got.filter((result) => result.status === "rejected").forEach((result) => {
      this.logger.Error().Err(result.reason).Str("cid", sCid).Msg("error getting compacted block");
    });
  }
  async loadCar(cid, store) {
    const loaded = await this.storesLoadCar(cid, store.carStore());
    if (isCarBlockItemStale(loaded)) {
      this.logger.Warn().Any({
        cid: loaded.cid.toString(),
        url: store.carStore().active.url().toString()
      }).Err(loaded.item.statusCause).Msg("load-car-stale car");
    }
    return loaded;
  }
  async makeDecoderAndCarReader(carCid, store) {
    const carCidStr = carCid.toString();
    let loadedCar;
    const activeStore = store.active;
    try {
      this.logger.Debug().Any("cid", carCidStr).Msg("loading car");
      loadedCar = await activeStore.load(carCid);
      this.logger.Debug().Bool("loadedCar", loadedCar).Msg("loaded");
    } catch (e) {
      if (!isNotFoundError(e)) {
        throw this.logger.Error().Str("cid", carCidStr).Err(e).Msg("loading car");
      }
    }
    if (!loadedCar) {
      return {
        cid: carCid,
        bytes: new Uint8Array(0),
        item: {
          status: "stale",
          statusCause: new Error("missing car file"),
          type: "car",
          origin: await activeStore.id(),
          value: void 0
        }
      };
    }
    if (activeStore !== store.local()) {
      await store.local().save(loadedCar);
    }
    const bytes = await asyncBlockDecode({ bytes: loadedCar.bytes, hasher: sha256, codec: (await activeStore.keyedCrypto()).codec() });
    const rawReader = await CarReader.fromBytes(bytes.value.data);
    const blocks = [];
    for await (const rawBlock of rawReader.blocks()) {
      const sBlock = rawBlock.cid.toString();
      const block = await anyBlock2FPBlock(rawBlock);
      blocks.push(block);
      this.cidCache.get(sBlock).once(() => block);
    }
    return {
      cid: carCid,
      bytes: bytes.value.data,
      item: {
        type: "car",
        status: "ready",
        origin: await activeStore.id(),
        value: {
          car: {
            blocks,
            roots: await rawReader.getRoots()
          }
        }
      }
    };
  }
  //What if instead it returns an Array of CarHeader
  async storesLoadCar(carCid, store) {
    const carCidStr = carCid.toString();
    return this.cidCache.get(carCidStr).once(async () => {
      return this.maxConcurrentCarReader(() => this.makeDecoderAndCarReader(carCid, store));
    });
  }
  async getMoreReaders(cids, store) {
    return Promise.all(
      cids.map(
        async (cid) => this.loadCar(cid, store).then((readers) => Result.Ok(readers)).catch((e) => Result.Err(e))
      )
    );
  }
};

// core/blockstore/store.ts
init_clock();
init_src3();

// node_modules/.pnpm/is-network-error@1.3.0/node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated",
  // Undici (Node.js)
  " A network error occurred.",
  // Bun (WebKit)
  "Network connection lost"
  // Cloudflare Workers (fetch)
]);
function isNetworkError(error48) {
  const isValid = error48 && isError(error48) && error48.name === "TypeError" && typeof error48.message === "string";
  if (!isValid) {
    return false;
  }
  const { message: message2, stack } = error48;
  if (message2 === "Load failed") {
    return stack === void 0 || "__sentry_captured__" in error48;
  }
  if (message2.startsWith("error sending request for url")) {
    return true;
  }
  return errorMessages.has(message2);
}

// node_modules/.pnpm/p-retry@7.1.1/node_modules/p-retry/index.js
function validateRetries(retries) {
  if (typeof retries === "number") {
    if (retries < 0) {
      throw new TypeError("Expected `retries` to be a non-negative number.");
    }
    if (Number.isNaN(retries)) {
      throw new TypeError("Expected `retries` to be a valid number or Infinity, got NaN.");
    }
  } else if (retries !== void 0) {
    throw new TypeError("Expected `retries` to be a number or Infinity.");
  }
}
function validateNumberOption(name2, value, { min = 0, allowInfinity = false } = {}) {
  if (value === void 0) {
    return;
  }
  if (typeof value !== "number" || Number.isNaN(value)) {
    throw new TypeError(`Expected \`${name2}\` to be a number${allowInfinity ? " or Infinity" : ""}.`);
  }
  if (!allowInfinity && !Number.isFinite(value)) {
    throw new TypeError(`Expected \`${name2}\` to be a finite number.`);
  }
  if (value < min) {
    throw new TypeError(`Expected \`${name2}\` to be \u2265 ${min}.`);
  }
}
var AbortError = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
function calculateDelay(retriesConsumed, options) {
  const attempt = Math.max(1, retriesConsumed + 1);
  const random = options.randomize ? Math.random() + 1 : 1;
  let timeout2 = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));
  timeout2 = Math.min(timeout2, options.maxTimeout);
  return timeout2;
}
function calculateRemainingTime(start, max) {
  if (!Number.isFinite(max)) {
    return max;
  }
  return max - (performance.now() - start);
}
async function onAttemptFailure({ error: error48, attemptNumber, retriesConsumed, startTime, options }) {
  const normalizedError = error48 instanceof Error ? error48 : new TypeError(`Non-error was thrown: "${error48}". You should only throw errors.`);
  if (normalizedError instanceof AbortError) {
    throw normalizedError.originalError;
  }
  const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;
  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;
  const context = Object.freeze({
    error: normalizedError,
    attemptNumber,
    retriesLeft,
    retriesConsumed
  });
  await options.onFailedAttempt(context);
  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {
    throw normalizedError;
  }
  const consumeRetry = await options.shouldConsumeRetry(context);
  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);
  if (remainingTime <= 0 || retriesLeft <= 0) {
    throw normalizedError;
  }
  if (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {
    if (consumeRetry) {
      throw normalizedError;
    }
    options.signal?.throwIfAborted();
    return false;
  }
  if (!await options.shouldRetry(context)) {
    throw normalizedError;
  }
  if (!consumeRetry) {
    options.signal?.throwIfAborted();
    return false;
  }
  const delayTime = calculateDelay(retriesConsumed, options);
  const finalDelay = Math.min(delayTime, remainingTime);
  options.signal?.throwIfAborted();
  if (finalDelay > 0) {
    await new Promise((resolve, reject) => {
      const onAbort = () => {
        clearTimeout(timeoutToken);
        options.signal?.removeEventListener("abort", onAbort);
        reject(options.signal.reason);
      };
      const timeoutToken = setTimeout(() => {
        options.signal?.removeEventListener("abort", onAbort);
        resolve();
      }, finalDelay);
      if (options.unref) {
        timeoutToken.unref?.();
      }
      options.signal?.addEventListener("abort", onAbort, { once: true });
    });
  }
  options.signal?.throwIfAborted();
  return true;
}
async function pRetry(input, options = {}) {
  options = { ...options };
  validateRetries(options.retries);
  if (Object.hasOwn(options, "forever")) {
    throw new Error("The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.");
  }
  options.retries ??= 10;
  options.factor ??= 2;
  options.minTimeout ??= 1e3;
  options.maxTimeout ??= Number.POSITIVE_INFINITY;
  options.maxRetryTime ??= Number.POSITIVE_INFINITY;
  options.randomize ??= false;
  options.onFailedAttempt ??= () => {
  };
  options.shouldRetry ??= () => true;
  options.shouldConsumeRetry ??= () => true;
  validateNumberOption("factor", options.factor, { min: 0, allowInfinity: false });
  validateNumberOption("minTimeout", options.minTimeout, { min: 0, allowInfinity: false });
  validateNumberOption("maxTimeout", options.maxTimeout, { min: 0, allowInfinity: true });
  validateNumberOption("maxRetryTime", options.maxRetryTime, { min: 0, allowInfinity: true });
  if (!(options.factor > 0)) {
    options.factor = 1;
  }
  options.signal?.throwIfAborted();
  let attemptNumber = 0;
  let retriesConsumed = 0;
  const startTime = performance.now();
  while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {
    attemptNumber++;
    try {
      options.signal?.throwIfAborted();
      const result = await input(attemptNumber);
      options.signal?.throwIfAborted();
      return result;
    } catch (error48) {
      if (await onAttemptFailure({
        error: error48,
        attemptNumber,
        retriesConsumed,
        startTime,
        options
      })) {
        retriesConsumed++;
      }
    }
  }
  throw new Error("Retry attempts exhausted without throwing an error.");
}

// node_modules/.pnpm/p-map@7.0.4/node_modules/p-map/index.js
async function pMap(iterable, mapper, {
  concurrency = Number.POSITIVE_INFINITY,
  stopOnError = true,
  signal
} = {}) {
  return new Promise((resolve_, reject_) => {
    if (iterable[Symbol.iterator] === void 0 && iterable[Symbol.asyncIterator] === void 0) {
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof iterable})`);
    }
    if (typeof mapper !== "function") {
      throw new TypeError("Mapper function is required");
    }
    if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
    }
    const result = [];
    const errors = [];
    const skippedIndexesMap = /* @__PURE__ */ new Map();
    let isRejected = false;
    let isResolved = false;
    let isIterableDone = false;
    let resolvingCount = 0;
    let currentIndex = 0;
    const iterator = iterable[Symbol.iterator] === void 0 ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
    const signalListener = () => {
      reject(signal.reason);
    };
    const cleanup = () => {
      signal?.removeEventListener("abort", signalListener);
    };
    const resolve = (value) => {
      resolve_(value);
      cleanup();
    };
    const reject = (reason) => {
      isRejected = true;
      isResolved = true;
      reject_(reason);
      cleanup();
    };
    if (signal) {
      if (signal.aborted) {
        reject(signal.reason);
      }
      signal.addEventListener("abort", signalListener, { once: true });
    }
    const next = async () => {
      if (isResolved) {
        return;
      }
      const nextItem = await iterator.next();
      const index2 = currentIndex;
      currentIndex++;
      if (nextItem.done) {
        isIterableDone = true;
        if (resolvingCount === 0 && !isResolved) {
          if (!stopOnError && errors.length > 0) {
            reject(new AggregateError(errors));
            return;
          }
          isResolved = true;
          if (skippedIndexesMap.size === 0) {
            resolve(result);
            return;
          }
          const pureResult = [];
          for (const [index3, value] of result.entries()) {
            if (skippedIndexesMap.get(index3) === pMapSkip) {
              continue;
            }
            pureResult.push(value);
          }
          resolve(pureResult);
        }
        return;
      }
      resolvingCount++;
      (async () => {
        try {
          const element = await nextItem.value;
          if (isResolved) {
            return;
          }
          const value = await mapper(element, index2);
          if (value === pMapSkip) {
            skippedIndexesMap.set(index2, value);
          }
          result[index2] = value;
          resolvingCount--;
          await next();
        } catch (error48) {
          if (stopOnError) {
            reject(error48);
          } else {
            errors.push(error48);
            resolvingCount--;
            try {
              await next();
            } catch (error49) {
              reject(error49);
            }
          }
        }
      })();
    };
    (async () => {
      for (let index2 = 0; index2 < concurrency; index2++) {
        try {
          await next();
        } catch (error48) {
          reject(error48);
          break;
        }
        if (isIterableDone || isRejected) {
          break;
        }
      }
    })();
  });
}
var pMapSkip = /* @__PURE__ */ Symbol("skip");

// core/blockstore/store.ts
init_runtime2();
function guardVersion(url2) {
  if (!url2.hasParam("version")) {
    return Result.Err(`missing version: ${url2.toString()}`);
  }
  return Result.Ok(url2);
}
var BaseStoreImpl = class {
  // readonly name: string;
  _url;
  logger;
  sthis;
  gateway;
  get realGateway() {
    return this.gateway.innerGW;
  }
  // readonly keybag: KeyBag;
  opts;
  loader;
  myId;
  // readonly loader: Loadable;
  constructor(sthis, url2, opts, logger) {
    this.myId = sthis.nextId().str;
    this._url = url2;
    this.opts = opts;
    this.loader = opts.loader;
    this.sthis = sthis;
    const name2 = this._url.getParam(PARAM.NAME);
    if (!name2) {
      throw logger.Error().Url(this._url).Msg("missing name").AsError();
    }
    this.logger = logger.With().Str("this", this.sthis.nextId().str).Ref("url", () => this._url.toString()).Logger();
    this.gateway = opts.gateway;
  }
  url() {
    return this._url;
  }
  _id = new ResolveOnce();
  id() {
    return this._id.once(() => hashStringSync(this.url().toString()));
  }
  _onStarted = [];
  onStarted(fn) {
    this._onStarted.push(fn);
  }
  _onClosed = [];
  onClosed(fn) {
    this._onClosed.push(fn);
  }
  async ready() {
    return;
  }
  async keyedCrypto() {
    return keyedCryptoFactory(this._url, await this.loader.keyBag(), this.sthis);
  }
  async start(dam) {
    this.logger.Debug().Str("storeType", this.storeType).Msg("starting-gateway-pre");
    this._url = this._url.build().setParam(PARAM.STORE, this.storeType).URI();
    const res = await this.gateway.start({ loader: this.loader }, this._url);
    if (res.isErr()) {
      this.logger.Error().Result("gw-start", res).Msg("started-gateway");
      return res;
    }
    this._url = res.Ok();
    const kb = await this.loader.keyBag();
    const skRes = await kb.ensureKeyFromUrl(this._url, () => {
      const key = this._url.getParam(PARAM.KEY);
      return key;
    });
    if (skRes.isErr()) {
      return skRes;
    }
    this._url = skRes.Ok();
    const version2 = guardVersion(this._url);
    if (version2.isErr()) {
      this.logger.Error().Result("version", version2).Msg("guardVersion");
      await this.close();
      return version2;
    }
    if (this.ready) {
      const fn = this.ready.bind(this);
      const ready = await exception2Result(fn);
      if (ready.isErr()) {
        await this.close();
        return ready;
      }
    }
    this._onStarted.forEach((fn) => fn(dam));
    this.logger.Debug().Msg("started");
    return version2;
  }
};
async function createDbMetaEvent(sthis, dbMeta, parents) {
  const event = await EventBlock.create(
    {
      dbMeta: sthis.txt.encode(format2(dbMeta))
    },
    parents
  );
  return {
    eventCid: event.cid,
    dbMeta,
    parents
  };
}
var MetaStoreImpl = class extends BaseStoreImpl {
  storeType = "meta";
  subscribers = /* @__PURE__ */ new Map();
  parents = [];
  // remote: boolean;
  constructor(sthis, url2, opts) {
    super(sthis, url2, { ...opts }, ensureLogger(sthis, "MetaStoreImpl"));
  }
  updateParentsFromDbMetas(dbMetas) {
    const cids = dbMetas.map((m) => m.eventCid);
    const dbMetaParents = dbMetas.flatMap((m) => m.parents);
    const uniqueParentsMap = new Map([...this.parents, ...cids].map((p) => [p.toString(), p]));
    const dbMetaParentsSet = new Set(dbMetaParents.map((p) => p.toString()));
    this.parents = Array.from(uniqueParentsMap.values()).filter((p) => !dbMetaParentsSet.has(p.toString()));
  }
  cnt = 0;
  stream(branch = "main") {
    let unsubscribe = Result.Ok(() => {
    });
    return new ReadableStream({
      start: async (controller) => {
        this.cnt++;
        unsubscribe = await this.gateway.subscribe({ loader: this.loader }, this.url(), async (fpMeta2) => {
          const dbMetas2 = fpMeta2.payload.map((m) => m.dbMeta);
          controller.enqueue(dbMetas2);
          this.updateParentsFromDbMetas(fpMeta2.payload);
        });
        const url2 = await this.gateway.buildUrl({ loader: this.loader }, this.url(), branch);
        if (url2.isErr()) {
          this.logger.Error().Err(url2).Msg("buildUrlError");
          return;
        }
        const rfpEnv = await this.gateway.get({ loader: this.loader }, url2.Ok());
        if (rfpEnv.isErr()) {
          if (isNotFoundError(rfpEnv)) {
            controller.enqueue([]);
            return;
          }
          controller.error(this.logger.Error().Url(url2.Ok()).Err(rfpEnv).Msg("gateway get").AsError());
          controller.close();
        }
        const fpMeta = rfpEnv.Ok().payload;
        const dbMetas = fpMeta.map((m) => m.dbMeta);
        controller.enqueue(dbMetas);
        this.updateParentsFromDbMetas(fpMeta);
      },
      cancel: (reason) => {
        if (reason !== "close") {
          this.logger.Warn().Any({ reason }).Msg("unexpected meta stream end");
        }
        if (unsubscribe.isOk()) {
          unsubscribe.Ok()();
        }
      }
      // pull: async (controller) => {},
    });
  }
  async save(meta3, branch) {
    branch = branch || "main";
    this.logger.Debug().Str("branch", branch).Any("meta", meta3).Msg("saving meta");
    const url2 = await this.gateway.buildUrl({ loader: this.loader }, this.url(), branch);
    if (url2.isErr()) {
      throw this.logger.Error().Err(url2.Err()).Str("branch", branch).Msg("got error from gateway.buildUrl").AsError();
    }
    const dbMetaEvent = await createDbMetaEvent(this.sthis, meta3, this.parents);
    const res = await this.gateway.put({ loader: this.loader }, url2.Ok(), {
      type: "meta",
      payload: [dbMetaEvent]
    });
    if (res.isErr()) {
      throw this.logger.Error().Err(res.Err()).Msg("got error from gateway.put").AsError();
    }
    return res;
  }
  async close() {
    await this.gateway.close({ loader: this.loader }, this.url());
    this._onClosed.forEach((fn) => fn());
    return Result.Ok(void 0);
  }
  async destroy() {
    this.logger.Debug().Msg("destroy");
    return this.gateway.destroy({ loader: this.loader }, this.url());
  }
};
var DataStoreImpl = class extends BaseStoreImpl {
  constructor(sthis, url2, opts, logger) {
    super(sthis, url2, { ...opts }, logger);
  }
  async load(cid) {
    this.logger.Debug().Any("cid", cid).Msg("loading");
    const cidStr = typeof cid === "string" ? cid : cid?.toString?.() !== "[object Object]" ? cid.toString() : cid?.["/"] || String(cid);
    const url2 = await this.gateway.buildUrl({ loader: this.loader }, this.url(), cidStr);
    if (url2.isErr()) {
      throw this.logger.Error().Err(url2.Err()).Str("cid", cid.toString()).Msg("got error from gateway.buildUrl").AsError();
    }
    const res = await this.gateway.get({ loader: this.loader }, url2.Ok());
    if (res.isErr()) {
      throw res.Err();
    }
    const fpenv = res.Ok();
    switch (fpenv.type) {
      case "car":
      case "file":
        return { cid, bytes: fpenv.payload };
      default:
        throw this.logger.Error().Msg("unexpected type").AsError();
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async save(car, opts) {
    this.logger.Debug().Any("cid", car.cid.toString()).Msg("saving");
    const url2 = await this.gateway.buildUrl({ loader: this.loader }, this.url(), car.cid.toString());
    if (url2.isErr()) {
      throw this.logger.Error().Err(url2.Err()).Ref("cid", car.cid).Msg("got error from gateway.buildUrl").AsError();
    }
    let fpMsg;
    switch (url2.Ok().getParam(PARAM.STORE)) {
      case "car":
        fpMsg = Car2FPMsg(car.bytes);
        break;
      case "file":
        fpMsg = File2FPMsg(car.bytes);
        break;
      default:
        throw this.logger.Error().Str("store", url2.Ok().getParam(PARAM.STORE)).Msg("unexpected store").AsError();
    }
    if (fpMsg.isErr()) {
      throw this.logger.Error().Err(fpMsg).Msg("got error from FPMsg2Car").AsError();
    }
    const res = await this.gateway.put({ loader: this.loader }, url2.Ok(), fpMsg.Ok());
    if (res.isErr()) {
      throw this.logger.Error().Err(res.Err()).Msg("got error from gateway.put").AsError();
    }
    return res.Ok();
  }
  async remove(cid) {
    const url2 = await this.gateway.buildUrl({ loader: this.loader }, this.url(), cid.toString());
    if (url2.isErr()) {
      return url2;
    }
    return this.gateway.delete({ loader: this.loader }, url2.Ok());
  }
  async close() {
    await this.gateway.close({ loader: this.loader }, this.url());
    this._onClosed.forEach((fn) => fn());
    return Result.Ok(void 0);
  }
  destroy() {
    this.logger.Debug().Msg("destroy");
    return this.gateway.destroy({ loader: this.loader }, this.url());
  }
};
var CarStoreImpl = class extends DataStoreImpl {
  storeType = "car";
  constructor(sthis, url2, opts) {
    super(sthis, url2, { ...opts }, ensureLogger(sthis, "CarStoreImpl"));
  }
};
var FileStoreImpl = class extends DataStoreImpl {
  storeType = "file";
  constructor(sthis, url2, opts) {
    super(sthis, url2, { ...opts }, ensureLogger(sthis, "FileStoreImpl"));
  }
};
var WALStoreImpl = class extends BaseStoreImpl {
  storeType = "wal";
  // readonly tag: string = "rwal-base";
  // readonly loader: Loadable;
  _ready = new ResolveOnce();
  walState = { operations: [], noLoaderOps: [], fileOperations: [] };
  processing;
  processQueue;
  constructor(sthis, url2, opts) {
    super(sthis, url2, { ...opts }, ensureLogger(sthis, "WALStoreImpl"));
    this.processQueue = opts.loader.commitQueue;
  }
  async ready() {
    return this._ready.once(async () => {
      const walState = await this.load().catch((e) => {
        this.logger.Error().Err(e).Msg("error loading wal");
        return;
      });
      this.walState.operations.splice(0, this.walState.operations.length);
      this.walState.fileOperations.splice(0, this.walState.fileOperations.length);
      if (walState) {
        this.walState.operations.push(...walState.operations);
        this.walState.fileOperations.push(...walState.fileOperations);
      }
    });
  }
  async enqueue(dbMeta, opts) {
    await this.ready();
    if (opts.compact) {
      this.walState.operations.splice(0, this.walState.operations.length);
      this.walState.noLoaderOps.splice(0, this.walState.noLoaderOps.length);
      this.walState.noLoaderOps.push(dbMeta);
    } else if (opts.noLoader) {
      this.walState.noLoaderOps.push(dbMeta);
    } else {
      this.walState.operations.push(dbMeta);
    }
    await this.save(this.walState);
    if (!opts.noLoader) {
      void this.process();
    }
  }
  async enqueueFile(fileCid, publicFile = false) {
    await this.ready();
    this.walState.fileOperations.push({ cid: fileCid, public: publicFile });
  }
  async process() {
    await this.ready();
    await this.processQueue.enqueue(async () => {
      try {
        await this._doProcess();
      } catch (e) {
        this.logger.Error().Any("error", e).Msg("error processing wal");
      }
      if (this.walState.operations.length || this.walState.fileOperations.length || this.walState.noLoaderOps.length) {
        setTimeout(() => void this.process(), 0);
      }
    });
  }
  async _doProcess() {
    if (!this.loader) return;
    const operations = [...this.walState.operations];
    const noLoaderOps = [...this.walState.noLoaderOps];
    const fileOperations = [...this.walState.fileOperations];
    if (operations.length + noLoaderOps.length + fileOperations.length === 0) return;
    const concurrencyLimit = 3;
    const retryableUpload = (fn, description) => pRetry(fn, {
      retries: 5,
      onFailedAttempt: (error48) => {
        this.logger.Warn().Any("error", error48).Any("fn", fn.toString()).Msg(`Attempt ${error48.attemptNumber} failed for ${description}. There are ${error48.retriesLeft} retries left.`);
      }
    });
    try {
      await pMap(
        noLoaderOps,
        async (dbMeta) => {
          await retryableUpload(async () => {
            for (const cid of dbMeta.cars) {
              const car = await this.loader.attachedStores.local().active.car.load(cid);
              if (!car) {
                if (carLogIncludesGroup(this.loader.carLog.asArray(), dbMeta.cars)) {
                  throw this.logger.Error().Ref("cid", cid).Msg("missing local car").AsError();
                }
              }
            }
            inplaceFilter(this.walState.noLoaderOps, (op) => op !== dbMeta);
          }, `noLoaderOp with dbMeta.cars=${dbMeta.cars.toString()}`);
        },
        { concurrency: concurrencyLimit }
      );
      await pMap(
        operations,
        async (dbMeta) => {
          await retryableUpload(async () => {
            for (const cid of dbMeta.cars) {
              const car = await this.loader.attachedStores.local().active.car.load(cid);
              if (!car) {
                if (carLogIncludesGroup(this.loader.carLog.asArray(), dbMeta.cars)) {
                  throw this.logger.Error().Ref("cid", cid).Msg(`missing local car`).AsError();
                }
              }
            }
            inplaceFilter(this.walState.operations, (op) => op !== dbMeta);
          }, `operation with dbMeta.cars=${dbMeta.cars.toString()}`);
        },
        { concurrency: concurrencyLimit }
      );
      await pMap(
        fileOperations,
        async ({ cid: fileCid }) => {
          await retryableUpload(async () => {
            const fileBlock = await this.loader.attachedStores.local().active.file.load(fileCid);
            if (!fileBlock) {
              throw this.logger.Error().Ref("cid", fileCid).Msg("missing file block").AsError();
            }
            inplaceFilter(this.walState.fileOperations, (op) => op.cid !== fileCid);
          }, `fileOperation with cid=${fileCid.toString()}`);
        },
        { concurrency: concurrencyLimit }
      );
      if (operations.length) {
        const lastOp = operations[operations.length - 1];
        await retryableUpload(async () => {
          if (!this.loader) {
            return;
          }
        }, `remoteMetaStore save with dbMeta.cars=${lastOp.cars.toString()}`);
      }
    } catch (error48) {
      this.logger.Error().Any("error", error48).Msg("Processing failed");
      return;
    } finally {
      await this.save(this.walState);
    }
  }
  async load() {
    this.logger.Debug().Msg("loading");
    const filepath = await this.gateway.buildUrl({ loader: this.loader }, this.url(), "main");
    if (filepath.isErr()) {
      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg("error building url").AsError();
    }
    const bytes = await this.gateway.get({ loader: this.loader }, filepath.Ok());
    if (bytes.isErr()) {
      if (isNotFoundError(bytes)) {
        return void 0;
      }
      throw this.logger.Error().Err(bytes.Err()).Msg("error get").AsError();
    }
    if (bytes.Ok().type !== "wal") {
      throw this.logger.Error().Str("type", bytes.Ok().type).Msg("unexpected type").AsError();
    }
    return bytes.Ok().payload;
  }
  async save(state) {
    const filepath = await this.gateway.buildUrl({ loader: this.loader }, this.url(), "main");
    if (filepath.isErr()) {
      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg("error building url").AsError();
    }
    const res = await this.gateway.put({ loader: this.loader }, filepath.Ok(), {
      type: "wal",
      payload: state
    });
    if (res.isErr()) {
      throw this.logger.Error().Err(res.Err()).Str("filePath", filepath.Ok().toString()).Msg("error saving").AsError();
    }
  }
  async close() {
    await this.gateway.close({ loader: this.loader }, this.url());
    this._onClosed.forEach((fn) => fn());
    return Result.Ok(void 0);
  }
  destroy() {
    this.logger.Debug().Msg("destroy");
    return this.gateway.destroy({ loader: this.loader }, this.url());
  }
};

// core/blockstore/store-factory.ts
init_base2();

// core/blockstore/register-store-protocol.ts
init_esm();
init_base2();

// core/gateways/memory/gateway.ts
init_esm();
init_base2();

// core/gateways/memory/version.ts
var MEMORY_VERSION = "v0.19-memory";

// core/gateways/memory/gateway.ts
init_runtime2();
function cleanURI(uri) {
  return uri.build().cleanParams(
    PARAM.VERSION,
    PARAM.NAME,
    // PARAM.STORE,
    PARAM.STORE_KEY,
    PARAM.SELF_REFLECT,
    PARAM.LOCAL_NAME
  ).URI();
}
var MemoryGateway = class {
  memories;
  sthis;
  // readonly logger: Logger;
  constructor(sthis, memories) {
    this.memories = memories;
    this.sthis = sthis;
  }
  buildUrl(baseUrl, key) {
    return Promise.resolve(Result.Ok(baseUrl.build().setParam(PARAM.KEY, key).URI()));
  }
  start(baseUrl) {
    return Promise.resolve(Result.Ok(baseUrl.build().setParam(PARAM.VERSION, MEMORY_VERSION).URI()));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  close(baseUrl) {
    return Promise.resolve(Result.Ok(void 0));
  }
  destroy(baseUrl) {
    const keyUrl = cleanURI(baseUrl);
    const match2 = keyUrl.match(keyUrl);
    for (const key of this.memories.keys()) {
      if (keyUrl.match(key).score >= match2.score) {
        this.memories.delete(key);
      }
    }
    return Promise.resolve(Result.Ok(void 0));
  }
  // subscribe(url: URI, callback: (meta: Uint8Array) => void, sthis: SuperThis): Promise<UnsubscribeResult> {
  //   console.log("subscribe", url.toString());
  //   const callbackKey = `callbacks:${cleanURI(url).toString()}`;
  //   const callbacks = (this.memories.get(callbackKey) as Callbacks) ?? new Map<string, Callbacks>();
  //   const key = sthis.nextId().str;
  //   callbacks.set(key, callback);
  //   return Promise.resolve(
  //     Result.Ok(() => {
  //       callbacks.delete(key);
  //       if (callbacks.size === 0) {
  //         this.memories.delete(callbackKey);
  //       }
  //     }),
  //   );
  // }
  async put(url2, bytes, sthis) {
    if (url2.getParam(PARAM.STORE) === "car") {
      const logger = ensureLogger(sthis, "MemoryGatewayCar");
      logger.Debug().Url(url2).Msg("put-car");
    }
    if (url2.getParam(PARAM.STORE) === "meta") {
      const logger = ensureLogger(sthis, "MemoryGatewayMeta");
      logger.Debug().Url(url2).Msg("put-meta");
    }
    this.memories.set(cleanURI(url2).toString(), bytes);
    return Result.Ok(void 0);
  }
  // get could return a NotFoundError if the key is not found
  get(url2, sthis) {
    const x = this.memories.get(cleanURI(url2).toString());
    if (!x) {
      return Promise.resolve(Result.Err(new NotFoundError(`not found: ${url2.toString()}`)));
    }
    const logger = ensureLogger(sthis, "MemoryGateway");
    if (url2.getParam(PARAM.STORE) === "meta") {
      logger.Debug().Url(url2).Msg("get-meta");
    }
    if (url2.getParam(PARAM.STORE) === "car") {
      logger.Debug().Url(url2).Msg("get-car");
    }
    return Promise.resolve(Result.Ok(x));
  }
  delete(url2) {
    this.memories.delete(cleanURI(url2).toString());
    return Promise.resolve(Result.Ok(void 0));
  }
  async getPlain(url2, key) {
    const x = this.memories.get(cleanURI(url2).build().setParam(PARAM.KEY, key).toString());
    if (!x) {
      return Result.Err(new NotFoundError("not found"));
    }
    return Result.Ok(x);
  }
};

// core/blockstore/register-store-protocol.ts
init_base3();

// core/gateways/cloud/gateway.ts
init_esm();
init_base2();

// core/types/protocols/cloud/msg-types.zod.ts
init_v4();
init_base2();
var RoleSchema = external_exports.enum(["admin", "owner", "member"]);
var ReadWriteSchema = external_exports.enum(["read", "write"]);
var TenantClaimSchema = external_exports.object({
  id: external_exports.string(),
  role: RoleSchema
}).readonly();
var LedgerClaimSchema = external_exports.object({
  id: external_exports.string(),
  role: RoleSchema,
  right: ReadWriteSchema
}).readonly();
var TenantLedgerSchema = external_exports.object({
  appId: external_exports.string().optional(),
  tenant: external_exports.string(),
  ledger: external_exports.string()
}).readonly();
var FPCloudClaimSchema = JWTPayloadSchema.extend({
  userId: external_exports.string(),
  email: external_exports.email(),
  nickname: external_exports.string().optional(),
  provider: external_exports.enum(["github", "google"]).optional(),
  created: external_exports.coerce.date(),
  tenants: external_exports.array(TenantClaimSchema),
  ledgers: external_exports.array(LedgerClaimSchema),
  selected: TenantLedgerSchema
}).readonly();
var FPCloudClaimParseSchema = JWTPayloadSchema.extend({
  userId: external_exports.string(),
  email: external_exports.email(),
  nickname: external_exports.string().optional(),
  provider: external_exports.enum(["github", "google"]).optional(),
  // Transform string to Date if needed (common in JWT parsing)
  created: external_exports.union([external_exports.date(), external_exports.string().transform((str) => new Date(str)), external_exports.number().transform((num) => new Date(num))]),
  tenants: external_exports.array(TenantClaimSchema),
  ledgers: external_exports.array(LedgerClaimSchema),
  selected: TenantLedgerSchema
}).readonly();

// core/types/protocols/cloud/msg-types.ts
init_v4();
var VERSION = "FP-MSG-1.0";
function MsgIsError(rq) {
  return rq.type === "error";
}
function coerceFPStoreTypes(s) {
  const x = s?.trim();
  if (x === "meta" || x === "car" || x === "wal" || x === "file") {
    return x;
  }
  throw new Error(`Invalid FPStoreTypes: ${s}`);
}
function defaultGestalt(msgP, gestalt) {
  return {
    storeTypes: ["meta", "file", "car", "wal"],
    httpEndpoints: ["/fp"],
    wsEndpoints: ["/ws"],
    encodings: ["JSON"],
    protocolCapabilities: msgP.protocolCapabilities || ["reqRes", "stream"],
    auth: [],
    requiresAuth: false,
    data: msgP.hasPersistent ? {
      inband: true,
      outband: true
    } : void 0,
    meta: msgP.hasPersistent ? {
      inband: true,
      outband: true
    } : void 0,
    wal: msgP.hasPersistent ? {
      inband: true,
      outband: true
    } : void 0,
    reqTypes: [
      "reqOpen",
      "reqGestalt",
      // "reqSignedUrl",
      "reqSubscribeMeta",
      "reqPutMeta",
      "reqBindMeta",
      "reqDelMeta",
      "reqPutData",
      "reqGetData",
      "reqDelData",
      "reqPutWAL",
      "reqGetWAL",
      "reqDelWAL",
      "reqUpdateMeta"
    ],
    resTypes: [
      "resOpen",
      "resGestalt",
      // "resSignedUrl",
      "resSubscribeMeta",
      "resPutMeta",
      "resGetMeta",
      "resDelMeta",
      "resPutData",
      "resGetData",
      "resDelData",
      "resPutWAL",
      "resGetWAL",
      "resDelWAL",
      "updateMeta"
    ],
    eventTypes: ["updateMeta"],
    ...gestalt
  };
}
function buildReqGestalt(sthis, auth, gestalt, publish) {
  return {
    tid: sthis.nextId().str,
    auth,
    type: "reqGestalt",
    version: VERSION,
    gestalt,
    publish
  };
}
function MsgIsResGestalt(msg) {
  return msg.type === "resGestalt";
}
function buildReqOpen(sthis, auth, conn) {
  const req = {
    tid: sthis.nextId().str,
    auth,
    type: "reqOpen",
    version: VERSION,
    conn: {
      ...conn,
      reqId: conn.reqId || sthis.nextId().str
    }
  };
  return req;
}
function MsgIsWithConn(msg) {
  const mwc = msg.conn;
  return mwc && !!mwc.reqId && !!mwc.resId;
}
function MsgIsWithConnAuth(msg) {
  return MsgIsWithConn(msg) && !!msg.auth && typeof msg.auth.type === "string";
}
function MsgIsConnected(msg, qsid) {
  return MsgIsWithConn(msg) && msg.conn.reqId === qsid.reqId && msg.conn.resId === qsid.resId;
}
function MsgIsResOpen(msg) {
  return msg.type === "resOpen";
}
function buildReqClose(sthis, auth, conn) {
  return {
    tid: sthis.nextId().str,
    auth,
    type: "reqClose",
    version: VERSION,
    conn
  };
}
function buildErrorMsg(msgCtx, base2, error48, body, stack) {
  if (!stack && msgCtx.sthis.env.get("FP_STACK")) {
    stack = error48.stack?.split("\n");
  }
  const msg = {
    auth: base2.auth || { type: "error" },
    src: base2,
    type: "error",
    tid: base2.tid || "internal",
    message: error48.message,
    version: VERSION,
    body,
    stack
  };
  msgCtx.logger.Any("ErrorMsg", msg);
  return msg;
}
function MsgIsTenantLedger(msg) {
  if (MsgIsWithConnAuth(msg)) {
    const t = msg.tenant;
    return !!t && !!t.tenant && !!t.ledger;
  }
  return false;
}
var UCanAuthSchema = external_exports.object({
  type: external_exports.literal("ucan"),
  params: external_exports.object({
    tbd: external_exports.string()
  }).readonly()
}).readonly();
var FPJWKCloudAuthTypeSchema = external_exports.object({
  type: external_exports.literal("fp-cloud-jwk"),
  params: external_exports.object({
    jwk: external_exports.string()
  }).readonly()
}).readonly();
var BaseTokenParamSchemaBase = external_exports.object({
  alg: external_exports.string(),
  // defaults ES256
  issuer: external_exports.string(),
  audience: external_exports.string(),
  validFor: external_exports.number()
});
var BaseTokenParamSchema = BaseTokenParamSchemaBase.readonly();
var TokenForParamSchema = FPCloudClaimSchema.and(BaseTokenParamSchemaBase.partial()).readonly();
var FPCloudAuthTypeSchema = external_exports.object({
  type: external_exports.literal("fp-cloud"),
  params: external_exports.object({
    claim: TokenForParamSchema,
    jwk: external_exports.string()
  }).readonly()
}).readonly();
var ErrorAuthSchema = external_exports.object({
  type: external_exports.literal("error")
}).readonly();
var FPDeviceIdAuthSchema = external_exports.object({
  type: external_exports.literal("device-id"),
  params: external_exports.object({
    sessionToken: external_exports.string()
  }).readonly()
}).readonly();
var AuthTypeSchema = external_exports.discriminatedUnion("type", [
  UCanAuthSchema,
  FPJWKCloudAuthTypeSchema,
  FPCloudAuthTypeSchema,
  FPDeviceIdAuthSchema,
  ErrorAuthSchema
]);
var QSIdSchema = external_exports.object({
  reqId: external_exports.string(),
  resId: external_exports.string()
});
var MsgBaseSchema = external_exports.object({
  tid: external_exports.string(),
  type: external_exports.string(),
  version: external_exports.string(),
  auth: AuthTypeSchema
});
var MsgBaseSchemaReadonly = MsgBaseSchema.readonly();
var GestaltSchema = external_exports.object({
  storeTypes: external_exports.array(external_exports.enum(["meta", "car", "wal", "file"])),
  id: external_exports.string(),
  protocolCapabilities: external_exports.array(external_exports.enum(["reqRes", "stream"])),
  httpEndpoints: external_exports.array(external_exports.string()),
  wsEndpoints: external_exports.array(external_exports.string()),
  encodings: external_exports.array(external_exports.enum(["JSON", "CBOR"])),
  auth: external_exports.array(AuthTypeSchema),
  requiresAuth: external_exports.boolean(),
  data: external_exports.object({
    inband: external_exports.boolean(),
    outband: external_exports.boolean()
  }).optional(),
  meta: external_exports.object({
    inband: external_exports.literal(true),
    outband: external_exports.boolean()
  }).optional(),
  wal: external_exports.object({
    inband: external_exports.boolean(),
    outband: external_exports.boolean()
  }).optional(),
  reqTypes: external_exports.array(external_exports.string()),
  resTypes: external_exports.array(external_exports.string()),
  eventTypes: external_exports.array(external_exports.string())
});
var MethodSignedUrlParamSchema = external_exports.object({
  method: external_exports.enum(["GET", "PUT", "DELETE"]),
  store: external_exports.enum(["meta", "car", "wal", "file"])
});
var SignedUrlParamSchema = external_exports.object({
  path: external_exports.string().optional(),
  key: external_exports.string(),
  expires: external_exports.number().optional(),
  index: external_exports.string().optional()
});
var MethodParamsSchema = external_exports.object({
  methodParam: MethodSignedUrlParamSchema
});
var SignedUrlParamsSchema = external_exports.object({
  urlParam: SignedUrlParamSchema
});
var MethodSignedUrlParamsSchema = MethodParamsSchema.and(SignedUrlParamsSchema);
var ReqChatSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqChat"),
  conn: QSIdSchema,
  message: external_exports.string(),
  targets: external_exports.array(QSIdSchema)
}).readonly();
var ResChatSchema = MsgBaseSchema.extend({
  type: external_exports.literal("resChat"),
  conn: QSIdSchema,
  message: external_exports.string(),
  targets: external_exports.array(QSIdSchema)
}).readonly();
var ReqGestaltSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqGestalt"),
  gestalt: GestaltSchema,
  publish: external_exports.boolean().optional()
}).readonly();
var ResGestaltSchema = MsgBaseSchema.extend({
  type: external_exports.literal("resGestalt"),
  gestalt: GestaltSchema
}).readonly();
var ReqOpenConnSchema = external_exports.object({
  reqId: external_exports.string(),
  resId: external_exports.string().optional()
}).readonly();
var ReqOpenSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqOpen"),
  conn: ReqOpenConnSchema
}).readonly();
var ResOpenSchema = MsgBaseSchema.extend({
  type: external_exports.literal("resOpen"),
  conn: QSIdSchema
}).readonly();
var ReqCloseSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqClose"),
  conn: QSIdSchema
}).readonly();
var ResCloseSchema = MsgBaseSchema.extend({
  type: external_exports.literal("resClose"),
  conn: QSIdSchema
}).readonly();
var MsgConnAuthSchema = external_exports.object({
  conn: QSIdSchema,
  auth: AuthTypeSchema
}).readonly();
var ErrorMsgBaseSchema = external_exports.object({
  type: external_exports.literal("error"),
  src: external_exports.unknown(),
  message: external_exports.string(),
  body: external_exports.string().optional(),
  stack: external_exports.array(external_exports.string()).optional(),
  conn: QSIdSchema.partial().optional(),
  tid: external_exports.string(),
  version: external_exports.string(),
  auth: AuthTypeSchema
}).readonly();
var NotReadyErrorMsgSchema = external_exports.object({
  type: external_exports.literal("error"),
  src: external_exports.literal("not-ready"),
  message: external_exports.literal("Not Ready"),
  reason: external_exports.literal("not-ready"),
  body: external_exports.string().optional(),
  stack: external_exports.array(external_exports.string()).optional(),
  conn: QSIdSchema.partial().optional(),
  tid: external_exports.string(),
  version: external_exports.string(),
  auth: AuthTypeSchema
}).readonly();
var ErrorMsgSchema = external_exports.union([ErrorMsgBaseSchema, NotReadyErrorMsgSchema]);
var ConnInfoSchema = external_exports.object({
  connIds: external_exports.array(external_exports.string())
}).readonly();
var MsgerParamsSchema = external_exports.object({
  mime: external_exports.string(),
  auth: AuthTypeSchema.optional(),
  hasPersistent: external_exports.boolean().optional(),
  protocolCapabilities: external_exports.array(external_exports.enum(["reqRes", "stream"])).optional(),
  timeout: external_exports.number()
}).readonly();
var GwCtxSchema = external_exports.object({
  tid: external_exports.string().optional(),
  conn: QSIdSchema,
  tenant: TenantLedgerSchema
}).readonly();
var ReqGwCtxSchema = external_exports.object({
  tid: external_exports.string().optional(),
  conn: QSIdSchema.partial(),
  tenant: TenantLedgerSchema
}).readonly();
var GwCtxConnSchema = external_exports.object({
  tid: external_exports.string().optional(),
  conn: QSIdSchema,
  tenant: TenantLedgerSchema
}).readonly();
var ResSignedUrlSchema = MsgBaseSchema.extend({
  conn: QSIdSchema,
  tenant: TenantLedgerSchema,
  methodParam: MethodSignedUrlParamSchema,
  urlParam: SignedUrlParamSchema,
  signedUrl: external_exports.string()
});
var ResOptionalSignedUrlSchema = MsgBaseSchema.extend({
  conn: QSIdSchema,
  tenant: TenantLedgerSchema,
  urlParam: SignedUrlParamSchema,
  methodParam: MethodSignedUrlParamSchema,
  signedUrl: external_exports.string().optional()
});

// core/types/protocols/cloud/msg-types-data.ts
init_v4();
function MsgIsResGetData(msg) {
  return msg.type === "resGetData" && MsgIsTenantLedger(msg);
}
function MsgIsResPutData(msg) {
  return msg.type === "resPutData";
}
function MsgIsResDelData(msg) {
  return msg.type === "resDelData";
}
var ReqGetDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqGetData")
});
var ResGetDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resGetData")
});
var ReqPutDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqPutData")
});
var ResPutDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resPutData")
});
var ReqDelDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqDelData")
});
var ResDelDataSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resDelData")
});

// core/types/protocols/cloud/msg-types-meta.ts
init_v4();
function buildReqPutMeta(sthis, auth, signedUrlParam, meta3, gwCtx) {
  return {
    auth,
    type: "reqPutMeta",
    ...gwCtx,
    tid: gwCtx.tid ?? sthis.nextId().str,
    version: VERSION,
    methodParam: {
      method: "PUT",
      store: "meta"
    },
    urlParam: signedUrlParam,
    meta: meta3
  };
}
function MsgIsResPutMeta(qs) {
  return qs.type === "resPutMeta";
}
function buildBindGetMeta(sthis, auth, msp, gwCtx) {
  return {
    auth,
    ...gwCtx,
    tid: gwCtx.tid ?? sthis.nextId().str,
    type: "bindGetMeta",
    version: VERSION,
    ...msp
  };
}
function MsgIsEventGetMeta(qs) {
  return qs.type === "eventGetMeta";
}
function buildReqDelMeta(sthis, auth, param2, gwCtx, meta3) {
  return {
    auth,
    tid: sthis.nextId().str,
    tenant: gwCtx.tenant,
    conn: gwCtx.conn,
    urlParam: param2,
    meta: meta3,
    type: "reqDelMeta",
    version: VERSION
    // params: signedUrlParams,
  };
}
var V2SerializedMetaKeySchema = external_exports.any();
var ReqPutMetaSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqPutMeta"),
  conn: QSIdSchema.partial().optional(),
  tenant: TenantLedgerSchema,
  methodParam: MethodSignedUrlParamSchema,
  urlParam: SignedUrlParamSchema,
  meta: V2SerializedMetaKeySchema
});
var ResPutMetaValSchema = external_exports.object({
  type: external_exports.literal("resPutMeta"),
  meta: V2SerializedMetaKeySchema
});
var ResPutMetaSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resPutMeta"),
  meta: V2SerializedMetaKeySchema
});
var BindGetMetaSchema = MsgBaseSchema.extend({
  type: external_exports.literal("bindGetMeta"),
  conn: QSIdSchema.partial().optional(),
  tenant: TenantLedgerSchema,
  methodParam: MethodSignedUrlParamSchema,
  urlParam: SignedUrlParamSchema
});
var EventGetMetaSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("eventGetMeta"),
  meta: V2SerializedMetaKeySchema
});
var ReqDelMetaSchema = MsgBaseSchema.extend({
  type: external_exports.literal("reqDelMeta"),
  conn: QSIdSchema.partial().optional(),
  tenant: TenantLedgerSchema,
  urlParam: SignedUrlParamSchema,
  meta: V2SerializedMetaKeySchema.optional()
});
var ResDelMetaSchema = ResOptionalSignedUrlSchema.extend({
  type: external_exports.literal("resDelMeta")
});

// core/types/protocols/cloud/msg-types-wal.ts
init_v4();
var ReqGetWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqGetWAL")
});
var ResGetWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resGetWAL")
});
var ReqPutWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqPutWAL")
});
var ResPutWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resPutWAL")
});
var ReqDelWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("reqDelWAL")
});
var ResDelWALSchema = ResSignedUrlSchema.extend({
  type: external_exports.literal("resDelWAL")
});

// core/types/protocols/cloud/gateway-control.ts
init_esm();
var ToCloudName = "toCloud";
function hashableFPCloudRef(ref) {
  if (!ref) {
    return {};
  }
  const keys = ["base", "car", "file", "meta"];
  return Object.fromEntries(keys.filter((k) => ref[k]).map((k) => [k, URI.from(ref[k]).toString()]));
}

// core/gateways/cloud/gateway.ts
init_runtime2();
init_base3();

// core/protocols/cloud/http-connection.ts
init_esm();

// core/protocols/cloud/msger.ts
init_esm();

// core/protocols/cloud/ws-connection.ts
init_esm();

// core/protocols/cloud/msg-raw-connection-base.ts
var MsgRawConnectionBase = class {
  sthis;
  exchangedGestalt;
  constructor(sthis, exGestalt) {
    this.sthis = sthis;
    this.exchangedGestalt = exGestalt;
  }
  onErrorFns = /* @__PURE__ */ new Map();
  onError(fn) {
    const key = this.sthis.nextId().str;
    this.onErrorFns.set(key, fn);
    return () => this.onErrorFns.delete(key);
  }
  buildErrorMsg(msgCtx, msg, err) {
    const rmsg = Array.from(this.onErrorFns.values()).reduce((msg2, fn) => {
      return fn(msg2, err);
    }, msg);
    const emsg = buildErrorMsg(msgCtx, rmsg, err);
    msgCtx.logger.Error().Err(err).Any("msg", rmsg).Msg("connection error");
    return emsg;
  }
};

// core/protocols/cloud/ws-connection.ts
init_runtime2();
var WaitForTids = class {
  waitForTids = /* @__PURE__ */ new Map();
  start(sthis, logger, waitFor) {
    let timeout2 = void 0;
    if (typeof waitFor.timeout === "number" && waitFor.timeout > 0) {
      timeout2 = setTimeout(() => {
        this.waitForTids.delete(waitFor.tid);
        waitFor.future.resolve(
          buildErrorMsg(
            { logger, sthis },
            {
              tid: waitFor.tid
            },
            logger.Error().Any({ tid: waitFor }).Msg("Timeout").AsError()
          )
        );
      }, waitFor.timeout);
    }
    this.waitForTids.set(waitFor.tid, {
      opts: waitFor,
      timeout: timeout2
    });
  }
  stop(tid) {
    const item = this.waitForTids.get(tid);
    if (!item) {
      return;
    }
    if (item.timeout) {
      clearTimeout(item.timeout);
    }
    this.waitForTids.delete(tid);
  }
  resolve(msg) {
    const item = this.waitForTids.get(msg.tid);
    if (!item) {
      return void 0;
    }
    if (item.opts.waitFor(msg)) {
      if (item.timeout) {
        clearTimeout(item.timeout);
      }
      item.opts.future.resolve(msg);
    }
    return item;
  }
};
var DefaultRoundTripTime = 1e3;
var WSConnection = class extends MsgRawConnectionBase {
  logger;
  msgP;
  ws;
  // readonly baseURI: URI;
  #onMsg = /* @__PURE__ */ new Map();
  #onClose = /* @__PURE__ */ new Map();
  waitForTid = new WaitForTids();
  id;
  isReady = false;
  constructor(sthis, ws, msgP, exGestalt) {
    super(sthis, exGestalt);
    this.id = sthis.nextId().str;
    this.logger = ensureLogger(sthis, "WSConnection");
    this.msgP = msgP;
    this.ws = ws;
  }
  async start() {
    const onOpenFuture = new Future();
    const timer = setTimeout(() => {
      const err = this.logger.Error().Dur("timeout", this.msgP.timeout).Msg("Timeout").AsError();
      this.toMsg(buildErrorMsg(this, {}, err));
      onOpenFuture.resolve(Result.Err(err));
    }, this.msgP.timeout);
    this.ws.onopen = () => {
      this.isReady = true;
      onOpenFuture.resolve(Result.Ok(void 0));
    };
    this.ws.onerror = (ierr) => {
      const err = this.logger.Error().Err(ierr).Msg("WS Error").AsError();
      onOpenFuture.resolve(Result.Err(err));
      const res = this.buildErrorMsg(this, {}, err);
      this.toMsg(res);
    };
    this.ws.onmessage = (evt) => {
      if (!this.isReady) {
        this.toMsg(buildErrorMsg(this, {}, this.logger.Error().Msg("Received message before onOpen").AsError()));
      }
      this.#wsOnMessage(evt);
    };
    this.ws.onclose = () => {
      this.isReady = false;
      this.close().catch((ierr) => {
        const err = this.logger.Error().Err(ierr).Msg("close error").AsError();
        onOpenFuture.resolve(Result.Err(err));
        this.toMsg(buildErrorMsg(this, { tid: "internal" }, err));
      });
    };
    const rOpen = await onOpenFuture.asPromise().finally(() => {
      clearTimeout(timer);
    });
    if (rOpen.isErr()) {
      return rOpen;
    }
    return Result.Ok(void 0);
  }
  #wsOnMessage = async (event) => {
    const rMsg = await exception2Result(async () => {
      const msg2 = this.msgP.ende.decode(await top_uint8(event.data));
      return msg2;
    });
    if (rMsg.isErr()) {
      this.logger.Error().Err(rMsg).Any({ event }).Msg("Invalid message");
      return;
    }
    const msg = rMsg.Ok();
    this.waitForTid.resolve(msg);
    Array.from(this.#onMsg.values()).forEach((cb) => {
      cb(msg);
    });
  };
  async close() {
    this.#onClose.forEach((fn) => fn());
    this.#onClose.clear();
    this.#onMsg.clear();
    this.ws.close();
    return Result.Ok(void 0);
  }
  toMsg(msg) {
    this.#onMsg.forEach((fn) => fn(msg));
    return msg;
  }
  send(msg) {
    this.ws.send(this.msgP.ende.encode(msg));
    return Promise.resolve(msg);
  }
  onMsg(fn) {
    const key = this.sthis.nextId().str;
    this.#onMsg.set(key, fn);
    return () => this.#onMsg.delete(key);
  }
  onClose(fn) {
    const key = this.sthis.nextId().str;
    this.#onClose.set(key, fn);
    return () => this.#onClose.delete(key);
  }
  activeBinds = /* @__PURE__ */ new Map();
  bind(req, opts) {
    const state = {
      id: this.sthis.nextId().str,
      bind: {
        msg: req,
        opts
      },
      // timeout: undefined,
      controller: void 0
    };
    this.activeBinds.set(state.id, state);
    const ret = new ReadableStream({
      cancel: () => {
        this.activeBinds.delete(state.id);
      },
      start: (controller) => {
        state.controller = controller;
        this.onMsg((msg) => {
          try {
            if (MsgIsError(msg)) {
              controller.enqueue(msg);
              return;
            }
            if (!opts.waitFor) {
              controller.enqueue(msg);
            } else if (opts.waitFor(msg)) {
              controller.enqueue(msg);
            }
          } catch (err) {
            this.logger.Error().Err(err).Any({ msg }).Msg("Error in onMsg callback[ignored]");
          }
        });
        this.send(req);
        const future = new Future();
        this.waitForTid.start(this.sthis, this.logger, { tid: req.tid, future, waitFor: opts.waitFor });
        future.asPromise().then((msg) => {
          if (MsgIsError(msg)) {
            controller.enqueue(msg);
            controller.close();
          }
        });
      }
    });
    return ret;
  }
  async request(req, opts) {
    const future = new Future();
    this.waitForTid.start(this.sthis, this.logger, {
      tid: req.tid,
      future,
      waitFor: opts.waitFor,
      timeout: opts.timeout ?? DefaultRoundTripTime
    });
    await this.send(req);
    return future.asPromise();
  }
  // toOnMessage<T extends MsgBase>(msg: WithErrorMsg<T>): Result<WithErrorMsg<T>> {
  //   this.mec.msgFn?.(msg as unknown as MessageEvent<MsgBase>);
  //   return Result.Ok(msg);
  // }
};

// core/protocols/cloud/msger.ts
init_runtime2();
function selectRandom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}
function timeout(ms, promise2) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`TIMEOUT after ${ms}ms`));
    }, ms);
    promise2.then(resolve).catch(reject).finally(() => clearTimeout(timer));
  });
}
function jsonEnDe(sthis) {
  return {
    encode: (node) => sthis.txt.encode(JSON.stringify(node)),
    decode: (data) => JSON.parse(sthis.txt.decode(data))
  };
}
function defaultMsgParams(sthis, igs) {
  return {
    mime: "application/json",
    ende: jsonEnDe(sthis),
    timeout: 3e3,
    protocolCapabilities: ["reqRes", "stream"],
    ...igs
  };
}
async function authTypeFromUri(logger, curi) {
  const uri = URI.from(curi);
  const authJWK = uri.getParam("authJWK");
  if (!authJWK) {
    return logger.Error().Url(uri).Msg("authJWK is required").ResultError();
  }
  return Result.Ok({
    type: "fp-cloud-jwk",
    params: {
      // claim: fpc.Ok().payload,
      jwk: authJWK
    }
  });
}
function initialFPUri(curl) {
  let gestaltUrl = URI.from(curl);
  if (["", "/"].includes(gestaltUrl.pathname)) {
    gestaltUrl = gestaltUrl.build().appendRelative("/fp").URI();
  }
  return gestaltUrl;
}
var Msger = class {
  static connect(sthis, curl, mParam) {
    const vc = new VirtualConnected(sthis, {
      curl,
      conn: mParam.conn,
      openWSorHttp: mParam.mowh,
      msgerParams: mParam.msgerParam ?? {}
    });
    return Promise.resolve(Result.Ok(vc));
  }
  constructor() {
  }
};
var MsgOpenWSAndHttp = class {
  async openHttp(vc, urls, msgP, exGestalt) {
    return Result.Ok(new HttpConnection(vc, urls, msgP, exGestalt));
  }
  async openWS(vc, url2, msgP, exGestalt) {
    url2 = url2.build().defParam("random", vc.nextId().str).URI();
    const wsUrl = ensurePath(url2, "ws");
    let wsFactory;
    if (runtimeFn().isNodeIsh) {
      const { WebSocket: WebSocket2 } = await Promise.resolve().then(() => __toESM(require_browser(), 1));
      wsFactory = () => new WebSocket2(wsUrl);
    } else {
      wsFactory = () => new WebSocket(wsUrl);
    }
    const wsc = new WSConnection(vc, wsFactory(), msgP, exGestalt);
    return Result.Ok(wsc);
  }
};
var VirtualConnected = class {
  sthis;
  // readonly actionQueue: ActionsQueue;
  opts;
  mowh;
  logger;
  id;
  exchangedGestalt;
  // readonly actionQueue: ActionsQueue;
  realConn;
  retries = [];
  virtualConn;
  constructor(sthis, opts) {
    this.sthis = sthis;
    this.id = sthis.nextId().str;
    this.logger = ensureLogger(sthis, "VirtualConnected");
    this.opts = {
      ...opts,
      openWSorHttp: opts.openWSorHttp || new MsgOpenWSAndHttp(),
      retryCount: opts.retryCount || 3,
      retryDelay: opts.retryDelay || 500,
      conn: { reqId: sthis.nextId().str, ...opts.conn }
      // ensure conn has reqId
    };
    this.mowh = this.opts.openWSorHttp;
  }
  get conn() {
    if (!this.virtualConn) {
      const err = new Error("conn is not set");
      throw err;
    }
    return this.virtualConn;
  }
  activeBinds = /* @__PURE__ */ new Map();
  async handleBindRealConn(realConn, req, as) {
    const conn = { ...this.conn, ...req.conn };
    const stream = realConn.bind({ ...as.bind.msg, auth: req.auth, conn }, as.bind.opts);
    const sreader = stream.getReader();
    while (true) {
      const { done, value: msg } = await sreader.read();
      if (done) {
        return;
      }
      try {
        if (MsgIsConnected(msg, this.conn) || MsgIsConnected(msg, conn)) {
          as.controller?.enqueue(msg);
        }
      } catch (err) {
        this.sthis.logger.Error().Err(err).Any({ msg }).Msg("Error in handleBindRealConn callback[ignored]");
      }
    }
  }
  ensureOpts(opts) {
    return {
      ...opts,
      timeout: opts.timeout ?? this.opts.msgerParams.timeout ?? 3e3
    };
  }
  bind(req, iopts) {
    const opts = this.ensureOpts(iopts);
    const id = this.sthis.nextId().str;
    return new ReadableStream({
      cancel: (err) => {
        this.sthis.logger.Debug().Msg("vc-bind-cancel", id, err);
        this.activeBinds.delete(id);
      },
      start: (ctl) => {
        this.getRealConn(req, opts, async (realConn) => {
          const as = {
            id,
            bind: {
              msg: req,
              opts
            },
            controller: ctl
          };
          this.activeBinds.set(id, as);
          this.handleBindRealConn(realConn, req, as);
          return Result.Ok(void 0);
        }).catch((err) => {
          ctl.error({
            type: "error",
            src: "VirtualConnection:bind",
            message: err.message,
            tid: req.tid,
            version: req.version,
            auth: req.auth,
            stack: []
          });
        });
      }
    });
  }
  request(req, iopts) {
    const opts = this.ensureOpts(iopts);
    const realFn = (realConn) => realConn.request(
      {
        ...req,
        conn: { ...this.virtualConn, ...req.conn }
      },
      opts
    );
    if (opts.rawConn) {
      return realFn(opts.rawConn);
    }
    return this.getRealConn(req, opts, realFn);
  }
  send(msg) {
    return this.getRealConn(
      msg,
      {
        waitFor: () => true
      },
      async (realConn) => {
        const myMsg = {
          ...msg,
          conn: { ...this.conn, ...msg.conn }
        };
        const ret = await realConn.send(myMsg);
        return ret;
      }
    );
  }
  close(t) {
    return this.getRealConn(
      t,
      {
        waitFor: () => true,
        noRetry: true
      },
      (realConn) => realConn.close(t)
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMsg(msgFn) {
    throw new Error("Method not implemented.");
  }
  async connect(auth, curl, imsgP = {}) {
    const jsMsgP = defaultMsgParams(this.sthis, { ...imsgP, mime: "application/json", ende: jsonEnDe(this.sthis) });
    const gestaltUrl = initialFPUri(curl);
    const gs = defaultGestalt(defaultMsgParams(this.sthis, imsgP), { id: "FP-Universal-Client" });
    const rHC = await this.mowh.openHttp(this.sthis, [gestaltUrl], jsMsgP, { my: gs, remote: gs });
    if (rHC.isErr()) {
      return rHC;
    }
    const hc = rHC.Ok();
    const resGestalt = await hc.request(buildReqGestalt(this.sthis, auth, gs), {
      waitFor: MsgIsResGestalt,
      noConn: true
    });
    if (!MsgIsResGestalt(resGestalt)) {
      return this.logger.Error().Any({ resGestalt }).Msg("should be ResGestalt").ResultError();
    }
    await hc.close(
      resGestalt
      /* as MsgWithConnAuth */
    );
    const exGt = { my: gs, remote: resGestalt.gestalt };
    const msgP = defaultMsgParams(this.sthis, imsgP);
    this.exchangedGestalt = exGt;
    let rRealConn;
    if (exGt.remote.protocolCapabilities.includes("reqRes") && !exGt.remote.protocolCapabilities.includes("stream")) {
      rRealConn = await this.mowh.openHttp(
        this.sthis,
        exGt.remote.httpEndpoints.map((i) => BuildURI.from(curl).resolve(i).URI()),
        msgP,
        exGt
      );
    } else {
      const wsUrl = BuildURI.from(gestaltUrl).resolve(selectRandom(exGt.remote.wsEndpoints)).URI();
      rRealConn = await this.mowh.openWS(this.sthis, wsUrl, msgP, exGt);
    }
    if (rRealConn.isErr()) {
      return rRealConn;
    }
    const realConn = rRealConn.Ok();
    const rStart = await realConn.start();
    if (rStart.isErr()) {
      return Result.Err(rStart);
    }
    return rRealConn;
  }
  async getQSIdWithSideEffect(rawConn, msg, conn) {
    const mOpen = await this.request(buildReqOpen(this.sthis, msg.auth, conn), {
      waitFor: MsgIsResOpen,
      noConn: true,
      rawConn
    });
    if (MsgIsError(mOpen)) {
      return mOpen;
    }
    this.virtualConn = mOpen.conn;
    return mOpen;
  }
  mutex = pLimit(1);
  async getRealConn(msg, iopts, action) {
    const opts = this.ensureOpts(iopts);
    const whatToDo = await this.mutex(async () => {
      if (!this.realConn) {
        if (this.retries.length >= this.opts.retryCount) {
          return {
            whatToDo: "return",
            value: {
              type: "error",
              src: "VirtualConnection:getRealConn",
              message: "retry count exceeded",
              tid: msg.tid,
              version: msg.version,
              auth: msg.auth,
              stack: []
            }
          };
        }
        const rConn = await this.connect(msg.auth, this.opts.curl, this.opts.msgerParams);
        if (rConn.isErr()) {
          this.retries.push({ retryCount: this.retries.length + 1 });
          await sleep2(this.opts.retryDelay * this.retries.length);
          return {
            whatToDo: "recurse"
            // this.getRealConn(msg, opts, action);
          };
        }
        this.realConn = rConn.Ok();
        const mQSid = await this.getQSIdWithSideEffect(this.realConn, msg, {
          reqId: this.sthis.nextId().str,
          ...this.virtualConn,
          ...this.opts.conn
        });
        if (MsgIsError(mQSid)) {
          return {
            whatToDo: "return",
            value: {
              ...mQSid,
              tid: msg.tid
              // type: msg.type,
            }
          };
        }
        for (const as of this.activeBinds.values()) {
          void this.handleBindRealConn(this.realConn, msg, as);
        }
        return {
          whatToDo: "recurse"
        };
      } else {
        if (!this.realConn.isReady) {
          await this.realConn.close(msg);
          this.realConn = void 0;
          this.retries = [];
          return { whatToDo: "recurse" };
        }
        if (!opts.noConn && !this.virtualConn) {
          const conn = MsgIsWithConn(msg) ? { conn: msg.conn } : {};
          return {
            whatToDo: "return",
            value: {
              type: "error",
              src: msg,
              message: "virtualConn is not set",
              tid: msg.tid,
              ...conn,
              version: msg.version,
              auth: msg.auth,
              stack: []
            }
          };
        }
        return {
          whatToDo: "action"
        };
      }
    });
    switch (whatToDo.whatToDo) {
      case "recurse":
        return this.getRealConn(msg, opts, action);
      case "return":
        return whatToDo.value;
      case "action":
        if (!this.realConn) {
          throw new Error("realConn is not set, this should not happen");
        }
        return action(this.realConn);
      default:
        throw new Error(`Unknown action: ${whatToDo.whatToDo} for msg: ${msg.type} with id: ${this.id}`);
    }
  }
};

// core/protocols/cloud/http-connection.ts
init_runtime2();
function toHttpProtocol(uri) {
  const protocol = (uri.getParam("protocol") ?? uri.protocol).replace(/:$/, "");
  const toFix = uri.build();
  switch (protocol) {
    case "ws":
    case "http":
      toFix.protocol("http");
      break;
    case "https":
    case "wss":
    default:
      toFix.protocol("https");
      break;
  }
  return toFix.URI();
}
function ensurePath(uri, fp) {
  const path = uri.pathname.replace(/\/$/, "").replace(/^\//, "");
  const buri = uri.build();
  if (path === "") {
    buri.appendRelative(fp);
  }
  return buri.toString();
}
var HttpConnection = class extends MsgRawConnectionBase {
  logger;
  msgP;
  baseURIs;
  #onMsg = /* @__PURE__ */ new Map();
  isReady = true;
  constructor(sthis, uris, msgP, exGestalt) {
    super(sthis, exGestalt);
    this.logger = ensureLogger(sthis, "HttpConnection");
    this.baseURIs = uris.map((uri) => ({
      in: uri,
      cleaned: toHttpProtocol(uri)
    }));
    this.msgP = msgP;
  }
  send(_msg) {
    throw new Error("Method not implemented.");
  }
  async start() {
    return Result.Ok(void 0);
  }
  async close() {
    await Promise.all(Array.from(this.activeBinds.values()).map((state) => state.controller?.close()));
    this.#onMsg.clear();
    return Result.Ok(void 0);
  }
  toMsg(msg) {
    this.#onMsg.forEach((fn) => fn(msg));
    return msg;
  }
  onMsg(fn) {
    const key = this.sthis.nextId().str;
    this.#onMsg.set(key, fn);
    return () => this.#onMsg.delete(key);
  }
  #poll(state) {
    this.request(state.bind.msg, state.bind.opts).then((msg) => {
      try {
        state.controller?.enqueue(msg);
        if (MsgIsError(msg)) {
          state.controller?.close();
        } else {
          state.timeout = setTimeout(() => this.#poll(state), state.bind.opts.pollInterval ?? 1e3);
        }
      } catch (err) {
        state.controller?.error(err);
        state.controller?.close();
      }
    }).catch((err) => {
      state.controller?.error(err);
    });
  }
  activeBinds = /* @__PURE__ */ new Map();
  bind(req, opts) {
    const state = {
      id: this.sthis.nextId().str,
      bind: {
        msg: req,
        opts
      }
    };
    this.activeBinds.set(state.id, state);
    return new ReadableStream({
      cancel: () => {
        clearTimeout(state.timeout);
        this.activeBinds.delete(state.id);
      },
      start: (controller) => {
        state.controller = controller;
        this.#poll(state);
      }
    });
  }
  async request(req, _opts) {
    const headers = HttpHeader.from();
    headers.Set("Content-Type", this.msgP.mime);
    headers.Set("Accept", this.msgP.mime);
    const rReqBody = exception2Result(() => this.msgP.ende.encode(req));
    if (rReqBody.isErr()) {
      return this.toMsg(
        buildErrorMsg(this, req, this.logger.Error().Err(rReqBody.Err()).Any("req", req).Msg("encode error").AsError())
      );
    }
    headers.Set("Content-Length", rReqBody.Ok().byteLength.toString());
    const url2 = selectRandom(this.baseURIs);
    this.logger.Debug().Any(url2).Any("body", req).Msg("request");
    const rRes = await exception2Result(
      () => timeout(
        this.msgP.timeout,
        fetch(ensurePath(url2.cleaned, "fp"), {
          method: "PUT",
          headers: headers.AsHeaderInit(),
          body: rReqBody.Ok()
        })
      )
    );
    this.logger.Debug().Any(url2).Any("body", rRes).Msg("response");
    if (rRes.isErr()) {
      return this.toMsg(buildErrorMsg(this, req, this.logger.Error().Err(rRes).Any(url2).Msg("fetch error").AsError()));
    }
    const res = rRes.Ok();
    if (!res.ok) {
      const data2 = new Uint8Array(await res.arrayBuffer());
      const ret2 = await exception2Result(async () => this.msgP.ende.decode(data2));
      if (ret2.isErr() || !MsgIsError(ret2.Ok())) {
        return this.toMsg(
          buildErrorMsg(
            this,
            req,
            this.logger.Error().Any(url2).Str("status", res.status.toString()).Str("statusText", res.statusText).Msg("HTTP Error").AsError(),
            await res.text().catch(() => "no body")
          )
        );
      }
      return this.toMsg(ret2.Ok());
    }
    const data = new Uint8Array(await res.arrayBuffer());
    const ret = await exception2Result(async () => this.msgP.ende.decode(data));
    if (ret.isErr()) {
      return this.toMsg(
        buildErrorMsg(this, req, this.logger.Error().Err(ret.Err()).Msg("decode error").AsError(), this.sthis.txt.decode(data))
      );
    }
    return this.toMsg(ret.Ok());
  }
  // toOnMessage<T extends MsgBase>(msg: WithErrorMsg<T>): Result<WithErrorMsg<T>> {
  //   this.mec.msgFn?.(msg as unknown as MessageEvent<MsgBase>);
  //   return Result.Ok(msg);
  // }
};

// core/gateways/cloud/gateway.ts
var VERSION2 = "v0.1-fp-cloud";
var BaseGateway = class {
  logger;
  sthis;
  constructor(sthis, module) {
    this.sthis = sthis;
    this.logger = ensureLogger(sthis, module);
  }
  async buildReqSignedUrl(type, method, store, uri, conn) {
    const rParams = uri.getParamsResult({
      key: param.REQUIRED,
      store: param.REQUIRED,
      path: param.OPTIONAL,
      tenant: param.REQUIRED,
      ledger: param.REQUIRED,
      name: param.REQUIRED,
      index: param.OPTIONAL
    });
    if (rParams.isErr()) {
      return buildErrorMsg(this, {}, rParams.Err());
    }
    const params = rParams.Ok();
    if (store !== params.store) {
      return buildErrorMsg(this, {}, new Error("store mismatch"));
    }
    const rAuth = await authTypeFromUri(this.logger, uri);
    if (rAuth.isErr()) {
      return buildErrorMsg(this, {}, rAuth.Err());
    }
    return {
      tid: this.sthis.nextId().str,
      auth: rAuth.Ok(),
      type,
      conn: { ...conn.conn.Ok().opts.conn },
      tenant: {
        tenant: params.tenant,
        ledger: params.ledger
      },
      // tenant: conn.tenant,
      methodParam: {
        method,
        store
      },
      urlParam: {
        ...params,
        key: params.key
      },
      version: VERSION2
    };
  }
  async getReqSignedUrl(type, method, store, waitForFn, uri, conn) {
    const rsu = await this.buildReqSignedUrl(type, method, store, uri, conn);
    if (MsgIsError(rsu)) {
      return rsu;
    }
    return conn.conn.Ok().request(rsu, { waitFor: waitForFn });
  }
  async putObject(uri, uploadUrl, body, conn) {
    this.logger.Debug().Any("url", { uploadUrl, uri }).Msg("put-fetch-url");
    const rUpload = await exception2Result(async () => fetch(uploadUrl, { method: "PUT", body }));
    if (rUpload.isErr()) {
      return this.logger.Error().Url(uploadUrl, "uploadUrl").Err(rUpload).Msg("Expection in put fetch").ResultError();
    }
    if (!rUpload.Ok().ok) {
      return this.logger.Error().Url(uploadUrl, "uploadUrl").Http(rUpload.Ok()).Msg("Status in put fetch").ResultError();
    }
    await rUpload.Ok().arrayBuffer();
    if (uri.getParam("testMode")) {
      conn.citem.trackPuts.add(uri.toString());
    }
    return Result.Ok(void 0);
  }
  async getObject(uri, downloadUrl, _conn) {
    this.logger.Debug().Any("url", { downloadUrl, uri }).Msg("get-fetch-url");
    const rDownload = await exception2Result(async () => fetch(downloadUrl.toString(), { method: "GET" }));
    if (rDownload.isErr()) {
      return this.logger.Error().Url(downloadUrl, "downloadUrl").Err(rDownload).Msg("Error in get downloadUrl").ResultError();
    }
    const download = rDownload.Ok();
    if (!download.ok) {
      if (download.status === 404) {
        return Result.Err(new NotFoundError("Not found"));
      }
      return this.logger.Error().Url(downloadUrl, "downloadUrl").Err(rDownload).Msg("Error in get fetch").ResultError();
    }
    return Result.Ok(to_uint8(await download.arrayBuffer()));
  }
  async delObject(uri, deleteUrl, _conn) {
    this.logger.Debug().Any("url", { deleteUrl, uri }).Msg("get-fetch-url");
    const rDelete = await exception2Result(async () => fetch(deleteUrl.toString(), { method: "DELETE" }));
    if (rDelete.isErr()) {
      return this.logger.Error().Url(deleteUrl, "deleteUrl").Err(rDelete).Msg("Error in get deleteURL").ResultError();
    }
    const download = rDelete.Ok();
    if (!download.ok) {
      if (download.status === 404) {
        return Result.Err(new NotFoundError("Not found"));
      }
      return this.logger.Error().Url(deleteUrl, "deleteUrl").Err(rDelete).Msg("Error in del fetch").ResultError();
    }
    return Result.Ok(void 0);
  }
};
var DataGateway = class extends BaseGateway {
  constructor(sthis) {
    super(sthis, "Cloud-DataGateway");
  }
  async get(ctx, uri) {
    const store = coerceFPStoreTypes(uri.getParam("store"));
    const rResSignedUrl = await this.getReqSignedUrl("reqGetData", "GET", store, MsgIsResGetData, uri, ctx.conn);
    if (MsgIsError(rResSignedUrl)) {
      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
    }
    const { signedUrl: downloadUrl } = rResSignedUrl;
    const r = await fpDeserialize(this.sthis, uri, this.getObject(uri, downloadUrl, ctx.conn));
    return r;
  }
  async put(ctx, uri, data) {
    const store = coerceFPStoreTypes(uri.getParam("store"));
    const rResSignedUrl = await this.getReqSignedUrl("reqPutData", "PUT", store, MsgIsResPutData, uri, ctx.conn);
    if (MsgIsError(rResSignedUrl)) {
      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
    }
    const { signedUrl: uploadUrl } = rResSignedUrl;
    const rBlob = await fpSerialize(ctx.loader.sthis, data);
    if (rBlob.isErr()) {
      return rBlob;
    }
    const r = await this.putObject(uri, uploadUrl, rBlob.Ok(), ctx.conn);
    return r;
  }
  async delete(ctx, uri) {
    const store = coerceFPStoreTypes(uri.getParam("store"));
    const rResSignedUrl = await this.getReqSignedUrl("reqDelData", "DELETE", store, MsgIsResDelData, uri, ctx.conn);
    if (MsgIsError(rResSignedUrl)) {
      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
    }
    const { signedUrl: deleteUrl } = rResSignedUrl;
    return this.delObject(uri, deleteUrl, ctx.conn);
  }
};
function getGwCtx(conn, uri) {
  const rParams = uri.getParamsResult({
    tid: param.OPTIONAL,
    tenant: param.REQUIRED,
    ledger: param.REQUIRED
  });
  if (rParams.isErr()) {
    return Result.Err(rParams);
  }
  const r = rParams.Ok();
  return Result.Ok({
    tid: r.tid,
    conn,
    tenant: {
      tenant: r.tenant,
      ledger: r.ledger
    }
  });
}
var CurrentMeta = class {
  // readonly boundGetMeta = new KeyedResolvOnce<ReadableStream<MsgWithError<EventGetMeta>>>();
  boundGetMeta = new KeyedResolvOnce();
  currentMeta = new KeyedResolvOnce();
  valueReady = new Future();
  value;
  subscriptions;
  constructor(subscriptions2) {
    this.subscriptions = subscriptions2;
  }
  async get(ctx, authType, reqSignedUrl, gwCtx) {
    const key = hashObjectSync(ctx.conn.conn.Ok());
    const item = this.boundGetMeta.get(key);
    item.once(async () => {
      const res = ctx.conn.conn.Ok().bind(buildBindGetMeta(ctx.loader.sthis, authType, reqSignedUrl, gwCtx), {
        waitFor: MsgIsEventGetMeta
      });
      const sreader = res.getReader();
      while (true) {
        const { done, value: msg } = await sreader.read();
        if (done) {
          break;
        }
        if (MsgIsError(msg)) {
          ctx.loader.logger.Error().Err(msg).Msg("Error in bindGetMeta");
          this.valueReady.resolve();
          this.valueReady = new Future();
          this.currentMeta.get(key).reset();
          return;
        }
        if (MsgIsEventGetMeta(msg)) {
          const rV2Meta = await V2SerializedMetaKeyExtractKey(ctx, msg.meta);
          const r = await decode2DbMetaEvents(ctx.loader.sthis, rV2Meta);
          let value;
          if (r.isErr()) {
            value = Result.Err(r);
          } else {
            value = Result.Ok({
              type: "meta",
              payload: r.Ok()
            });
          }
          this.value = value;
          this.valueReady.resolve();
          this.valueReady = new Future();
          this.currentMeta.get(key).reset();
          if (value.isOk()) {
            for (const cb of this.subscriptions.values()) {
              await cb(value.Ok());
            }
          }
        }
      }
      ctx.loader.logger.Error().Msg("Error bind should not end");
    }).catch((err) => {
      ctx.loader.logger.Error().Err(err).Msg("Error in bindGetMeta");
    });
    return this.currentMeta.get(key).once(async () => {
      if (!this.value) {
        await this.valueReady.asPromise();
      }
      const rDbMeta = this.value;
      if (!rDbMeta) {
        return ctx.loader.logger.Error().Msg("No value").ResultError();
      }
      return rDbMeta;
    });
  }
};
var MetaGateway = class extends BaseGateway {
  subscriptions = /* @__PURE__ */ new Map();
  currentMeta = new CurrentMeta(this.subscriptions);
  constructor(sthis) {
    super(sthis, "Cloud-MetaGateway");
  }
  async subscribe(ctx, uri, callback) {
    const key = ctx.loader.sthis.nextId().str;
    const unsub = () => {
      this.subscriptions.delete(key);
    };
    this.subscriptions.set(key, callback);
    return Result.Ok(unsub);
  }
  async get(ctx, uri) {
    const reqSignedUrl = await this.buildReqSignedUrl("bindGetMeta", "GET", "meta", uri, ctx.conn);
    if (MsgIsError(reqSignedUrl)) {
      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
    }
    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().opts.conn, uri);
    if (rGwCtx.isErr()) {
      return Result.Err(rGwCtx);
    }
    const rAuthType = await authTypeFromUri(this.logger, uri);
    if (rAuthType.isErr()) {
      return Result.Err(rAuthType);
    }
    const rMeta = await this.currentMeta.get(ctx, rAuthType.Ok(), reqSignedUrl, rGwCtx.Ok());
    if (rMeta.isErr()) {
      return Result.Err(rMeta);
    }
    return Result.Ok(rMeta.Ok());
  }
  async put(ctx, uri, imeta) {
    const meta3 = imeta;
    const reqSignedUrl = await this.buildReqSignedUrl("reqPutMeta", "PUT", "meta", uri, ctx.conn);
    if (MsgIsError(reqSignedUrl)) {
      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
    }
    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().opts.conn, uri);
    if (rGwCtx.isErr()) {
      return Result.Err(rGwCtx);
    }
    const rAuthType = await authTypeFromUri(this.logger, uri);
    if (rAuthType.isErr()) {
      return Result.Err(rAuthType);
    }
    const serializedMeta = await dbMetaEvent2Serialized(ctx.loader.sthis, meta3.payload);
    const rKeyedMeta = await encodeAsV2SerializedMetaKey(ctx, serializedMeta);
    if (rKeyedMeta.isErr()) {
      return rKeyedMeta;
    }
    const reqPutMeta = buildReqPutMeta(ctx.loader.sthis, rAuthType.Ok(), reqSignedUrl.urlParam, rKeyedMeta.Ok(), rGwCtx.Ok());
    const resMsg = await ctx.conn.conn.Ok().request(reqPutMeta, {
      waitFor: MsgIsResPutMeta
    });
    if (MsgIsError(resMsg)) {
      return this.logger.Error().Err(resMsg).Msg("Error in buildResSignedUrl").ResultError();
    }
    return Result.Ok(void 0);
  }
  async delete(ctx, uri) {
    const reqSignedUrl = await this.getReqSignedUrl("reqDelMeta", "DELETE", "meta", MsgIsResDelData, uri, ctx.conn);
    if (MsgIsError(reqSignedUrl)) {
      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
    }
    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().opts.conn, uri);
    if (rGwCtx.isErr()) {
      return Result.Err(rGwCtx);
    }
    const rAuthType = await authTypeFromUri(this.logger, uri);
    if (rAuthType.isErr()) {
      return Result.Err(rAuthType);
    }
    const reqDelMeta = buildReqDelMeta(ctx.loader.sthis, rAuthType.Ok(), reqSignedUrl.urlParam, rGwCtx.Ok());
    const resMsg = await ctx.conn.conn.Ok().request(reqDelMeta, {
      waitFor: MsgIsResDelData
    });
    if (MsgIsError(resMsg)) {
      return this.logger.Error().Err(resMsg).Msg("Error in buildResSignedUrl").ResultError();
    }
    return Result.Ok(void 0);
  }
};
var WALGateway = class extends BaseGateway {
  // WAL will not pollute to the cloud
  wals = /* @__PURE__ */ new Map();
  constructor(sthis) {
    super(sthis, "Cloud-WALGateway");
  }
  getWalKeyFromUri(uri) {
    const rKey = uri.getParamsResult({
      key: 0,
      name: 0
    });
    if (rKey.isErr()) {
      return Result.Err(rKey.Err());
    }
    const { name: name2, key } = rKey.Ok();
    return Result.Ok(`${name2}:${key}`);
  }
  async get(ctx, uri) {
    const rKey = this.getWalKeyFromUri(uri);
    if (rKey.isErr()) {
      return Result.Err(rKey.Err());
    }
    const wal = this.wals.get(rKey.Ok());
    if (!wal) {
      return Result.Err(new NotFoundError("Not found"));
    }
    return Result.Ok(wal);
  }
  async put(ctx, uri, body) {
    const rKey = this.getWalKeyFromUri(uri);
    if (rKey.isErr()) {
      return Result.Err(rKey.Err());
    }
    this.wals.set(rKey.Ok(), body);
    return Result.Ok(void 0);
  }
  async delete(ctx, uri) {
    const rKey = this.getWalKeyFromUri(uri);
    if (rKey.isErr()) {
      return Result.Err(rKey.Err());
    }
    this.wals.delete(rKey.Ok());
    return Result.Ok(void 0);
  }
};
var storeTypedGateways = new KeyedResolvOnce();
function getStoreTypeGateway(sthis, uri) {
  const store = uri.getParam("store");
  switch (store) {
    case "file":
    case "car":
      return storeTypedGateways.get(store).once(() => new DataGateway(sthis));
    case "meta":
      return storeTypedGateways.get(store).once(() => new MetaGateway(sthis));
    case "wal":
      return storeTypedGateways.get(store).once(() => new WALGateway(sthis));
    default:
      throw ensureLogger(sthis, "getStoreTypeGateway").Error().Str("store", store).Msg("Invalid store type").ResultError();
  }
}
var subscriptions = /* @__PURE__ */ new Map();
var CloudGateway = class {
  logger;
  sthis;
  #connectionURIs = new KeyedResolvOnce();
  constructor(sthis) {
    this.sthis = sthis;
    this.logger = ensureLogger(sthis, "CloudGateway", {
      this: true
    });
  }
  async buildUrl(ctx, baseUrl, key) {
    return Result.Ok(baseUrl.build().setParam("key", key).URI());
  }
  async start(ctx, uri) {
    await this.sthis.start();
    const ret = uri.build().defParam("version", VERSION2);
    ret.defParam("protocol", "wss");
    const retURI = ret.URI();
    this.registerConnectionURI(retURI, () => ({
      connection: new ResolveOnce(),
      trackPuts: /* @__PURE__ */ new Set()
    }));
    return Result.Ok(retURI);
  }
  async get(ctx, uri) {
    const conn = await this.getCloudConnectionItem(ctx.loader.logger, uri);
    if (conn.conn.isErr()) {
      return Result.Err(conn.conn);
    }
    const ret = await getStoreTypeGateway(ctx.loader.sthis, uri).get({ ...ctx, conn }, uri);
    return ret;
  }
  async put(ctx, uri, body) {
    const conn = await this.getCloudConnectionItem(ctx.loader.logger, uri);
    if (conn.conn.isErr()) {
      return conn.conn;
    }
    const ret = await getStoreTypeGateway(ctx.loader.sthis, uri).put({ ...ctx, conn }, uri, body);
    if (ret.isOk()) {
      if (uri.getParam("testMode")) {
        conn.citem.trackPuts.add(uri.toString());
      }
    }
    return ret;
  }
  async delete(ctx, uri) {
    const conn = await this.getCloudConnectionItem(ctx.loader.logger, uri);
    if (conn.conn.isErr()) {
      return conn.conn;
    }
    conn.citem.trackPuts.delete(uri.toString());
    return getStoreTypeGateway(ctx.loader.sthis, uri).delete({ ...ctx, conn }, uri);
  }
  async close(ctx, uri) {
    const uriStr = uri.toString();
    for (const sub of Array.from(subscriptions.values())) {
      for (const s of sub) {
        if (s.uri.toString() === uriStr) {
          s.unsub();
        }
      }
    }
    const rConn = await this.getCloudConnectionItem(ctx.loader.logger, uri);
    if (rConn.conn.isErr()) {
      return this.logger.Error().Err(rConn).Msg("Error in getCloudConnection").ResultError();
    }
    const conn = rConn.conn.Ok();
    const rAuth = await authTypeFromUri(this.logger, uri);
    if (rAuth.isErr()) {
      this.logger.Error().Err(rAuth).Msg("Error in authTypeFromUri").ResultError();
    } else {
      await conn.close(buildReqClose(this.sthis, rAuth.Ok(), conn.conn));
    }
    this.#connectionURIs.unget(this.matchURI(uri)());
    return Result.Ok(void 0);
  }
  matchURI(uri) {
    let protocol = uri.getParam("protocol", "https");
    switch (protocol) {
      case "wss":
        protocol = "https";
        break;
      case "ws":
        protocol = "http";
        break;
      case "http":
        break;
      case "https":
      default:
        protocol = "https";
        break;
    }
    const matchURI = BuildURI.from(uri).cleanParams().protocol(protocol).URI().toString();
    return () => {
      return matchURI;
    };
  }
  registerConnectionURI(uri, itemFactory) {
    this.#connectionURIs.get(this.matchURI(uri)).once(itemFactory);
  }
  async getCloudConnectionItem(logger, uri) {
    const item = this.#connectionURIs.get(this.matchURI(uri));
    const bestMatch = item.value;
    if (!item.ready || !bestMatch) {
      return { conn: logger.Error().Url(uri).Msg("Connection not ready").ResultError(), citem: {} };
    }
    const rConn = await bestMatch.connection.once(async () => {
      const rParams = uri.getParamsResult({
        protocol: "https"
      });
      if (rParams.isErr()) {
        return this.logger.Error().Url(uri).Err(rParams).Msg("getCloudConnection:err").ResultError();
      }
      const params = rParams.Ok();
      const rAuth = await authTypeFromUri(this.logger, uri);
      if (rAuth.isErr()) {
        return Result.Err(rAuth);
      }
      const qOpen = buildReqOpen(this.sthis, rAuth.Ok(), {});
      const cUrl = uri.build().protocol(params.protocol).cleanParams().URI();
      return Msger.connect(this.sthis, cUrl, qOpen);
    });
    return { conn: rConn, citem: bestMatch };
  }
  async subscribe(ctx, uri, callback) {
    const metaGw = getStoreTypeGateway(ctx.loader.sthis, uri);
    return metaGw.subscribe(ctx, uri, callback);
  }
  async destroy(ctx, uri) {
    const item = await this.getCloudConnectionItem(ctx.loader.logger, uri);
    if (item.conn.isErr()) {
      return item.conn;
    }
    await Promise.all(Array.from(item.citem.trackPuts).map(async (k) => this.delete(ctx, URI.from(k))));
    return Result.Ok(void 0);
  }
  async getPlain() {
    return Result.Err(new Error("Not implemented"));
  }
};

// core/gateways/cloud/to-cloud.ts
init_esm();
init_runtime2();
init_decode_jwt();
init_base3();
function addTenantAndLedger(opts, uri) {
  const buri = BuildURI.from(uri);
  if (opts.tenant) {
    buri.setParam("tenant", opts.tenant);
  }
  if (opts.ledger) {
    buri.setParam("ledger", opts.ledger);
  }
  return buri.URI();
}
var SimpleTokenStrategy = class {
  tc;
  constructor(jwk) {
    let claims;
    try {
      const rawClaims = decodeJwt(jwk);
      const rParse = FPCloudClaimParseSchema.safeParse(rawClaims);
      if (rParse.success) {
        claims = rParse.data;
      } else {
        throw rParse.error;
      }
    } catch (e) {
      claims = {
        userId: "test",
        email: "test@test.de",
        created: /* @__PURE__ */ new Date(),
        tenants: [{ id: "test", role: "admin" }],
        ledgers: [{ id: "test", role: "admin", right: "write" }],
        selected: { tenant: "test", ledger: "test" }
      };
    }
    this.tc = {
      token: jwk,
      claims
    };
  }
  hash = Lazy(() => hashObjectSync(this.tc.token));
  stop() {
    return;
  }
  open() {
    return;
  }
  async tryToken() {
    return this.tc;
  }
  async waitForToken() {
    return this.tc;
  }
};
var defaultSimpleTokenStrategy = new SimpleTokenStrategy("");
function defaultOpts(opts) {
  const base2 = opts.urls?.base ?? "fpcloud://fireproof-v2-cloud-dev.jchris.workers.dev";
  const param2 = {
    car: addTenantAndLedger(opts, opts.urls?.car ?? base2),
    file: addTenantAndLedger(opts, opts.urls?.file ?? base2),
    meta: addTenantAndLedger(opts, opts.urls?.meta ?? base2)
  };
  const sthis = opts.sthis ?? ensureSuperThis();
  const defOpts = {
    name: ToCloudName,
    intervalSec: 1,
    tokenWaitTimeSec: 90,
    // 90 seconds
    refreshTokenPresetSec: 2 * 60,
    // 2 minutes
    ...opts,
    sthis,
    events: opts.events ?? {
      hash: () => "1",
      changed: async () => {
      }
    },
    context: opts.context ?? sthis.ctx,
    urls: param2,
    strategy: opts.strategy ?? defaultSimpleTokenStrategy
  };
  return defOpts;
}
function definedExp(exp) {
  if (typeof exp === "number") {
    return exp;
  }
  return (/* @__PURE__ */ new Date()).getTime() / 1e3;
}
var TokenObserver = class {
  opts;
  currentTokenAndClaim;
  constructor(opts) {
    this.opts = opts;
  }
  async start() {
    return;
  }
  async stop() {
    return;
  }
  async refreshToken(logger, ledger) {
    let token = await this.opts.strategy.tryToken(ledger.sthis, logger, this.opts);
    if (this.isExpired(token)) {
      logger.Debug().Msg("waiting for token");
      this.opts.strategy.open(ledger.sthis, logger, ledger.name, this.opts);
      token = await this.opts.strategy.waitForToken(ledger.sthis, logger, ledger.name, this.opts);
      if (!token) {
        throw new Error("Token not found");
      }
    }
    return token;
  }
  isExpired(token) {
    const now = ~~((/* @__PURE__ */ new Date()).getTime() / 1e3);
    return !token || definedExp(token.claims?.exp) - this.opts.refreshTokenPresetSec < now;
  }
  _token = new ResolveOnce();
  async getToken(logger, ledger) {
    let activeTokenAndClaim = this.currentTokenAndClaim;
    if (this.isExpired(activeTokenAndClaim)) {
      await this.opts.events?.changed(void 0);
      logger.Debug().Any({ claims: this.currentTokenAndClaim?.claims, exp: definedExp(this.currentTokenAndClaim?.claims?.exp) }).Msg("refresh token");
      activeTokenAndClaim = await this.refreshToken(logger, ledger);
    }
    if (activeTokenAndClaim && activeTokenAndClaim.token !== this.currentTokenAndClaim?.token) {
      this.currentTokenAndClaim = activeTokenAndClaim;
      await this.opts.events?.changed(activeTokenAndClaim);
    }
    if (this.currentTokenAndClaim) {
      return this.currentTokenAndClaim;
    }
    throw logger.Error().Msg("Token not found").AsError();
  }
  async reset() {
    this.currentTokenAndClaim = void 0;
    await this.opts.events?.changed(void 0);
    return;
  }
};
var ToCloud = class {
  opts;
  currentToken;
  constructor(opts) {
    this.opts = defaultOpts(opts);
  }
  get name() {
    return this.opts.name;
  }
  _tokenObserver;
  configHash(db) {
    const hash2 = hashObjectSync({
      dbRefId: db?.refId(),
      opts: hashForToCloudBase(this.opts)
    });
    return hash2;
  }
  // doRedirect(logger: Logger, name: string) {
  //   const url = BuildURI.from(this.opts.dashboardURI)
  //     .setParam("back_url", window.location.href)
  //     .setParam("local_ledger_name", name)
  //     .toString();
  //   logger.Debug().Url(url).Msg("gathering token");
  //   window.location.href = url;
  // }
  get token() {
    return this.currentToken;
  }
  async prepare(ledger) {
    if (!ledger) {
      throw new Error("Ledger is required");
    }
    const logger = ensureLogger(ledger.sthis, "ToCloud");
    this._tokenObserver = new TokenObserver(this.opts);
    await this._tokenObserver.start();
    const gatewayInterceptor = URIInterceptor.withMapper(async (uri) => {
      const token = await this._tokenObserver.getToken(logger, ledger);
      const buri = BuildURI.from(uri).setParam("authJWK", token.token);
      if (!token.claims) {
        throw new Error("No claims");
      }
      const selected = token.claims.selected ?? {};
      if (selected.tenant) {
        buri.setParam("tenant", selected.tenant);
      } else if (this.opts.tenant) {
        buri.setParam("tenant", this.opts.tenant);
      }
      if (selected.ledger) {
        buri.setParam("ledger", selected.ledger);
      } else if (this.opts.ledger) {
        buri.setParam("ledger", this.opts.ledger);
      }
      return buri.URI();
    });
    return {
      car: { url: this.opts.urls.car, gatewayInterceptor },
      file: { url: this.opts.urls.file, gatewayInterceptor },
      meta: { url: this.opts.urls.meta, gatewayInterceptor },
      teardown: () => {
        this._tokenObserver.stop();
      },
      ctx: this.opts.context
    };
  }
};
function hashForToCloudBase(opts) {
  const hashable = {
    opts: stripper(["context", "events", "strategy", "sthis"], opts),
    ...opts.urls ? { urls: hashableFPCloudRef(opts.urls) } : {},
    // ...(opts.context ? { context: opts.context.asObj() } : {}),
    ...opts.strategy ? { strategy: opts.strategy.hash() } : {},
    ...opts.events ? { events: opts.events.hash() } : {}
  };
  return hashObjectSync(hashable);
}
var toClouds = new KeyedResolvOnce();
var defaultAppContext = new AppContext();
function toCloud(iopts) {
  return toClouds.get(hashForToCloudBase(iopts)).once(() => {
    return new ToCloud({
      ...iopts,
      urls: iopts.urls ?? {},
      events: iopts.events ?? {
        hash: () => "1",
        changed: async () => {
        }
      },
      context: iopts.context ?? defaultAppContext,
      strategy: iopts.strategy
    });
  });
}

// core/blockstore/register-store-protocol.ts
var OneSerdeGatewayFactoryItem = class {
  once = new ResolveOnce();
  item;
  constructor(sgfi) {
    this.item = sgfi;
  }
  get protocol() {
    return this.item.protocol;
  }
  get isDefault() {
    return this.item.isDefault ?? false;
  }
  set isDefault(value) {
    this.item.isDefault = value;
  }
  defaultURI(sthis) {
    return this.item.defaultURI(sthis);
  }
  async serdegateway(sthis) {
    return this.once.once(() => this.item.serdegateway(sthis));
  }
};
var storeFactory = /* @__PURE__ */ new Map();
function getDefaultURI(sthis, protocol) {
  if (protocol) {
    if (!protocol.endsWith(":")) {
      protocol += ":";
    }
    const gfi = storeFactory.get(protocol);
    if (gfi) {
      return gfi.defaultURI(sthis);
    }
  }
  const found = Array.from(storeFactory.values()).find((item) => item.isDefault);
  if (!found) {
    throw sthis.logger.Error().Msg("no default found").AsError();
  }
  return found.defaultURI(sthis);
}
function registerStoreProtocol(item) {
  let protocol = item.protocol;
  if (!protocol.endsWith(":")) {
    protocol += ":";
  }
  if (!item.serdegateway && !item.gateway) {
    throw new Error(`registerStoreProtocol needs a gateway or serdegateway`);
  }
  let serdegateway;
  if (item.gateway) {
    serdegateway = async (sthis) => {
      const m = await item.gateway(sthis);
      return new DefSerdeGateway(m);
    };
  } else {
    serdegateway = item.serdegateway;
  }
  if (item.isDefault) {
    Array.from(storeFactory.values()).forEach((items) => {
      items.isDefault = false;
    });
  }
  storeFactory.set(
    protocol,
    new OneSerdeGatewayFactoryItem({
      ...item,
      serdegateway
    })
  );
  return () => {
    storeFactory.delete(protocol);
  };
}
function getGatewayFactoryItem(protocol) {
  return storeFactory.get(protocol);
}
function defaultURI(sthis) {
  const rt = runtimeFn();
  return BuildURI.from("file://").pathname(`${sthis.env.get("HOME")}/.fireproof/${FILESTORE_VERSION.replace(/-.*$/, "")}`).setParam(PARAM.VERSION, FILESTORE_VERSION).setParam(PARAM.URL_GEN, "default").setParam(PARAM.RUNTIME, rt.isNodeIsh ? "node" : rt.isDeno ? "deno" : "unknown").URI();
}
if (runtimeFn().isNodeIsh || runtimeFn().isDeno) {
  registerStoreProtocol({
    protocol: "file:",
    isDefault: true,
    defaultURI,
    gateway: async (sthis) => {
      return new FileGateway(sthis, await sysFileSystemFactory(defaultURI(sthis)));
    }
  });
}
if (runtimeFn().isBrowser) {
  registerStoreProtocol({
    protocol: "indexeddb:",
    isDefault: true,
    defaultURI: () => {
      return BuildURI.from("indexeddb://").pathname("fp").setParam(PARAM.VERSION, INDEXEDDB_VERSION).setParam(PARAM.RUNTIME, "browser").URI();
    },
    gateway: async () => {
      const { GatewayImpl } = await Promise.resolve().then(() => (init_indexeddb(), indexeddb_exports));
      return new GatewayImpl();
    }
  });
}
var memory = /* @__PURE__ */ new Map();
registerStoreProtocol({
  protocol: "memory:",
  isDefault: false,
  defaultURI: () => {
    return BuildURI.from("memory://").pathname("ram").URI();
  },
  gateway: async (sthis) => {
    return new MemoryGateway(sthis, memory);
  }
});
URI.protocolHasHostpart("fpcloud");
registerStoreProtocol({
  protocol: "fpcloud",
  defaultURI() {
    return URI.from("fpcloud://fireproof.cloud/");
  },
  serdegateway: async (sthis) => {
    return new CloudGateway(sthis);
  }
});

// core/blockstore/store-factory.ts
init_base3();
init_runtime2();
async function getInterceptableGateway(ctx, url2, opt) {
  const item = getGatewayFactoryItem(url2.protocol);
  if (item) {
    return Result.Ok(new InterceptorGateway(ctx.loader.sthis, await item.serdegateway(ctx.loader.sthis), opt.gatewayInterceptor));
  }
  return Result.Err(ctx.loader.sthis.logger.Warn().Url(url2).Msg("unsupported protocol").AsError());
}
async function carStoreFactory(ctx, uai) {
  const storeUrl = uai.url.build().setParam(PARAM.STORE, "car").URI();
  const rgateway = await getInterceptableGateway(ctx, storeUrl, uai);
  if (rgateway.isErr()) {
    throw ctx.loader.sthis.logger.Error().Result("err", rgateway).Url(uai.url).Msg("notfound").AsError();
  }
  const gateway = rgateway.Ok();
  const store = new CarStoreImpl(ctx.loader.sthis, uai.url, {
    gateway,
    loader: ctx.loader
  });
  return store;
}
async function fileStoreFactory(ctx, uai) {
  const storeUrl = uai.url.build().setParam(PARAM.STORE, "file").URI();
  const rgateway = await getInterceptableGateway(ctx, storeUrl, uai);
  if (rgateway.isErr()) {
    throw ctx.loader.sthis.logger.Error().Result("err", rgateway).Url(uai.url).Msg("notfound").AsError();
  }
  const gateway = rgateway.Ok();
  const store = new FileStoreImpl(ctx.loader.sthis, uai.url, {
    gateway,
    loader: ctx.loader
  });
  return store;
}
async function metaStoreFactory(ctx, uai) {
  const storeUrl = uai.url.build().setParam(PARAM.STORE, "meta").URI();
  const rgateway = await getInterceptableGateway(ctx, storeUrl, uai);
  if (rgateway.isErr()) {
    throw ctx.loader.sthis.logger.Error().Result("err", rgateway).Url(uai.url).Msg("notfound").AsError();
  }
  const gateway = rgateway.Ok();
  const store = new MetaStoreImpl(ctx.loader.sthis, uai.url, {
    gateway,
    loader: ctx.loader
  });
  return store;
}
async function WALStoreFactory(ctx, uai) {
  const storeUrl = uai.url.build().setParam(PARAM.STORE, "wal").URI();
  const rgateway = await getInterceptableGateway(ctx, storeUrl, uai);
  if (rgateway.isErr()) {
    throw ctx.loader.sthis.logger.Error().Result("err", rgateway).Url(uai.url).Msg("notfound").AsError();
  }
  const gateway = rgateway.Ok();
  const store = new WALStoreImpl(ctx.loader.sthis, uai.url, {
    gateway,
    loader: ctx.loader
  });
  return store;
}
async function ensureStart(store, damaw) {
  const ret = await store.start(damaw);
  if (ret.isErr()) {
    throw store.logger.Error().Result("start", ret).Msg("start failed").AsError();
  }
  return store;
}
function ensureStoreEnDeFile(ende) {
  ende = ende || {};
  return {
    encodeFile: ende.encodeFile || encodeFile,
    decodeFile: ende.decodeFile || decodeFile
  };
}
function toStoreRuntime(sthis, endeOpts = {}) {
  return {
    makeStores: async (sfi) => {
      const ctx = {
        loader: sfi.loader
      };
      const storeSet = {};
      storeSet.meta = await metaStoreFactory(ctx, sfi.byStore.meta);
      storeSet.car = await carStoreFactory(ctx, sfi.byStore.car);
      storeSet.file = await fileStoreFactory(ctx, sfi.byStore.file);
      if (sfi.byStore.wal) {
        storeSet.wal = await WALStoreFactory(ctx, sfi.byStore.wal);
      }
      await ensureStart(storeSet.meta, storeSet);
      await ensureStart(storeSet.car, storeSet);
      await ensureStart(storeSet.file, storeSet);
      if (storeSet.wal) {
        await ensureStart(storeSet.wal, storeSet);
      }
      return storeSet;
    },
    // makeMetaStore: async (sfi: StoreFactoryItem) => ensureStart(await metaStoreFactory(sfi)),
    // makeDataStore: async (sfi: StoreFactoryItem) => ensureStart(await dataStoreFactory(sfi)),
    // makeWALStore: async (sfi: StoreFactoryItem) => ensureStart(await WALStoreFactory(sfi)),
    ...ensureStoreEnDeFile(endeOpts)
  };
}

// core/base/indexer-helpers.ts
init_runtime2();
function refCompare2(aRef, bRef) {
  if (Number.isNaN(aRef)) return -1;
  if (Number.isNaN(bRef)) throw new Error("ref may not be Infinity or NaN");
  if (aRef === Infinity) return 1;
  return simpleCompare(aRef, bRef);
}
function compare4(a, b) {
  const [aKey, aRef] = a;
  const [bKey, bRef] = b;
  const comp = simpleCompare(aKey, bKey);
  if (comp !== 0) return comp;
  return refCompare2(aRef, bRef);
}
var byKeyOpts = { cache: nocache, chunker: bf(30), codec: src_exports, hasher: sha256, compare: compare4 };
var byIdOpts = { cache: nocache, chunker: bf(30), codec: src_exports, hasher: sha256, compare: simpleCompare };
function indexEntriesForChanges(changes, mapFn) {
  const indexEntries = [];
  changes.forEach(({ id: key, value, del: del2 }) => {
    if (del2 || !value) return;
    let mapCalled = false;
    const mapReturn = mapFn({ ...value, _id: key }, (k, v) => {
      mapCalled = true;
      if (typeof k === "undefined") return;
      indexEntries.push({
        key: [import_charwise.default.encode(k), key],
        value: v || null
      });
    });
    if (!mapCalled && typeof mapReturn !== "undefined") {
      indexEntries.push({
        key: [import_charwise.default.encode(mapReturn), key],
        value: null
      });
    }
  });
  return indexEntries;
}
function makeProllyGetBlock(blocks) {
  return async (address) => {
    const block = await blocks.get(address);
    if (!block) throw new Error(`Missing block ${address.toString()}`);
    const { cid, bytes } = block;
    return asyncBlockCreate({ cid, bytes, hasher: sha256, codec: src_exports });
  };
}
async function bulkIndex(logger, tblocks, inIndex, indexEntries, opts) {
  logger.Debug().Msg("enter bulkIndex");
  if (!indexEntries.length) return inIndex;
  if (!inIndex.root) {
    if (!inIndex.cid) {
      let returnRootBlock = void 0;
      let returnNode = void 0;
      for await (const node of await create4({
        get: makeProllyGetBlock(tblocks),
        list: indexEntries,
        ...opts
      })) {
        const block = await node.block;
        await tblocks.put(await anyBlock2FPBlock(block));
        returnRootBlock = block;
        returnNode = node;
      }
      if (!returnNode || !returnRootBlock) throw new Error("failed to create index");
      logger.Debug().Msg("exit !root bulkIndex");
      return { root: returnNode, cid: returnRootBlock.cid };
    } else {
      inIndex.root = await load2({ cid: inIndex.cid, get: makeProllyGetBlock(tblocks), ...opts });
    }
  }
  logger.Debug().Msg("pre bulk bulkIndex");
  const { root: root2, blocks: newBlocks } = await inIndex.root.bulk(indexEntries);
  if (root2) {
    logger.Debug().Msg("pre root put bulkIndex");
    for await (const block of newBlocks) {
      await tblocks.put(await anyBlock2FPBlock(block));
    }
    return { root: root2, cid: (await root2.block).cid };
  } else {
    logger.Debug().Msg("pre !root bulkIndex");
    return { root: void 0, cid: void 0 };
  }
}
async function loadIndex(tblocks, cid, opts) {
  return await load2({ cid, get: makeProllyGetBlock(tblocks), ...opts });
}
async function applyQuery(crdt, resp, query) {
  if (query.descending) {
    resp.result = resp.result.reverse();
  }
  if (query.limit) {
    resp.result = resp.result.slice(0, query.limit);
  }
  if (typeof query.includeDocs === "boolean" ? query.includeDocs : true) {
    resp.result = await Promise.all(
      resp.result.map(async (row) => {
        const val = await crdt.get(row.id);
        const doc = val ? { ...val.doc, _id: row.id } : void 0;
        return { ...row, doc };
      })
    );
  }
  const rows = resp.result.map(({ key, ...row }) => {
    const decodedKey = import_charwise.default.decode(key);
    const dynamicRow = row;
    if ("row" in dynamicRow && !("value" in dynamicRow)) {
      const normalizedRow = {};
      Object.keys(dynamicRow).forEach((k) => {
        if (k === "row") {
          normalizedRow.value = dynamicRow[k];
        } else {
          normalizedRow[k] = dynamicRow[k];
        }
      });
      return {
        key: decodedKey,
        ...normalizedRow
      };
    }
    return {
      key: decodedKey,
      ...row
    };
  });
  const typedRows = rows;
  const docs = typedRows.filter((r) => !!r.doc);
  return {
    rows: typedRows,
    docs
  };
}
function encodeRange(range) {
  return [import_charwise.default.encode(range[0]), import_charwise.default.encode(range[1])];
}
function encodeKey(key) {
  return import_charwise.default.encode(key);
}

// core/base/indexer.ts
init_runtime2();
function refLedger(u) {
  return !!u.ledger;
}
function index(refDb, name2, mapFn, meta3) {
  const crdt = refLedger(refDb) ? refDb.ledger.crdt : refDb.crdt;
  if (mapFn && meta3) throw refDb.logger.Error().Msg("cannot provide both mapFn and meta").AsError();
  if (mapFn && mapFn.constructor.name !== "Function") throw refDb.logger.Error().Msg("mapFn must be a function").AsError();
  if (crdt.indexers.has(name2)) {
    const idx = crdt.indexers.get(name2);
    idx.applyMapFn(name2, mapFn, meta3);
  } else {
    const idx = new Index(refDb.sthis, crdt, name2, mapFn, meta3);
    crdt.indexers.set(name2, idx);
  }
  return crdt.indexers.get(name2);
}
var Index = class {
  blockstore;
  crdt;
  name;
  mapFn;
  mapFnString = "";
  byKey = {};
  byId = {};
  indexHead;
  initError;
  ready() {
    return Promise.all([this.blockstore.ready(), this.crdt.ready()]).then(() => {
    });
  }
  // close(): Promise<void> {
  //   return Promise.all([this.blockstore.close(), this.crdt.close()]).then(() => {
  //     /* noop */
  //   });
  // }
  // destroy(): Promise<void> {
  //   return Promise.all([this.blockstore.destroy(), this.crdt.destroy()]).then(() => {
  //     /* noop */
  //   });
  // }
  logger;
  constructor(sthis, crdt, name2, mapFn, meta3) {
    this.logger = ensureLogger(sthis, "Index");
    if (!crdt.indexBlockstore) {
      throw sthis.logger.Error().Msg("indexBlockstore not set").AsError();
    }
    this.blockstore = crdt.indexBlockstore;
    this.crdt = crdt;
    this.applyMapFn(name2, mapFn, meta3);
    this.name = name2;
    if (!(this.mapFnString || this.initError)) throw this.logger.Error().Msg("missing mapFnString").AsError();
  }
  applyMapFn(name2, mapFn, meta3) {
    if (mapFn && meta3) throw this.logger.Error().Msg("cannot provide both mapFn and meta").AsError();
    if (this.name && this.name !== name2) throw this.logger.Error().Msg("cannot change name").AsError();
    try {
      let mapFnChanged = false;
      if (meta3) {
        if (this.indexHead && this.indexHead.map((c) => c.toString()).join() !== meta3.head.map((c) => c.toString()).join()) {
          throw this.logger.Error().Msg("cannot apply different head meta").AsError();
        }
        if (this.mapFnString) {
          if (this.mapFnString !== meta3.map) {
            this.mapFnString = meta3.map;
            mapFnChanged = true;
          }
          this.byId.cid = meta3.byId;
          this.byKey.cid = meta3.byKey;
          this.indexHead = meta3.head;
        } else {
          this.mapFnString = meta3.map;
          this.byId.cid = meta3.byId;
          this.byKey.cid = meta3.byKey;
          this.indexHead = meta3.head;
        }
      } else {
        if (this.mapFn) {
          if (mapFn) {
            if (this.mapFn.toString() !== mapFn.toString()) {
              this.mapFn = mapFn;
              this.mapFnString = mapFn.toString();
              mapFnChanged = true;
            }
          }
        } else {
          if (!mapFn) {
            mapFn = ((doc) => doc[name2] ?? void 0);
          }
          if (this.mapFnString) {
            if (this.mapFnString !== mapFn.toString()) {
              mapFnChanged = true;
            }
          } else {
            this.mapFnString = mapFn.toString();
          }
          this.mapFn = mapFn;
        }
      }
      if (mapFnChanged) {
        this._resetIndex();
      }
    } catch (e) {
      this.initError = e;
    }
  }
  async query(opts = {}) {
    await this.ready();
    await this._updateIndex();
    await this._hydrateIndex();
    if (!this.byKey.root) {
      return await applyQuery(this.crdt, { result: [] }, opts);
    }
    if (opts.range) {
      const eRange = encodeRange(opts.range);
      return await applyQuery(this.crdt, await throwFalsy(this.byKey.root).range(eRange[0], eRange[1]), opts);
    }
    if (typeof opts.key === "boolean" || opts.key) {
      const encodedKey = encodeKey(opts.key);
      return await applyQuery(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts);
    }
    if (Array.isArray(opts.keys)) {
      const optsWithoutLimit = { ...opts };
      delete optsWithoutLimit.limit;
      const results = await Promise.all(
        opts.keys.map(async (key) => {
          const encodedKey = encodeKey(key);
          return (await applyQuery(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), optsWithoutLimit)).rows;
        })
      );
      let flattenedRows = results.flat();
      if (opts) {
        flattenedRows = flattenedRows.slice(0, opts.limit);
      }
      const docInc = typeof opts.includeDocs === "boolean" ? opts.includeDocs : true;
      let docsObj = {};
      if (docInc) {
        docsObj = { docs: flattenedRows.map((r) => r.doc).filter((r) => !!r) };
      }
      return {
        rows: flattenedRows,
        ...docsObj
        // docs: flattenedRows.map((r) => r.doc).filter((r): r is DocWithId<T> => !!r),
      };
    }
    if (opts.prefix) {
      let prefix = [];
      if (!Array.isArray(opts.prefix)) prefix = [opts.prefix];
      else prefix = opts.prefix;
      const start = [...prefix, NaN];
      const end = [...prefix, Infinity];
      const encodedR = encodeRange([start, end]);
      return await applyQuery(this.crdt, await this.byKey.root.range(...encodedR), {
        ...opts,
        prefix
      });
    }
    const all = await this.byKey.root.getAllEntries();
    return await applyQuery(
      this.crdt,
      {
        // getAllEntries returns a different type than range
        result: all.result.map(({ key: [k, id], value }) => ({
          key: k,
          id,
          value
        }))
      },
      opts
    );
  }
  _resetIndex() {
    this.byId = {};
    this.byKey = {};
    this.indexHead = void 0;
  }
  async _hydrateIndex() {
    if (this.byId.root && this.byKey.root) return;
    if (!this.byId.cid || !this.byKey.cid) return;
    this.byId.root = await loadIndex(this.blockstore, this.byId.cid, byIdOpts);
    this.byKey.root = await loadIndex(this.blockstore, this.byKey.cid, byKeyOpts);
  }
  async _updateIndex() {
    await this.ready();
    this.logger.Debug().Msg("enter _updateIndex");
    if (this.initError) throw this.initError;
    if (!this.mapFn) throw this.logger.Error().Msg("No map function defined").AsError();
    let result, head;
    if (!this.indexHead || this.indexHead.length === 0) {
      ({ result, head } = await this.crdt.allDocs());
      this.logger.Debug().Msg("enter crdt.allDocs");
    } else {
      ({ result, head } = await this.crdt.changes(this.indexHead));
      this.logger.Debug().Msg("enter crdt.changes");
    }
    if (result.length === 0) {
      this.indexHead = head;
    }
    let staleKeyIndexEntries = [];
    let removeIdIndexEntries = [];
    if (this.byId.root) {
      const removeIds = result.map(({ id: key }) => key);
      const { result: oldChangeEntries } = await this.byId.root.getMany(removeIds);
      staleKeyIndexEntries = oldChangeEntries.map((key) => ({ key, del: true }));
      removeIdIndexEntries = oldChangeEntries.map((key) => ({ key: key[1], del: true }));
    }
    const indexEntries = indexEntriesForChanges(result, this.mapFn);
    const byIdIndexEntries = indexEntries.map(({ key }) => ({
      key: key[1],
      value: key
    }));
    const indexerMeta = { indexes: /* @__PURE__ */ new Map() };
    for (const [name2, indexer] of this.crdt.indexers) {
      if (indexer.indexHead) {
        indexerMeta.indexes?.set(name2, {
          byId: indexer.byId.cid,
          byKey: indexer.byKey.cid,
          head: indexer.indexHead,
          map: indexer.mapFnString,
          name: indexer.name
        });
      }
    }
    if (result.length === 0) {
      return indexerMeta;
    }
    this.logger.Debug().Msg("pre this.blockstore.transaction");
    const { meta: meta3 } = await this.blockstore.transaction(async (tblocks) => {
      this.byId = await bulkIndex(
        this.logger,
        tblocks,
        this.byId,
        removeIdIndexEntries.concat(byIdIndexEntries),
        byIdOpts
      );
      this.byKey = await bulkIndex(
        this.logger,
        tblocks,
        this.byKey,
        staleKeyIndexEntries.concat(indexEntries),
        byKeyOpts
      );
      this.indexHead = head;
      if (this.byId.cid && this.byKey.cid) {
        const idxMeta = {
          byId: this.byId.cid,
          byKey: this.byKey.cid,
          head,
          map: this.mapFnString,
          name: this.name
        };
        indexerMeta.indexes?.set(this.name, idxMeta);
      }
      this.logger.Debug().Any("indexerMeta", new Array(indexerMeta.indexes?.entries())).Msg("exit this.blockstore.transaction fn");
      return indexerMeta;
    });
    this.logger.Debug().Msg("post this.blockstore.transaction");
    return meta3;
  }
};

// core/base/database.ts
init_base2();
init_runtime2();
var DatabaseImpl = class {
  onClosed(fn) {
    this.ledger.onClosed(fn);
  }
  close() {
    return this.ledger.close();
  }
  destroy() {
    return this.ledger.destroy();
  }
  ready() {
    return this.ledger.ready();
  }
  ledger;
  logger;
  sthis;
  // readonly id: string;
  constructor(ledger) {
    this.sthis = ledger.sthis;
    this.ledger = ledger;
    this.logger = ensureLogger(this.sthis, "Database");
  }
  attach(a) {
    return this.ledger.attach(a);
  }
  get name() {
    return this.ledger.name;
  }
  async get(id) {
    if (!id) throw this.logger.Error().Str("db", this.name).Msg(`Doc id is required`).AsError();
    await this.ready();
    this.logger.Debug().Str("id", id).Msg("get");
    try {
      const got = await this.ledger.crdt.get(id);
      if (!got) throw new NotFoundError(`Not found: ${id}`);
      const { doc } = got;
      return { ...doc, _id: id };
    } catch (e) {
      throw new NotFoundError(`Not found: ${id} - ${e instanceof Error ? e.message : String(e)}`);
    }
  }
  async put(doc) {
    await this.ready();
    this.logger.Debug().Str("id", doc._id).Msg("put");
    const { _id, ...value } = doc;
    const docId = _id || this.sthis.timeOrderedNextId().str;
    const result = await this.ledger.writeQueue.push({
      id: docId,
      value: {
        ...value,
        _id: docId
      }
    });
    return { id: docId, clock: result?.head, name: this.name };
  }
  async bulk(docs) {
    await this.ready();
    const updates = docs.map((doc) => {
      const id = doc._id || this.sthis.timeOrderedNextId().str;
      return {
        id,
        value: {
          ...doc,
          _id: id
        }
      };
    });
    const result = await this.ledger.writeQueue.bulk(updates);
    return { ids: updates.map((u) => u.id), clock: result.head, name: this.name };
  }
  async del(id) {
    await this.ready();
    this.logger.Debug().Str("id", id).Msg("del");
    const result = await this.ledger.writeQueue.push({ id, del: true });
    return { id, clock: result?.head, name: this.name };
  }
  async remove(id) {
    return this.del(id);
  }
  async changes(since = [], opts = {}) {
    await this.ready();
    this.logger.Debug().Any("since", since).Any("opts", opts).Msg("changes");
    const { result, head } = await this.ledger.crdt.changes(since, opts);
    const rows = result.map(({ id: key, value, del: del2, clock }) => ({
      key,
      value: del2 ? { _id: key, _deleted: true } : { _id: key, ...value },
      clock
    }));
    return { rows, clock: head, name: this.name };
  }
  async allDocs(opts = {}) {
    await this.ready();
    this.logger.Debug().Msg("allDocs");
    const { result, head } = await this.ledger.crdt.allDocs();
    let rows = result.map(({ id: key, value, del: del2 }) => ({
      key,
      value: del2 ? { _id: key, _deleted: true } : { _id: key, ...value }
    }));
    if (!opts.includeDeleted) {
      rows = rows.filter((row) => !row.value._deleted);
    }
    if (typeof opts.limit === "number" && opts.limit >= 0) {
      rows = rows.slice(0, opts.limit);
    }
    return { rows, clock: head, name: this.name };
  }
  async allDocuments() {
    return this.allDocs();
  }
  subscribe(listener, updates) {
    return this.ledger.subscribe(listener, updates);
  }
  // todo if we add this onto dbs in fireproof.ts then we can make index.ts a separate package
  async query(field, iopts) {
    let opts;
    if (!iopts) {
      opts = {};
    } else {
      opts = iopts;
    }
    await this.ready();
    this.logger.Debug().Any("field", field).Any("opts", opts).Msg("query");
    const idx = typeof field === "string" ? index(this, field) : index(this, makeName(field.toString()), field);
    const result = await idx.query(opts);
    const docInc = typeof opts.includeDocs === "boolean" ? opts.includeDocs : true;
    if (docInc) {
      return {
        rows: result.rows,
        docs: result.rows.map((r) => r.doc).filter((r) => !!r)
      };
    }
    return {
      rows: result.rows
    };
  }
  async compact() {
    await this.ready();
    await this.ledger.crdt.compact();
  }
};

// core/base/crdt.ts
init_esm();

// core/base/crdt-helpers.ts
init_runtime2();
init_link();
init_block();
init_sha2_browser();
init_src2();

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/crdt/index.js
init_clock();
init_clock();

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/shard.js
init_link();
init_block();
init_sha2_browser();
init_src2();
var KeyCharsASCII = "ascii";
var MaxKeySize = 4096;
var ShardBlock = class extends Block {
  /**
   * @param {object} config
   * @param {API.ShardLink} config.cid
   * @param {API.Shard} config.value
   * @param {Uint8Array} config.bytes
   */
  constructor({ cid, value, bytes }) {
    super({ cid, value, bytes });
  }
  /** @param {API.ShardOptions} [options] */
  static create(options) {
    return encodeBlock(create5(options));
  }
};
var create5 = (options) => ({ entries: [], ...configure(options) });
var configure = (options) => ({
  version: 1,
  keyChars: options?.keyChars ?? KeyCharsASCII,
  maxKeySize: options?.maxKeySize ?? MaxKeySize,
  prefix: options?.prefix ?? ""
});
var withEntries = (entries4, options) => ({ ...create5(options), entries: entries4 });
var decodeCache = /* @__PURE__ */ new WeakMap();
var encodeBlock = async (value) => {
  const { cid, bytes } = await encode8({ value, codec: src_exports, hasher: sha256 });
  const block = new ShardBlock({ cid, value, bytes });
  decodeCache.set(block.bytes, block);
  return block;
};
var decodeBlock = async (bytes) => {
  const block = decodeCache.get(bytes);
  if (block)
    return block;
  const { cid, value } = await decode9({ bytes, codec: src_exports, hasher: sha256 });
  if (!isShard(value))
    throw new Error(`invalid shard: ${cid}`);
  return new ShardBlock({ cid, value, bytes });
};
var isShard = (value) => value != null && typeof value === "object" && Array.isArray(value.entries) && value.version === 1 && typeof value.maxKeySize === "number" && typeof value.keyChars === "string" && typeof value.prefix === "string";
var isShardLink = (value) => isLink(value) && value.code === code3;
var ShardFetcher = class {
  /** @param {API.BlockFetcher} blocks */
  constructor(blocks) {
    this._blocks = blocks;
  }
  /**
   * @param {API.ShardLink} link
   * @returns {Promise<API.ShardBlockView>}
   */
  async get(link) {
    const block = await this._blocks.get(link);
    if (!block)
      throw new Error(`missing block: ${link}`);
    return decodeBlock(block.bytes);
  }
};
var putEntry = (target, newEntry) => {
  const entries4 = [];
  for (const [i, entry] of target.entries()) {
    const [k, v] = entry;
    if (newEntry[0] === k) {
      if (Array.isArray(newEntry[1])) {
        if (Array.isArray(v) && v[1] != null && newEntry[1][1] == null) {
          entries4.push([k, [newEntry[1][0], v[1]]]);
        } else {
          entries4.push(newEntry);
        }
      } else {
        if (Array.isArray(v)) {
          entries4.push([k, [v[0], newEntry[1]]]);
        } else {
          entries4.push(newEntry);
        }
      }
      for (let j = i + 1; j < target.length; j++) {
        entries4.push(target[j]);
      }
      return entries4;
    }
    if (i === 0 && newEntry[0] < k) {
      entries4.push(newEntry);
      for (let j = i; j < target.length; j++) {
        entries4.push(target[j]);
      }
      return entries4;
    }
    if (i > 0 && newEntry[0] > target[i - 1][0] && newEntry[0] < k) {
      entries4.push(newEntry);
      for (let j = i; j < target.length; j++) {
        entries4.push(target[j]);
      }
      return entries4;
    }
    entries4.push(entry);
  }
  entries4.push(newEntry);
  return entries4;
};
var isPrintableASCII = (s) => /^[\x20-\x7E]*$/.test(s);

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/index.js
var put = async (blocks, root2, key, value) => {
  const shards = new ShardFetcher(blocks);
  const rshard = await shards.get(root2);
  if (rshard.value.keyChars !== KeyCharsASCII) {
    throw new Error(`unsupported key character set: ${rshard.value.keyChars}`);
  }
  if (!isPrintableASCII(key)) {
    throw new Error("key contains non-ASCII characters");
  }
  if (new TextEncoder().encode(key).length > rshard.value.maxKeySize) {
    throw new Error(`UTF-8 encoded key exceeds max size of ${rshard.value.maxKeySize} bytes`);
  }
  const path = await traverse(shards, rshard, key);
  const target = path[path.length - 1];
  const skey = key.slice(target.value.prefix.length);
  let entry = [skey, value];
  const targetEntries = [...target.value.entries];
  const additions = [];
  for (const [i, e] of targetEntries.entries()) {
    const [k, v] = e;
    if (k === skey)
      break;
    const shortest = k.length < skey.length ? k : skey;
    const other = shortest === k ? skey : k;
    let common = "";
    for (const char of shortest) {
      const next = common + char;
      if (!other.startsWith(next))
        break;
      common = next;
    }
    if (common.length) {
      let entries4 = [];
      if (common !== skey) {
        entries4 = putEntry(entries4, [skey.slice(common.length), value]);
      }
      if (common !== k) {
        entries4 = putEntry(entries4, [k.slice(common.length), v]);
      }
      let child2 = await encodeBlock(withEntries(entries4, { ...target.value, prefix: target.value.prefix + common }));
      additions.push(child2);
      const commonChars = [...common];
      for (let i2 = commonChars.length - 1; i2 > 0; i2--) {
        const parentConfig = { ...target.value, prefix: target.value.prefix + commonChars.slice(0, i2).join("") };
        let parentValue;
        if (i2 === commonChars.length - 1 && common === k) {
          if (Array.isArray(v))
            throw new Error("found a shard link when expecting a value");
          parentValue = [child2.cid, v];
        } else if (i2 === commonChars.length - 1 && common === skey) {
          parentValue = [child2.cid, value];
        } else {
          parentValue = [child2.cid];
        }
        const parent = await encodeBlock(withEntries([[commonChars[i2], parentValue]], parentConfig));
        additions.push(parent);
        child2 = parent;
      }
      targetEntries.splice(i, 1);
      if (commonChars.length === 1 && common === k) {
        if (Array.isArray(v))
          throw new Error("found a shard link when expecting a value");
        entry = [commonChars[0], [child2.cid, v]];
      } else if (commonChars.length === 1 && common === skey) {
        entry = [commonChars[0], [child2.cid, value]];
      } else {
        entry = [commonChars[0], [child2.cid]];
      }
      break;
    }
  }
  const shard = withEntries(putEntry(targetEntries, entry), target.value);
  let child = await encodeBlock(shard);
  if (child.cid.toString() === target.cid.toString()) {
    return { root: root2, additions: [], removals: [] };
  }
  additions.push(child);
  for (let i = path.length - 2; i >= 0; i--) {
    const parent = path[i];
    const key2 = child.value.prefix.slice(parent.value.prefix.length);
    const value2 = withEntries(parent.value.entries.map((entry2) => {
      const [k, v] = entry2;
      if (k !== key2)
        return entry2;
      if (!Array.isArray(v))
        throw new Error(`"${key2}" is not a shard link in: ${parent.cid}`);
      return (
        /** @type {API.ShardEntry} */
        v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]]
      );
    }), parent.value);
    child = await encodeBlock(value2);
    additions.push(child);
  }
  return { root: additions[additions.length - 1].cid, additions, removals: path };
};
var get2 = async (blocks, root2, key) => {
  const shards = new ShardFetcher(blocks);
  const rshard = await shards.get(root2);
  const path = await traverse(shards, rshard, key);
  const target = path[path.length - 1];
  const skey = key.slice(target.value.prefix.length);
  const entry = target.value.entries.find(([k]) => k === skey);
  if (!entry)
    return;
  return Array.isArray(entry[1]) ? entry[1][1] : entry[1];
};
var del = async (blocks, root2, key) => {
  const shards = new ShardFetcher(blocks);
  const rshard = await shards.get(root2);
  const path = await traverse(shards, rshard, key);
  const target = path[path.length - 1];
  const skey = key.slice(target.value.prefix.length);
  const entryidx = target.value.entries.findIndex(([k]) => k === skey);
  if (entryidx === -1)
    return { root: root2, additions: [], removals: [] };
  const entry = target.value.entries[entryidx];
  if (Array.isArray(entry[1]) && entry[1][1] == null) {
    return { root: root2, additions: [], removals: [] };
  }
  const additions = [];
  const removals = [...path];
  let shard = withEntries([...target.value.entries], target.value);
  if (Array.isArray(entry[1])) {
    shard.entries[entryidx] = [entry[0], [entry[1][0]]];
  } else {
    shard.entries.splice(entryidx, 1);
    while (!shard.entries.length) {
      const child2 = path[path.length - 1];
      const parent = path[path.length - 2];
      if (!parent)
        break;
      path.pop();
      shard = withEntries(parent.value.entries.filter((e) => {
        if (!Array.isArray(e[1]))
          return true;
        return e[1][0].toString() !== child2.cid.toString();
      }), parent.value);
    }
  }
  let child = await encodeBlock(shard);
  additions.push(child);
  for (let i = path.length - 2; i >= 0; i--) {
    const parent = path[i];
    const key2 = child.value.prefix.slice(parent.value.prefix.length);
    const value = withEntries(parent.value.entries.map((entry2) => {
      const [k, v] = entry2;
      if (k !== key2)
        return entry2;
      if (!Array.isArray(v))
        throw new Error(`"${key2}" is not a shard link in: ${parent.cid}`);
      return (
        /** @type {API.ShardEntry} */
        v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]]
      );
    }), parent.value);
    child = await encodeBlock(value);
    additions.push(child);
  }
  return { root: additions[additions.length - 1].cid, additions, removals };
};
var isKeyPrefixOption = (options) => {
  const opts = options ?? {};
  return "prefix" in opts && Boolean(opts.prefix);
};
var isKeyRangeOption = (options) => {
  const opts = options ?? {};
  return "gt" in opts && Boolean(opts.gt) || "gte" in opts && Boolean(opts.gte) || "lt" in opts && Boolean(opts.lt) || "lte" in opts && Boolean(opts.lte);
};
var isKeyLowerBoundRangeOption = (options) => "gt" in options && Boolean(options.gt) || "gte" in options && Boolean(options.gte);
var isKeyLowerBoundRangeInclusiveOption = (options) => "gte" in options && Boolean(options.gte);
var isKeyLowerBoundRangeExclusiveOption = (options) => "gt" in options && Boolean(options.gt);
var isKeyUpperBoundRangeOption = (options) => "lt" in options && Boolean(options.lt) || "lte" in options && Boolean(options.lte);
var isKeyUpperBoundRangeInclusiveOption = (options) => "lte" in options && Boolean(options.lte);
var isKeyUpperBoundRangeExclusiveOption = (options) => "lt" in options && Boolean(options.lt);
var entries = async function* (blocks, root2, options) {
  const hasKeyPrefix = isKeyPrefixOption(options);
  const hasKeyRange = isKeyRangeOption(options);
  const hasKeyLowerBoundRange = hasKeyRange && isKeyLowerBoundRangeOption(options);
  const hasKeyLowerBoundRangeInclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeInclusiveOption(options);
  const hasKeyLowerBoundRangeExclusive = hasKeyLowerBoundRange && isKeyLowerBoundRangeExclusiveOption(options);
  const hasKeyUpperBoundRange = hasKeyRange && isKeyUpperBoundRangeOption(options);
  const hasKeyUpperBoundRangeInclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeInclusiveOption(options);
  const hasKeyUpperBoundRangeExclusive = hasKeyUpperBoundRange && isKeyUpperBoundRangeExclusiveOption(options);
  const hasKeyUpperAndLowerBoundRange = hasKeyLowerBoundRange && hasKeyUpperBoundRange;
  const shards = new ShardFetcher(blocks);
  const rshard = await shards.get(root2);
  yield* (
    /** @returns {AsyncIterableIterator<API.ShardValueEntry>} */
    (async function* ents(shard) {
      for (const entry of shard.value.entries) {
        const key = shard.value.prefix + entry[0];
        if (Array.isArray(entry[1])) {
          if (entry[1][1]) {
            if (hasKeyPrefix && key.startsWith(options.prefix) || hasKeyUpperAndLowerBoundRange && ((hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte) && (hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte)) || hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte || hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte || !hasKeyPrefix && !hasKeyRange) {
              yield [key, entry[1][1]];
            }
          }
          if (hasKeyPrefix) {
            if (options.prefix.length <= key.length && !key.startsWith(options.prefix)) {
              continue;
            }
            if (options.prefix.length > key.length && !options.prefix.startsWith(key)) {
              continue;
            }
          } else if (hasKeyLowerBoundRangeExclusive && trunc(key, Math.min(key.length, options.gt.length)) < trunc(options.gt, Math.min(key.length, options.gt.length)) || hasKeyLowerBoundRangeInclusive && trunc(key, Math.min(key.length, options.gte.length)) < trunc(options.gte, Math.min(key.length, options.gte.length)) || hasKeyUpperBoundRangeExclusive && trunc(key, Math.min(key.length, options.lt.length)) > trunc(options.lt, Math.min(key.length, options.lt.length)) || hasKeyUpperBoundRangeInclusive && trunc(key, Math.min(key.length, options.lte.length)) > trunc(options.lte, Math.min(key.length, options.lte.length))) {
            continue;
          }
          yield* ents(await shards.get(entry[1][0]));
        } else {
          if (hasKeyPrefix && key.startsWith(options.prefix) || hasKeyRange && hasKeyUpperAndLowerBoundRange && ((hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte) && (hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte)) || hasKeyRange && !hasKeyUpperAndLowerBoundRange && (hasKeyLowerBoundRangeExclusive && key > options.gt || hasKeyLowerBoundRangeInclusive && key >= options.gte || hasKeyUpperBoundRangeExclusive && key < options.lt || hasKeyUpperBoundRangeInclusive && key <= options.lte) || !hasKeyPrefix && !hasKeyRange) {
            yield [key, entry[1]];
          }
        }
      }
    })(rshard)
  );
};
var trunc = (str, len) => str.length <= len ? str : str.slice(0, len);
var traverse = async (shards, shard, key) => {
  for (const [k, v] of shard.value.entries) {
    if (key === k)
      return [shard];
    if (key.startsWith(k) && Array.isArray(v)) {
      const path = await traverse(shards, await shards.get(v[0]), key.slice(k.length));
      return [shard, ...path];
    }
  }
  return [shard];
};

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/block.js
init_link();
var MemoryBlockstore = class {
  /** @type {Map<string, Uint8Array>} */
  #blocks = /* @__PURE__ */ new Map();
  /**
   * @param {Array<import('multiformats').Block>} [blocks]
   */
  constructor(blocks) {
    if (blocks) {
      this.#blocks = new Map(blocks.map((b) => [b.cid.toString(), b.bytes]));
    }
  }
  /** @type {API.BlockFetcher['get']} */
  async get(cid) {
    const bytes = this.#blocks.get(cid.toString());
    if (!bytes)
      return;
    return { cid, bytes };
  }
  /**
   * @param {API.UnknownLink} cid
   * @param {Uint8Array} bytes
   */
  async put(cid, bytes) {
    this.#blocks.set(cid.toString(), bytes);
  }
  /**
   * @param {API.UnknownLink} cid
   * @param {Uint8Array} bytes
   */
  putSync(cid, bytes) {
    this.#blocks.set(cid.toString(), bytes);
  }
  /** @param {API.UnknownLink} cid */
  async delete(cid) {
    this.#blocks.delete(cid.toString());
  }
  /** @param {API.UnknownLink} cid */
  deleteSync(cid) {
    this.#blocks.delete(cid.toString());
  }
  *entries() {
    for (const [str, bytes] of this.#blocks) {
      yield { cid: parse4(str), bytes };
    }
  }
};
var MultiBlockFetcher = class {
  /** @type {API.BlockFetcher[]} */
  #fetchers;
  /** @param {API.BlockFetcher[]} fetchers */
  constructor(...fetchers) {
    this.#fetchers = fetchers;
  }
  /** @type {API.BlockFetcher['get']} */
  async get(link) {
    for (const f of this.#fetchers) {
      const v = await f.get(link);
      if (v)
        return v;
    }
  }
};

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/batch/shard.js
var create6 = (init) => ({
  base: init?.base,
  entries: [...init?.entries ?? []],
  ...configure(init)
});

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/batch/index.js
var Batcher = class _Batcher {
  #committed = false;
  /**
   * @param {object} init
   * @param {API.BlockFetcher} init.blocks Block storage.
   * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.
   * @param {string} init.prefix Key prefix.
   * @param {number} init.version Shard compatibility version.
   * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.
   * @param {number} init.maxKeySize Max key size in bytes.
   * @param {API.ShardBlockView} init.base Original shard this batcher is based on.
   */
  constructor({ blocks, entries: entries4, prefix, version: version2, keyChars, maxKeySize, base: base2 }) {
    this.blocks = blocks;
    this.prefix = prefix;
    this.entries = [...entries4];
    this.base = base2;
    this.version = version2;
    this.keyChars = keyChars;
    this.maxKeySize = maxKeySize;
  }
  /**
   * @param {string} key The key of the value to put.
   * @param {API.UnknownLink} value The value to put.
   * @returns {Promise<void>}
   */
  async put(key, value) {
    if (this.#committed)
      throw new BatchCommittedError();
    return put2(this.blocks, this, key, value);
  }
  async commit() {
    if (this.#committed)
      throw new BatchCommittedError();
    this.#committed = true;
    return commit2(this);
  }
  /**
   * @param {object} init
   * @param {API.BlockFetcher} init.blocks Block storage.
   * @param {API.ShardLink} init.link CID of the shard block.
   */
  static async create({ blocks, link }) {
    const shards = new ShardFetcher(blocks);
    const base2 = await shards.get(link);
    return new _Batcher({ blocks, base: base2, ...base2.value });
  }
};
var put2 = async (blocks, shard, key, value) => {
  if (shard.keyChars !== KeyCharsASCII) {
    throw new Error(`unsupported key character set: ${shard.keyChars}`);
  }
  if (!isPrintableASCII(key)) {
    throw new Error("key contains non-ASCII characters");
  }
  if (new TextEncoder().encode(key).length > shard.maxKeySize) {
    throw new Error(`UTF-8 encoded key exceeds max size of ${shard.maxKeySize} bytes`);
  }
  const shards = new ShardFetcher(blocks);
  const dest = await traverse2(shards, shard, key);
  if (dest.shard !== shard) {
    shard = dest.shard;
    key = dest.key;
  }
  let entry = [dest.key, value];
  const targetEntries = [...dest.shard.entries];
  for (const [i, e] of targetEntries.entries()) {
    const [k, v] = e;
    if (k === dest.key)
      break;
    const shortest = k.length < dest.key.length ? k : dest.key;
    const other = shortest === k ? dest.key : k;
    let common = "";
    for (const char of shortest) {
      const next = common + char;
      if (!other.startsWith(next))
        break;
      common = next;
    }
    if (common.length) {
      let entries4 = [];
      if (common !== dest.key) {
        entries4 = putEntry(entries4, [dest.key.slice(common.length), value]);
      }
      if (common !== k) {
        entries4 = putEntry(entries4, asShardEntry([k.slice(common.length), v]));
      }
      let child = create6({
        ...configure(dest.shard),
        prefix: dest.shard.prefix + common,
        entries: entries4
      });
      const commonChars = [...common];
      for (let i2 = commonChars.length - 1; i2 > 0; i2--) {
        let parentValue;
        if (i2 === commonChars.length - 1 && common === k) {
          if (Array.isArray(v))
            throw new Error("found a shard link when expecting a value");
          parentValue = [child, v];
        } else if (i2 === commonChars.length - 1 && common === dest.key) {
          parentValue = [child, value];
        } else {
          parentValue = [child];
        }
        const parent = create6({
          ...configure(dest.shard),
          prefix: dest.shard.prefix + commonChars.slice(0, i2).join(""),
          entries: [[commonChars[i2], parentValue]]
        });
        child = parent;
      }
      targetEntries.splice(i, 1);
      if (commonChars.length === 1 && common === k) {
        if (Array.isArray(v))
          throw new Error("found a shard link when expecting a value");
        entry = [commonChars[0], [child, v]];
      } else if (commonChars.length === 1 && common === dest.key) {
        entry = [commonChars[0], [child, value]];
      } else {
        entry = [commonChars[0], [child]];
      }
      break;
    }
  }
  shard.entries = putEntry(asShardEntries(targetEntries), asShardEntry(entry));
};
var traverse2 = async (shards, shard, key) => {
  for (let i = 0; i < shard.entries.length; i++) {
    const [k, v] = shard.entries[i];
    if (key <= k)
      break;
    if (key.startsWith(k) && Array.isArray(v)) {
      if (isShardLink(v[0])) {
        const blk = await shards.get(v[0]);
        const batcher = create6({ base: blk, ...blk.value });
        shard.entries[i] = [k, v[1] == null ? [batcher] : [batcher, v[1]]];
        return traverse2(shards, batcher, key.slice(k.length));
      }
      return traverse2(shards, v[0], key.slice(k.length));
    }
  }
  return { shard, key };
};
var commit2 = async (shard) => {
  const additions = [];
  const removals = [];
  const entries4 = [];
  for (const entry of shard.entries) {
    if (Array.isArray(entry[1]) && !isShardLink(entry[1][0])) {
      const result = await commit2(entry[1][0]);
      entries4.push([
        entry[0],
        entry[1][1] == null ? [result.root] : [result.root, entry[1][1]]
      ]);
      additions.push(...result.additions);
      removals.push(...result.removals);
    } else {
      entries4.push(asShardEntry(entry));
    }
  }
  const block = await encodeBlock(withEntries(entries4, shard));
  additions.push(block);
  if (shard.base && shard.base.cid.toString() === block.cid.toString()) {
    return { root: block.cid, additions: [], removals: [] };
  }
  if (shard.base)
    removals.push(shard.base);
  return { root: block.cid, additions, removals };
};
var asShardEntries = (entries4) => (
  /** @type {API.ShardEntry[]} */
  entries4
);
var asShardEntry = (entry) => (
  /** @type {API.ShardEntry} */
  entry
);
var create7 = (blocks, root2) => Batcher.create({ blocks, link: root2 });
var BatchCommittedError = class _BatchCommittedError extends Error {
  /**
   * @param {string} [message]
   * @param {ErrorOptions} [options]
   */
  constructor(message2, options) {
    super(message2 ?? "batch already committed", options);
    this.code = _BatchCommittedError.code;
  }
  static code = "ERR_BATCH_COMMITTED";
};

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/crdt/index.js
var put3 = async (blocks, head, key, value) => {
  const mblocks = new MemoryBlockstore();
  blocks = new MultiBlockFetcher(mblocks, blocks);
  if (!head.length) {
    const shard = await ShardBlock.create();
    mblocks.putSync(shard.cid, shard.bytes);
    const result2 = await put(blocks, shard.cid, key, value);
    const data2 = { type: "put", root: result2.root, key, value };
    const event2 = await EventBlock.create(data2, head);
    head = await advance(blocks, head, event2.cid);
    return {
      root: result2.root,
      additions: [shard, ...result2.additions],
      removals: result2.removals,
      head,
      event: event2
    };
  }
  const events = new EventFetcher(blocks);
  const ancestor = await findCommonAncestor(events, head);
  if (!ancestor)
    throw new Error("failed to find common ancestor event");
  const aevent = await events.get(ancestor);
  let { root: root2 } = aevent.value.data;
  const sorted = await findSortedEvents(events, head, ancestor);
  const additions = /* @__PURE__ */ new Map();
  const removals = /* @__PURE__ */ new Map();
  for (const { value: event2 } of sorted) {
    let result2;
    if (event2.data.type === "put") {
      result2 = await put(blocks, root2, event2.data.key, event2.data.value);
    } else if (event2.data.type === "del") {
      result2 = await del(blocks, root2, event2.data.key);
    } else if (event2.data.type === "batch") {
      const batch = await create7(blocks, root2);
      for (const op of event2.data.ops) {
        if (op.type !== "put")
          throw new Error(`unsupported batch operation: ${op.type}`);
        await batch.put(op.key, op.value);
      }
      result2 = await batch.commit();
    } else {
      throw new Error(`unknown operation: ${event2.data.type}`);
    }
    root2 = result2.root;
    for (const a of result2.additions) {
      mblocks.putSync(a.cid, a.bytes);
      additions.set(a.cid.toString(), a);
    }
    for (const r of result2.removals) {
      removals.set(r.cid.toString(), r);
    }
  }
  const result = await put(blocks, root2, key, value);
  if (result.root.toString() === root2.toString()) {
    return { root: root2, additions: [], removals: [], head };
  }
  for (const a of result.additions) {
    mblocks.putSync(a.cid, a.bytes);
    additions.set(a.cid.toString(), a);
  }
  for (const r of result.removals) {
    removals.set(r.cid.toString(), r);
  }
  const data = { type: "put", root: result.root, key, value };
  const event = await EventBlock.create(data, head);
  mblocks.putSync(event.cid, event.bytes);
  head = await advance(blocks, head, event.cid);
  for (const k of removals.keys()) {
    if (additions.has(k)) {
      additions.delete(k);
      removals.delete(k);
    }
  }
  return {
    root: result.root,
    additions: [...additions.values()],
    removals: [...removals.values()],
    head,
    event
  };
};
var root = async (blocks, head) => {
  if (!head.length)
    throw new Error("cannot determine root of headless clock");
  const mblocks = new MemoryBlockstore();
  blocks = new MultiBlockFetcher(mblocks, blocks);
  const events = new EventFetcher(blocks);
  if (head.length === 1) {
    const event = await events.get(head[0]);
    const { root: root3 } = event.value.data;
    return { root: root3, additions: [], removals: [] };
  }
  const ancestor = await findCommonAncestor(events, head);
  if (!ancestor)
    throw new Error("failed to find common ancestor event");
  const aevent = await events.get(ancestor);
  let { root: root2 } = aevent.value.data;
  const sorted = await findSortedEvents(events, head, ancestor);
  const additions = /* @__PURE__ */ new Map();
  const removals = /* @__PURE__ */ new Map();
  for (const { value: event } of sorted) {
    let result;
    if (event.data.type === "put") {
      result = await put(blocks, root2, event.data.key, event.data.value);
    } else if (event.data.type === "del") {
      result = await del(blocks, root2, event.data.key);
    } else if (event.data.type === "batch") {
      const batch = await create7(blocks, root2);
      for (const op of event.data.ops) {
        if (op.type !== "put")
          throw new Error(`unsupported batch operation: ${op.type}`);
        await batch.put(op.key, op.value);
      }
      result = await batch.commit();
    } else {
      throw new Error(`unknown operation: ${event.data.type}`);
    }
    root2 = result.root;
    for (const a of result.additions) {
      mblocks.putSync(a.cid, a.bytes);
      additions.set(a.cid.toString(), a);
    }
    for (const r of result.removals) {
      removals.set(r.cid.toString(), r);
    }
  }
  for (const k of removals.keys()) {
    if (additions.has(k)) {
      additions.delete(k);
      removals.delete(k);
    }
  }
  return {
    root: root2,
    additions: [...additions.values()],
    removals: [...removals.values()]
  };
};
var get3 = async (blocks, head, key) => {
  if (!head.length)
    return;
  const result = await root(blocks, head);
  if (result.additions.length) {
    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks);
  }
  return get2(blocks, result.root, key);
};
var entries2 = async function* (blocks, head, options) {
  if (!head.length)
    return;
  const result = await root(blocks, head);
  if (result.additions.length) {
    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks);
  }
  yield* entries(blocks, result.root, options);
};
var findCommonAncestor = async (events, children) => {
  if (!children.length)
    return;
  const candidates = children.map((c) => [c]);
  while (true) {
    let changed = false;
    for (const c of candidates) {
      const candidate = await findAncestorCandidate(events, c[c.length - 1]);
      if (!candidate)
        continue;
      changed = true;
      c.push(candidate);
      const ancestor = findCommonString(candidates);
      if (ancestor)
        return ancestor;
    }
    if (!changed)
      return;
  }
};
var findAncestorCandidate = async (events, root2) => {
  const { value: event } = await events.get(root2);
  if (!event.parents.length)
    return root2;
  return event.parents.length === 1 ? event.parents[0] : findCommonAncestor(events, event.parents);
};
var findCommonString = (arrays) => {
  arrays = arrays.map((a) => [...a]);
  for (const arr of arrays) {
    for (const item of arr) {
      let matched = true;
      for (const other of arrays) {
        if (arr === other)
          continue;
        matched = other.some((i) => String(i) === String(item));
        if (!matched)
          break;
      }
      if (matched)
        return item;
    }
  }
};
var findSortedEvents = async (events, head, tail) => {
  if (head.length === 1 && head[0].toString() === tail.toString()) {
    return [];
  }
  const weights = /* @__PURE__ */ new Map();
  const all = await Promise.all(head.map((h) => findEvents(events, h, tail)));
  for (const arr of all) {
    for (const { event, depth } of arr) {
      const info = weights.get(event.cid.toString());
      if (info) {
        info.weight += depth;
      } else {
        weights.set(event.cid.toString(), { event, weight: depth });
      }
    }
  }
  const buckets = /* @__PURE__ */ new Map();
  for (const { event, weight } of weights.values()) {
    const bucket = buckets.get(weight);
    if (bucket) {
      bucket.push(event);
    } else {
      buckets.set(weight, [event]);
    }
  }
  return Array.from(buckets).sort((a, b) => b[0] - a[0]).flatMap(([, es]) => es.sort((a, b) => String(a.cid) < String(b.cid) ? -1 : 1));
};
var findEvents = async (events, start, end, depth = 0) => {
  const event = await events.get(start);
  const acc = [{ event, depth }];
  const { parents } = event.value;
  if (parents.length === 1 && String(parents[0]) === String(end))
    return acc;
  const rest = await Promise.all(parents.map((p) => findEvents(events, p, end, depth + 1)));
  return acc.concat(...rest);
};

// core/base/crdt-helpers.ts
init_clock();

// node_modules/.pnpm/@web3-storage+pail@0.6.2/node_modules/@web3-storage/pail/dist/src/crdt/batch/index.js
init_clock();
init_clock();
var Batcher2 = class _Batcher {
  #committed = false;
  /**
   * @param {object} init
   * @param {API.BlockFetcher} init.blocks Block storage.
   * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.
   * @param {API.BatcherShardEntry[]} init.entries The entries in this shard.
   * @param {string} init.prefix Key prefix.
   * @param {number} init.version Shard compatibility version.
   * @param {string} init.keyChars Characters allowed in keys, referring to a known character set.
   * @param {number} init.maxKeySize Max key size in bytes.
   * @param {API.ShardBlockView} init.base Original shard this batcher is based on.
   * @param {API.ShardBlockView[]} init.additions Additions to include in the committed batch.
   * @param {API.ShardBlockView[]} init.removals Removals to include in the committed batch.
   */
  constructor({ blocks, head, entries: entries4, prefix, version: version2, keyChars, maxKeySize, base: base2, additions, removals }) {
    this.blocks = blocks;
    this.head = head;
    this.prefix = prefix;
    this.entries = [...entries4];
    this.base = base2;
    this.version = version2;
    this.keyChars = keyChars;
    this.maxKeySize = maxKeySize;
    this.additions = additions;
    this.removals = removals;
    this.ops = [];
  }
  /**
   * @param {string} key The key of the value to put.
   * @param {API.UnknownLink} value The value to put.
   * @returns {Promise<void>}
   */
  async put(key, value) {
    if (this.#committed)
      throw new BatchCommittedError();
    await put2(this.blocks, this, key, value);
    this.ops.push({ type: "put", key, value });
  }
  async commit() {
    if (this.#committed)
      throw new BatchCommittedError();
    this.#committed = true;
    const res = await commit2(this);
    const data = { type: "batch", ops: this.ops, root: res.root };
    const event = await EventBlock.create(data, this.head);
    const mblocks = new MemoryBlockstore();
    const blocks = new MultiBlockFetcher(mblocks, this.blocks);
    mblocks.putSync(event.cid, event.bytes);
    const head = await advance(blocks, this.head, event.cid);
    const additions = /* @__PURE__ */ new Map();
    const removals = /* @__PURE__ */ new Map();
    for (const a of this.additions) {
      additions.set(a.cid.toString(), a);
    }
    for (const r of this.removals) {
      removals.set(r.cid.toString(), r);
    }
    for (const a of res.additions) {
      if (removals.has(a.cid.toString())) {
        removals.delete(a.cid.toString());
      }
      additions.set(a.cid.toString(), a);
    }
    for (const r of res.removals) {
      if (additions.has(r.cid.toString())) {
        additions.delete(r.cid.toString());
      } else {
        removals.set(r.cid.toString(), r);
      }
    }
    return {
      head,
      event,
      root: res.root,
      additions: [...additions.values()],
      removals: [...removals.values()]
    };
  }
  /**
   * @param {object} init
   * @param {API.BlockFetcher} init.blocks Block storage.
   * @param {API.EventLink<API.Operation>[]} init.head Merkle clock head.
   */
  static async create({ blocks, head }) {
    const mblocks = new MemoryBlockstore();
    blocks = new MultiBlockFetcher(mblocks, blocks);
    if (!head.length) {
      const base3 = await ShardBlock.create();
      mblocks.putSync(base3.cid, base3.bytes);
      return new _Batcher({
        blocks,
        head,
        entries: [],
        base: base3,
        additions: [base3],
        removals: [],
        ...configure(base3.value)
      });
    }
    const { root: root2, additions, removals } = await root(blocks, head);
    for (const a of additions) {
      mblocks.putSync(a.cid, a.bytes);
    }
    const shards = new ShardFetcher(blocks);
    const base2 = await shards.get(root2);
    return new _Batcher({
      blocks,
      head,
      entries: base2.value.entries,
      base: base2,
      additions,
      removals,
      ...configure(base2.value)
    });
  }
};
var create8 = (blocks, head) => Batcher2.create({ blocks, head });

// core/base/crdt-helpers.ts
init_base2();
function toString4(key, logger) {
  switch (typeof key) {
    case "string":
    case "number":
      return key.toString();
    default:
      throw logger.Error().Msg("Invalid key type").AsError();
  }
}
function toPailFetcher(tblocks) {
  return {
    get: async (link) => {
      const block = await tblocks.get(link);
      return block ? {
        cid: block.cid,
        bytes: block.bytes
      } : void 0;
    }
  };
}
function sanitizeDocumentFields(obj) {
  if (Array.isArray(obj)) {
    return obj.map((item) => {
      if (typeof item === "object" && item !== null) {
        return sanitizeDocumentFields(item);
      }
      return item;
    });
  } else if (typeof obj === "object" && obj !== null) {
    if (obj instanceof Date) {
      return obj.toISOString();
    }
    const typedObj = obj;
    const result = {};
    for (const key in typedObj) {
      if (Object.hasOwnProperty.call(typedObj, key)) {
        const value = typedObj[key];
        if (value === null || !Number.isNaN(value) && value !== void 0) {
          if (typeof value === "object" && !key.startsWith("_")) {
            if (value instanceof Date) {
              result[key] = value.toISOString();
            } else {
              const sanitized = sanitizeDocumentFields(value);
              result[key] = sanitized;
            }
          } else {
            result[key] = value;
          }
        }
      }
    }
    return result;
  }
  return obj;
}
async function applyBulkUpdateToCrdt(store, tblocks, head, updates, logger) {
  let result = null;
  if (updates.length > 1) {
    const batch = await create8(toPailFetcher(tblocks), head);
    for (const update of updates) {
      const link = await writeDocContent(store, tblocks, update, logger);
      await batch.put(toString4(update.id, logger), link);
    }
    result = await batch.commit();
  } else if (updates.length === 1) {
    const link = await writeDocContent(store, tblocks, updates[0], logger);
    result = await put3(toPailFetcher(tblocks), head, toString4(updates[0].id, logger), link);
  }
  if (!result) throw logger.Error().Uint64("updates.len", updates.length).Msg("Missing result").AsError();
  if (result.event) {
    for (const block of [
      ...result.additions,
      // ...result.removals,
      result.event
    ]) {
      tblocks.putSync(await anyBlock2FPBlock(block));
    }
  }
  return { head: result.head };
}
async function writeDocContent(store, blocks, update, logger) {
  let value;
  if (update.del) {
    value = { del: true };
  } else {
    if (!update.value) throw logger.Error().Msg("Missing value").AsError();
    await processFiles(store, blocks, update.value, logger);
    value = { doc: update.value };
  }
  const block = await doc2FPBlock(value);
  blocks.putSync(block);
  return block.cid;
}
async function processFiles(store, blocks, doc, logger) {
  if (doc._files) {
    await processFileset(logger, store, blocks, doc._files);
  }
  if (doc._publicFiles) {
    await processFileset(
      logger,
      store,
      blocks,
      doc._publicFiles
      /*, true*/
    );
  }
}
async function processFileset(logger, store, blocks, files) {
  const dbBlockstore = blocks.parent;
  if (!dbBlockstore.loader) throw logger.Error().Msg("Missing loader, ledger name is required").AsError();
  const t = new CarTransactionImpl(dbBlockstore);
  const didPut = [];
  for (const filename in files) {
    if (File === files[filename].constructor) {
      const file2 = files[filename];
      const { cid, blocks: fileBlocks } = await store.encodeFile(file2);
      didPut.push(filename);
      for (const block of fileBlocks) {
        t.putSync(await fileBlock2FPBlock(block));
      }
      files[filename] = { cid, type: file2.type, size: file2.size, lastModified: file2.lastModified };
    } else {
      const { cid, type, size, car, lastModified } = files[filename];
      if (cid && type && size && car) {
        files[filename] = { cid, type, size, car, lastModified };
      }
    }
  }
  if (didPut.length) {
    const car = await dbBlockstore.loader.commitFiles(
      t,
      { files }
    );
    if (car) {
      for (const name2 of didPut) {
        files[name2] = { car, ...files[name2] };
      }
    }
  }
}
async function getValueFromCrdt(blocks, head, key, logger) {
  if (!head.length) throw logger.Debug().Msg("Getting from an empty ledger").AsError();
  const link = await get3(toPailFetcher(blocks), head, key);
  if (!link) {
    throw new NotFoundError(`Not found: ${key}`);
  }
  const ret = await getValueFromLink(blocks, link, logger);
  return ret;
}
function readFiles(blocks, { doc }) {
  if (!doc) return;
  if (doc._files) {
    readFileset(blocks, doc._files);
  }
  if (doc._publicFiles) {
    readFileset(blocks, doc._publicFiles, true);
  }
}
function readFileset(blocks, files, isPublic = false) {
  for (const filename in files) {
    const fileMeta = files[filename];
    if (fileMeta.cid) {
      if (isPublic) {
        fileMeta.url = `https://${fileMeta.cid.toString()}.ipfs.w3s.link/`;
      }
      if (fileMeta.car) {
        fileMeta.file = async () => {
          const result = await blocks.ebOpts.storeRuntime.decodeFile(
            {
              get: async (cid) => {
                return await blocks.getFile(throwFalsy(fileMeta.car), cid);
              }
            },
            fileMeta.cid,
            fileMeta
          );
          if (result.isErr()) {
            throw blocks.logger.Error().Any("error", result.Err()).Any("cid", fileMeta.cid).Msg("Error decoding file").AsError();
          }
          return result.unwrap();
        };
      }
    }
    files[filename] = fileMeta;
  }
}
async function getValueFromLink(blocks, link, logger) {
  const block = await blocks.get(link);
  if (!block) throw logger.Error().Str("link", link.toString()).Msg(`Missing linked block`).AsError();
  const { value } = await asyncBlockDecode({ bytes: block.bytes, hasher: sha256, codec: src_exports });
  const cvalue = {
    ...value,
    cid: link
  };
  readFiles(blocks, cvalue);
  return cvalue;
}
var DirtyEventFetcher = class extends EventFetcher {
  logger;
  constructor(logger, blocks) {
    super(toPailFetcher(blocks));
    this.logger = logger;
  }
  async get(link) {
    try {
      return await super.get(link);
    } catch (e) {
      this.logger.Error().Ref("link", link.toString()).Err(e).Msg("Missing event");
      return { value: void 0 };
    }
  }
};
async function clockChangesSince(blocks, head, since, opts, logger) {
  const eventsFetcher = opts.dirty ? new DirtyEventFetcher(logger, blocks) : new EventFetcher(toPailFetcher(blocks));
  const keys = /* @__PURE__ */ new Set();
  const updates = await gatherUpdates(
    blocks,
    eventsFetcher,
    head,
    since,
    [],
    keys,
    /* @__PURE__ */ new Set(),
    opts.limit || Infinity,
    logger
  );
  return { result: updates.reverse(), head };
}
async function gatherUpdates(blocks, eventsFetcher, head, since, updates = [], keys, didLinks, limit, logger) {
  if (limit <= 0) return updates;
  const sHead = head.map((l) => l.toString());
  for (const link of since) {
    if (sHead.includes(link.toString())) {
      return updates;
    }
  }
  for (const link of head) {
    if (didLinks.has(link.toString())) continue;
    didLinks.add(link.toString());
    const { value: event } = await eventsFetcher.get(link);
    if (!event) continue;
    const { type } = event.data;
    let ops = [];
    if (type === "batch") {
      ops = event.data.ops;
    } else if (type === "put") {
      ops = [event.data];
    }
    for (let i = ops.length - 1; i >= 0; i--) {
      const { key, value } = ops[i];
      if (!keys.has(key)) {
        const docValue = await getValueFromLink(blocks, value, logger);
        if (key === PARAM.GENESIS_CID) {
          continue;
        }
        updates.push({ id: key, value: docValue.doc, del: docValue.del, clock: link });
        limit--;
        keys.add(key);
      }
    }
    if (event.parents) {
      updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit, logger);
    }
  }
  return updates;
}
async function* getAllEntries(blocks, head, logger) {
  for await (const [key, link] of entries2(toPailFetcher(blocks), head)) {
    if (key !== PARAM.GENESIS_CID) {
      const docValue = await getValueFromLink(blocks, link, logger);
      yield { id: key, value: docValue.doc, del: docValue.del };
    }
  }
}
async function* clockVis(blocks, head) {
  for await (const line of vis(toPailFetcher(blocks), head)) {
    yield line;
  }
}
async function getBlock(blocks, cidString) {
  const block = await blocks.get(parse4(cidString));
  if (!block) throw new Error(`Missing block ${cidString}`);
  const { cid, value } = await asyncBlockDecode({ bytes: block.bytes, codec: src_exports, hasher: sha256 });
  return new Block({ cid, value, bytes: block.bytes });
}

// core/base/crdt.ts
init_base2();
init_runtime2();

// core/base/crdt-clock.ts
init_clock();
init_base2();

// core/base/apply-head-queue.ts
function applyHeadQueue(worker, logger) {
  const queue = [];
  let isProcessing = false;
  async function* process2() {
    if (isProcessing || queue.length === 0) return;
    isProcessing = true;
    const allUpdates = [];
    try {
      while (queue.length > 0) {
        queue.sort((a, b) => b.updates ? 1 : -1);
        const task = queue.shift();
        if (!task) continue;
        await worker(task.newHead, task.prevHead, task.updates !== void 0).catch((e) => {
          throw logger.Error().Err(e).Msg("int_applyHead worker error").AsError();
        });
        if (task.updates) {
          allUpdates.push(...task.updates);
        }
        if (!queue.some((t) => t.updates) || task.updates) {
          const allTasksHaveUpdates = queue.every((task2) => task2.updates !== null);
          yield { updates: allUpdates, all: allTasksHaveUpdates };
          allUpdates.length = 0;
        }
      }
    } finally {
      isProcessing = false;
      const generator = process2();
      let result = await generator.next();
      while (!result.done) {
        result = await generator.next();
      }
    }
  }
  return {
    push(task) {
      queue.push(task);
      return process2();
    },
    size() {
      return queue.length;
    }
  };
}

// core/base/crdt-clock.ts
init_runtime2();
var CRDTClockImpl = class {
  // todo: track local and remote clocks independently, merge on read
  // that way we can drop the whole remote if we need to
  // should go with making sure the local clock only references locally available blockstore on write
  head = [];
  zoomers = /* @__PURE__ */ new Map();
  watchers = /* @__PURE__ */ new Map();
  noPayloadWatchers = /* @__PURE__ */ new Map();
  blockstore;
  // ready blockstore
  applyHeadQueue;
  transaction;
  async ready() {
  }
  async close() {
  }
  logger;
  sthis;
  constructor(blockstore) {
    this.sthis = blockstore.sthis;
    this.blockstore = blockstore;
    this.logger = ensureLogger(blockstore.sthis, `CRDTClock`).With().Str("dbName", blockstore.crdtParent?.ledgerParent?.name || "unnamed").Logger();
    this.applyHeadQueue = applyHeadQueue(this.int_applyHead.bind(this), this.logger);
  }
  setHead(head) {
    this.head.splice(0, this.head.length, ...head);
  }
  async applyHead(newHead, prevHead, updates) {
    for await (const { updates: updatesAcc, all } of this.applyHeadQueue.push({
      newHead,
      prevHead,
      updates
    })) {
      return this.processUpdates(updatesAcc, all, prevHead);
    }
  }
  async processUpdates(updatesAcc, all, prevHead) {
    let internalUpdates = updatesAcc;
    if (this.watchers.size && !all) {
      const changes = await clockChangesSince(this.blockstore, this.head, prevHead, {}, this.logger);
      internalUpdates = changes.result;
    }
    this.zoomers.forEach((fn) => fn());
    this.notifyWatchers(internalUpdates || []);
  }
  notifyWatchers(updates) {
    updates = updates.filter((update) => update.id !== PARAM.GENESIS_CID);
    if (!updates.length) {
      return;
    }
    this.logger.Debug().Int("updatesCount", updates.length).Int("watchersCount", this.watchers.size).Int("noPayloadWatchersCount", this.noPayloadWatchers.size).Msg("NOTIFY_WATCHERS: Triggering subscriptions");
    this.noPayloadWatchers.forEach((fn) => fn());
    this.watchers.forEach((fn) => fn(updates || []));
  }
  onTick(fn) {
    const key = this.sthis.timeOrderedNextId().str;
    this.watchers.set(key, fn);
    return () => {
      this.watchers.delete(key);
    };
  }
  onTock(fn) {
    const key = this.sthis.timeOrderedNextId().str;
    this.noPayloadWatchers.set(key, fn);
    return () => {
      this.noPayloadWatchers.delete(key);
    };
  }
  onZoom(fn) {
    const key = this.sthis.timeOrderedNextId().str;
    this.zoomers.set(key, fn);
    return () => {
      this.zoomers.delete(key);
    };
  }
  async int_applyHead(newHead, prevHead, localUpdates) {
    const noLoader = !localUpdates;
    const needsManualNotification = !localUpdates && (this.watchers.size > 0 || this.noPayloadWatchers.size > 0);
    this.logger.Debug().Bool("localUpdates", localUpdates).Int("watchersCount", this.watchers.size).Int("noPayloadWatchersCount", this.noPayloadWatchers.size).Bool("needsManualNotification", needsManualNotification).Int("headLength", newHead.length).Int("prevHeadLength", prevHead.length).Int("currentHeadLength", this.head.length).Msg("INT_APPLY_HEAD: Entry point");
    const ogHead = sortClockHead(this.head);
    newHead = sortClockHead(newHead);
    if (compareClockHeads(ogHead, newHead)) {
      return;
    }
    const ogPrev = sortClockHead(prevHead);
    if (compareClockHeads(ogHead, ogPrev)) {
      this.setHead(newHead);
      return;
    }
    if (!this.blockstore) {
      throw this.logger.Error().Msg("missing blockstore").AsError();
    }
    await validateBlocks(this.logger, newHead, this.blockstore);
    if (!this.transaction) {
      this.transaction = this.blockstore.openTransaction({ noLoader, add: false });
    }
    const tblocks = this.transaction;
    const advancedHead = await advanceBlocks(this.logger, newHead, tblocks, this.head);
    const result = await root(toPailFetcher(tblocks), advancedHead);
    const fpBlocks = await Promise.all(result.additions.map(anyBlock2FPBlock));
    for (const fp of fpBlocks) {
      tblocks.putSync(fp);
    }
    if (!noLoader) {
      await this.blockstore.commitTransaction(tblocks, { head: advancedHead }, { add: false, noLoader });
      this.transaction = void 0;
    }
    this.setHead(advancedHead);
    if (needsManualNotification) {
      const changes = await clockChangesSince(this.blockstore, advancedHead, prevHead, {}, this.logger);
      const triggerReason = this.watchers.size > 0 && this.noPayloadWatchers.size > 0 ? "both" : this.watchers.size > 0 ? "watchers" : "noPayloadWatchers";
      this.logger.Debug().Int("changesCount", changes.result.length).Str("triggerReason", triggerReason).Int("watchersCount", this.watchers.size).Int("noPayloadWatchersCount", this.noPayloadWatchers.size).Msg("MANUAL_NOTIFICATION: Checking for changes");
      if (changes.result.length > 0) {
        this.logger.Debug().Msg("MANUAL_NOTIFICATION: Calling notifyWatchers with changes");
        this.notifyWatchers(changes.result);
        this.noPayloadWatchers.forEach((fn) => fn());
      } else {
        this.logger.Debug().Msg("MANUAL_NOTIFICATION: Calling noPayloadWatchers directly");
        this.noPayloadWatchers.forEach((fn) => fn());
      }
    }
  }
};
function sortClockHead(clockHead) {
  return clockHead.sort((a, b) => a.toString().localeCompare(b.toString()));
}
async function validateBlocks(logger, newHead, blockstore) {
  if (!blockstore) throw logger.Error().Msg("missing blockstore");
  await Promise.all(
    newHead.map(async (cid) => {
      const got = await blockstore.get(cid);
      if (!got) {
        throw logger.Error().Str("cid", cid.toString()).Msg("int_applyHead missing block").AsError();
      }
    })
  );
}
function compareClockHeads(head1, head2) {
  return head1.toString() === head2.toString();
}
async function advanceBlocks(logger, newHead, tblocks, head) {
  for (const cid of newHead) {
    try {
      head = await advance(toPailFetcher(tblocks), head, cid);
    } catch (e) {
      logger.Error().Err(e).Msg("failed to advance head");
    }
  }
  return head;
}

// core/base/crdt.ts
function tracerAction(opts, parent) {
  return (event) => {
    switch (event.event) {
      case "idleFromCommitQueue":
        opts.tracer({
          event: "idleFromBlockstore",
          blockstore: "data",
          ledger: parent
        });
        break;
      case "busyFromCommitQueue":
        opts.tracer({
          event: "busyFromBlockstore",
          blockstore: "data",
          ledger: parent,
          queueLen: event.queueLen
        });
        break;
      default:
        return opts.tracer(event);
    }
  };
}
var CRDTImpl = class {
  opts;
  blockstore;
  // we can run without an index instance
  indexBlockstore;
  indexers = /* @__PURE__ */ new Map();
  clock;
  logger;
  sthis;
  // self reference to fullfill HasCRDT
  crdt;
  ledgerParent;
  constructor(sthis, opts, parent) {
    this.sthis = sthis;
    this.ledgerParent = parent;
    this.crdt = this;
    this.logger = ensureLogger(sthis, "CRDTImpl");
    this.opts = opts;
    const rCompactStrategy = getCompactStrategy(this.opts.compactStrategy);
    if (rCompactStrategy.isErr()) {
      throw this.logger.Error().Err(rCompactStrategy.Err()).Str("compactorName", this.opts.compactStrategy).Msg("compactor not found").AsError();
    }
    const blockstoreOpts = {
      tracer: tracerAction(opts, parent),
      applyMeta: async (meta3) => {
        const crdtMeta = meta3;
        if (!crdtMeta.head) throw this.logger.Error().Msg("missing head").AsError();
        this.logger.Debug().Str("newHead", crdtMeta.head.map((h) => h.toString()).join(",")).Int("subscribers", this.clock.watchers.size + this.clock.noPayloadWatchers.size).Int("headLength", crdtMeta.head.length).Int("currentHeadLength", this.clock.head.length).Str("dbName", this.opts.name || "unnamed").Msg("APPLY_META: Calling applyHead for REMOTE sync");
        await this.clock.applyHead(crdtMeta.head, []);
      },
      compactStrategy: rCompactStrategy.Ok(),
      gatewayInterceptor: opts.gatewayInterceptor,
      // autoCompact: this.opts.autoCompact || 100,
      storeRuntime: toStoreRuntime(this.sthis, this.opts.storeEnDe),
      storeUrls: this.opts.storeUrls.data,
      keyBag: this.opts.keyBag,
      // public: this.opts.public,
      meta: this.opts.meta
      // threshold: this.opts.threshold,
    };
    this.blockstore = new EncryptedBlockstore(sthis, blockstoreOpts, this);
    if (this.opts.storeUrls.idx) {
      this.indexBlockstore = new EncryptedBlockstore(
        sthis,
        {
          tracer: opts.tracer,
          // name: opts.name,
          applyMeta: async (meta3) => {
            const idxCarMeta = meta3;
            if (!idxCarMeta.indexes) throw this.logger.Error().Msg("missing indexes").AsError();
            for (const [name2, idx] of Object.entries(idxCarMeta.indexes)) {
              index(this, name2, void 0, idx);
            }
          },
          gatewayInterceptor: opts.gatewayInterceptor,
          storeRuntime: toStoreRuntime(this.sthis, this.opts.storeEnDe),
          storeUrls: this.opts.storeUrls.idx,
          keyBag: this.opts.keyBag
          // public: this.opts.public,
        },
        this
      );
    }
    this.clock = new CRDTClockImpl(this.blockstore);
    this.clock.onZoom(() => {
      for (const idx of this.indexers.values()) {
        idx._resetIndex();
      }
    });
  }
  async bulk(updates) {
    await this.ready();
    updates = updates.map((dupdate) => ({
      ...dupdate,
      value: sanitizeDocumentFields(dupdate.value)
    }));
    if (this.clock.head.length === 0) {
      const value = { id: PARAM.GENESIS_CID, value: { _id: PARAM.GENESIS_CID } };
      await this._bulk([value]);
    }
    return await this._bulk(updates);
  }
  async _bulk(updates) {
    const prevHead = [...this.clock.head];
    const done = await this.blockstore.transaction(async (blocks) => {
      const { head } = await applyBulkUpdateToCrdt(
        this.blockstore.ebOpts.storeRuntime,
        blocks,
        this.clock.head,
        updates,
        this.logger
      );
      updates = updates.map((dupdate) => {
        readFiles(this.blockstore, { doc: dupdate.value });
        return dupdate;
      });
      return { head };
    });
    this.logger.Debug().Str("newHead", done.meta.head.map((h) => h.toString()).join(",")).Int("subscribers", this.clock.watchers.size + this.clock.noPayloadWatchers.size).Int("headLength", done.meta.head.length).Int("prevHeadLength", prevHead.length).Int("currentHeadLength", this.clock.head.length).Str("dbName", this.opts.name || "unnamed").Msg("BULK: Calling applyHead for LOCAL write");
    await this.clock.applyHead(done.meta.head, prevHead, updates);
    return done.meta;
  }
  onceReady = new ResolveOnce();
  async ready() {
    return this.onceReady.once(async () => {
      try {
        await Promise.all([
          this.blockstore.ready(),
          this.indexBlockstore ? this.indexBlockstore.ready() : Promise.resolve(),
          this.clock.ready()
        ]);
      } catch (e) {
        throw this.logger.Error().Err(e).Msg(`CRDT is not ready`).AsError();
      }
    });
  }
  async close() {
    await Promise.all([
      this.blockstore.close(),
      this.indexBlockstore ? this.indexBlockstore.close() : Promise.resolve(),
      this.clock.close()
    ]);
  }
  async destroy() {
    await Promise.all([this.blockstore.destroy(), this.indexBlockstore ? this.indexBlockstore.destroy() : Promise.resolve()]);
  }
  // if (snap) await this.clock.applyHead(crdtMeta.head, this.clock.head)
  async allDocs() {
    await this.ready();
    const result = [];
    for await (const entry of getAllEntries(this.blockstore, this.clock.head, this.logger)) {
      result.push(entry);
    }
    return { result, head: this.clock.head };
  }
  async vis() {
    await this.ready();
    const txt = [];
    for await (const line of clockVis(this.blockstore, this.clock.head)) {
      txt.push(line);
    }
    return txt.join("\n");
  }
  async getBlock(cidString) {
    await this.ready();
    return await getBlock(this.blockstore, cidString);
  }
  async get(key) {
    await this.ready();
    const result = await getValueFromCrdt(this.blockstore, this.clock.head, key, this.logger);
    if (result.del) return void 0;
    return result;
  }
  async changes(since = [], opts = {}) {
    await this.ready();
    return await clockChangesSince(this.blockstore, this.clock.head, since, opts, this.logger);
  }
  async compact() {
    const blocks = this.blockstore;
    return await blocks.compact();
  }
};

// core/base/ledger.ts
var ledgers = new KeyedResolvOnce();
function keyConfigOpts(sthis, name2, opts) {
  return JSON.stringify(
    toSortedArray({
      name: name2,
      stores: toSortedArray(JSON.parse(JSON.stringify(toStoreURIRuntime(sthis, name2, opts?.storeUrls))))
    })
  );
}
function LedgerFactory(name2, opts) {
  const sthis = ensureSuperThis(opts);
  const key = keyConfigOpts(sthis, name2, opts);
  const item = ledgers.get(key);
  return new LedgerShell(
    item.once(() => {
      const db = new LedgerImpl(sthis, {
        name: name2,
        meta: opts?.meta,
        keyBag: defaultKeyBagOpts(sthis, opts?.keyBag),
        storeUrls: toStoreURIRuntime(sthis, name2, opts?.storeUrls),
        gatewayInterceptor: opts?.gatewayInterceptor,
        compactStrategy: opts?.compactStrategy,
        writeQueue: defaultWriteQueueOpts(opts?.writeQueue),
        ctx: opts?.ctx ?? new AppContext(),
        storeEnDe: {
          encodeFile,
          decodeFile,
          ...opts?.storeEnDe
        },
        tracer: opts?.tracer ?? (() => {
        })
      });
      db.onClosed(() => {
        ledgers.unget(key);
      });
      return db;
    })
  );
}
var LedgerShell = class {
  ref;
  writeQueue;
  name;
  constructor(ref) {
    this.ref = ref;
    this.writeQueue = ref.writeQueue;
    this.name = ref.name;
    ref.addShell(this);
  }
  attach(a) {
    return this.ref.attach(a);
  }
  get opts() {
    return this.ref.opts;
  }
  get ctx() {
    return this.ref.ctx;
  }
  refId() {
    return this.ref.refId();
  }
  // get id(): string {
  //   return this.ref.id;
  // }
  get logger() {
    return this.ref.logger;
  }
  get sthis() {
    return this.ref.sthis;
  }
  get crdt() {
    return this.ref.crdt;
  }
  onClosed(fn) {
    return this.ref.onClosed(fn);
  }
  close() {
    return this.ref.shellClose(this);
  }
  destroy() {
    return this.ref.destroy();
  }
  ready() {
    return this.ref.ready();
  }
  // asDB(): Database {
  //   return this.ref.asDB();
  // }
  subscribe(listener, updates) {
    return this.ref.subscribe(listener, updates);
  }
};
var LedgerImpl = class {
  // readonly name: string;
  opts;
  _listening = false;
  _listeners = /* @__PURE__ */ new Set();
  _noupdate_listeners = /* @__PURE__ */ new Set();
  crdt;
  writeQueue;
  // readonly blockstore: BaseBlockstore;
  shells = /* @__PURE__ */ new Set();
  ctx;
  get name() {
    return this.opts.name;
  }
  addShell(shell) {
    this.shells.add(shell);
  }
  refId = Lazy(() => hashObjectSync(keyConfigOpts(this.sthis, this.name, this.opts)));
  _onClosedFns = /* @__PURE__ */ new Map();
  onClosed(fn) {
    const id = this.sthis.nextId().str;
    this._onClosedFns.set(id, fn);
    return () => {
      this._onClosedFns.delete(id);
    };
  }
  async close() {
    throw this.logger.Error().Str("db", this.name).Msg(`use shellClose`).AsError();
  }
  async shellClose(db) {
    if (!this.shells.has(db)) {
      throw this.logger.Error().Str("db", this.name).Msg(`LedgerShell mismatch`).AsError();
    }
    this.shells.delete(db);
    if (this.shells.size === 0) {
      await this.ready();
      await this.crdt.close();
      await this.writeQueue.close();
      this._onClosedFns.forEach((fn) => fn());
    }
  }
  async destroy() {
    await this.ready();
    await this.crdt.destroy();
  }
  _ready = new ResolveOnce();
  async ready() {
    const ret = await this._ready.once(async () => {
      await this.sthis.start();
      await this.crdt.ready();
    });
    return ret;
  }
  logger;
  sthis;
  // readonly id: string;
  constructor(sthis, opts) {
    this.opts = {
      tracer: () => {
      },
      ...opts
    };
    this.sthis = sthis;
    this.ctx = opts.ctx;
    this.logger = ensureLogger(this.sthis, "Ledger");
    this.crdt = new CRDTImpl(this.sthis, this.opts, this);
    this.writeQueue = writeQueue(
      this.sthis,
      async (updates) => this.crdt.bulk(updates),
      this.opts.writeQueue
    );
    this.crdt.clock.onTock(() => this._no_update_notify());
  }
  async attach(a) {
    await this.ready();
    return this.crdt.blockstore.loader.attach(a);
  }
  // readonly _asDb = new ResolveOnce<Database>();
  // asDB(): Database {
  //   return this._asDb.once(() => new DatabaseImpl(this));
  // }
  subscribe(listener, updates) {
    this.ready();
    this.logger.Debug().Bool("updates", updates).Msg("subscribe");
    if (updates) {
      if (!this._listening) {
        this._listening = true;
        this.crdt.clock.onTick((updates2) => {
          void this._notify(updates2);
        });
      }
      this._listeners.add(listener);
      return () => {
        this._listeners.delete(listener);
      };
    } else {
      this._noupdate_listeners.add(listener);
      return () => {
        this._noupdate_listeners.delete(listener);
      };
    }
  }
  async _notify(updates) {
    await this.ready();
    if (this._listeners.size) {
      const docs = updates.map(({ id, value }) => ({ ...value, _id: id }));
      for (const listener of this._listeners) {
        await (async () => await listener(docs))().catch((e) => {
          this.logger.Error().Err(e).Msg("subscriber error");
        });
      }
    }
  }
  async _no_update_notify() {
    await this.ready();
    if (this._noupdate_listeners.size) {
      for (const listener of this._noupdate_listeners) {
        await (async () => await listener([]))().catch((e) => {
          this.logger.Error().Err(e).Msg("subscriber error");
        });
      }
    }
  }
};
function toStoreURIRuntime(sthis, name2, sopts) {
  sopts = sopts || {};
  if (!sopts.base) {
    const fp_env = sthis.env.get("FP_STORAGE_URL");
    if (fp_env) {
      sopts = { ...sopts, base: BuildURI.from(fp_env).setParam(PARAM.URL_GEN, "fromEnv") };
    } else {
      sopts = { ...sopts, base: getDefaultURI(sthis).build().setParam(PARAM.URL_GEN, "default") };
    }
  }
  const base2 = URI.from(sopts.base);
  return {
    idx: {
      car: ensureURIDefaults(sthis, { name: name2 }, sopts.idx?.car ?? sopts.data?.car, base2, "car", { idx: true }),
      file: ensureURIDefaults(
        sthis,
        { name: name2 },
        sopts.idx?.file ?? sopts.idx?.car ?? sopts.data?.file ?? sopts.data?.car,
        base2,
        "file",
        {
          file: true,
          idx: true
        }
      ),
      meta: ensureURIDefaults(sthis, { name: name2 }, sopts.idx?.meta ?? sopts.data?.meta, base2, "meta", { idx: true }),
      wal: ensureURIDefaults(sthis, { name: name2 }, sopts.idx?.wal ?? sopts.data?.wal, base2, "wal", { idx: true })
    },
    data: {
      car: ensureURIDefaults(sthis, { name: name2 }, sopts.data?.car, base2, "car"),
      file: ensureURIDefaults(sthis, { name: name2 }, sopts.data?.file ?? sopts.data?.car, base2, "file", { file: true }),
      meta: ensureURIDefaults(sthis, { name: name2 }, sopts.data?.meta, base2, "meta"),
      wal: ensureURIDefaults(sthis, { name: name2 }, sopts.data?.wal, base2, "wal")
    }
  };
}
function fireproof(name2, opts) {
  return new DatabaseImpl(LedgerFactory(name2, opts));
}

// core/base/version.ts
var PACKAGE_VERSION = Object.keys({
  __packageVersion__: "xxxx"
})[0];

// core/base/compact-strategies.ts
init_clock();
init_runtime2();
registerCompactStrategy({
  name: "fireproof",
  compact: async (ctx) => {
    const head = ctx.clock?.head || [];
    timerStart(ctx, "compact head");
    for (const cid of head) {
      const bl = await ctx.get(cid);
      if (!bl) throw ctx.logger.Error().Ref("cid", cid).Msg("Missing head block").AsError();
    }
    timerEnd(ctx, "compact head");
    timerStart(ctx, "compact all entries");
    for await (const _entry of getAllEntries(ctx, head, ctx.logger)) {
    }
    timerEnd(ctx, "compact all entries");
    timerStart(ctx, "compact clock vis");
    for await (const _line of vis(toPailFetcher(ctx), head)) {
    }
    timerEnd(ctx, "compact clock vis");
    timerStart(ctx, "compact root");
    const result = await root(toPailFetcher(ctx), head);
    timerEnd(ctx, "compact root");
    timerStart(ctx, "compact root blocks");
    for (const block of [...result.additions, ...result.removals]) {
      ctx.loggedBlocks.putSync(await anyBlock2FPBlock(block));
    }
    timerEnd(ctx, "compact root blocks");
    timerStart(ctx, "compact changes");
    await clockChangesSince(ctx, head, [], {}, ctx.logger);
    timerEnd(ctx, "compact changes");
    return { head: ctx.clock?.head };
  }
});
registerCompactStrategy({
  name: "full",
  compact: async (ctx) => {
    if (!ctx.lastTxMeta) {
      throw ctx.logger.Error().Msg("no lastTxMeta").AsError();
    }
    for await (const blk of ctx.loader.entries(false)) {
      ctx.loggedBlocks.putSync(blk);
    }
    for (const t of ctx.transactions) {
      for await (const blk of t.entries()) {
        ctx.loggedBlocks.putSync(blk);
      }
    }
    return ctx.lastTxMeta;
  }
});
registerCompactStrategy({
  name: "no-op",
  compact: async () => {
    return {};
  }
});

// core/base/index.ts
init_runtime2();

// use-fireproof/base/react/use-fireproof.ts
import { useMemo as useMemo5 } from "react";

// use-fireproof/base/react/use-attach.ts
init_esm();
import { useEffect, useState } from "react";
init_runtime2();
var WebCtx = "webCtx";
var webCtxs = new KeyedResolvOnce();
var initialCtx = {
  tokenAndClaims: { state: "initial" }
};
var prepareWebctxs = new KeyedResolvOnce();
function createAttach(database, config2) {
  const [attachState, setAttachState] = useState({ state: "initial", ctx: initialCtx });
  useEffect(() => {
    if (!config2.attach) {
      return;
    }
    prepareWebctxs.get(database.ledger.refId() + config2.attach.configHash(database.ledger)).once(() => {
      if (config2.attach && attachState.state === "initial") {
        setAttachState((prev) => ({ ...prev, state: "attaching" }));
        async function prepareWebctx(attachable) {
          const webCtx = attachable.opts.context.get(WebCtx);
          if (!webCtx) {
            throw database.logger.Error().Msg("WebCtx not found").AsError();
          }
          await webCtx.ready(database);
          webCtx.onTokenChange((token) => {
            if (!token) {
              setAttachState((prev) => ({ ...prev, state: "initial", ctx: initialCtx }));
              return;
            }
            setAttachState((prev) => ({
              ...prev,
              ctx: {
                ...prev.ctx,
                tokenAndClaims: {
                  state: "ready",
                  tokenAndClaims: token,
                  reset: () => {
                    webCtx.resetToken().then(
                      () => setAttachState((prev2) => ({
                        ...prev2,
                        state: "initial",
                        ctx: initialCtx
                      }))
                    );
                  }
                }
              }
            }));
          });
          const rAttached = await exception2Result(async () => {
            const ret = await database.attach(attachable);
            return ret;
          });
          if (rAttached.isErr()) {
            database.logger.Error().Err(rAttached).Msg("attach error");
            setAttachState((prev) => ({ ...prev, state: "error", error: rAttached.Err() }));
          } else {
            const attached = rAttached.Ok();
            setAttachState((prev) => ({
              ...prev,
              state: "attached",
              attached
            }));
          }
        }
        prepareWebctx(config2.attach);
      }
    });
  }, [database, config2.attach, attachState.state]);
  return attachState;
}

// use-fireproof/base/react/use-all-docs.ts
import { useCallback, useEffect as useEffect2, useMemo, useRef, useState as useState2 } from "react";
function createUseAllDocs(database) {
  return function useAllDocs(query = {}) {
    const [hydrated, setHydrated] = useState2(false);
    const [result, setResult] = useState2({
      docs: []
    });
    const queryString = useMemo(() => JSON.stringify(query), [query]);
    const requestIdRef = useRef(0);
    useEffect2(() => {
      setHydrated(false);
      requestIdRef.current += 1;
    }, [queryString]);
    const refreshRows = useCallback(async () => {
      const myReq = ++requestIdRef.current;
      const res = await database.allDocs(query);
      if (myReq === requestIdRef.current) {
        setResult({
          ...res,
          docs: res.rows.map((r) => r.value)
        });
        setHydrated(true);
      }
    }, [database, query, queryString]);
    useEffect2(() => {
      refreshRows();
      const unsubscribe = database.subscribe(refreshRows);
      return () => {
        unsubscribe();
      };
    }, [database, refreshRows]);
    return { ...result, hydrated };
  };
}

// use-fireproof/base/react/use-changes.ts
import { useCallback as useCallback2, useEffect as useEffect3, useMemo as useMemo2, useRef as useRef2, useState as useState3 } from "react";
function createUseChanges(database) {
  return function useChanges(since = [], opts = {}) {
    const [hydrated, setHydrated] = useState3(false);
    const [result, setResult] = useState3({
      docs: []
    });
    const queryString = useMemo2(() => JSON.stringify(opts), [opts]);
    const sinceString = useMemo2(() => JSON.stringify(since), [since]);
    const requestIdRef = useRef2(0);
    useEffect3(() => {
      setHydrated(false);
      requestIdRef.current += 1;
    }, [sinceString, queryString]);
    const refreshRows = useCallback2(async () => {
      const myReq = ++requestIdRef.current;
      const res = await database.changes(since, opts);
      if (myReq === requestIdRef.current) {
        setResult({ ...res, docs: res.rows.map((r) => r.value) });
        setHydrated(true);
      }
    }, [database, since, opts, sinceString, queryString]);
    useEffect3(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return { ...result, hydrated };
  };
}

// use-fireproof/base/react/use-document.ts
init_runtime2();
import { useCallback as useCallback3, useEffect as useEffect4, useMemo as useMemo3, useState as useState4, useRef as useRef3 } from "react";
function createUseDocument(database) {
  return function useDocument(initialDocOrFn) {
    const updateHappenedRef = useRef3(false);
    const [hydrated, setHydrated] = useState4(false);
    let initialDoc;
    if (typeof initialDocOrFn === "function") {
      initialDoc = initialDocOrFn();
    } else {
      initialDoc = initialDocOrFn ?? {};
    }
    const originalInitialDoc = useMemo3(() => deepClone({ ...initialDoc }), []);
    const [doc, setDoc] = useState4(initialDoc);
    const requestIdRef = useRef3(0);
    const initialDocId = initialDoc._id;
    const initialDocIdString = useMemo3(() => String(initialDocId ?? ""), [initialDocId]);
    const prevDocIdRef = useRef3(doc._id);
    useEffect4(() => {
      setHydrated(false);
      requestIdRef.current += 1;
    }, [initialDocIdString]);
    useEffect4(() => {
      if (initialDocId !== prevDocIdRef.current) {
        prevDocIdRef.current = initialDocId;
        setDoc(initialDoc);
      }
    }, [initialDocId]);
    const refresh = useCallback3(async () => {
      const myReq = ++requestIdRef.current;
      const currentDocId = doc._id;
      if (currentDocId) {
        try {
          const gotDoc = await database.get(currentDocId);
          if (myReq === requestIdRef.current && gotDoc._id === currentDocId) {
            setDoc(gotDoc);
            setHydrated(true);
          }
        } catch {
          if (myReq === requestIdRef.current) {
            setDoc(initialDoc);
            setHydrated(true);
          }
        }
      } else {
        if (myReq === requestIdRef.current) {
          setDoc(initialDoc);
          setHydrated(true);
        }
      }
    }, [doc._id]);
    const save = useCallback3(
      async (existingDoc) => {
        updateHappenedRef.current = false;
        const toSave = existingDoc ?? doc;
        const res = await database.put(toSave);
        if (!updateHappenedRef.current && !doc._id && !existingDoc) {
          setDoc((d) => ({ ...d, _id: res.id }));
        }
        return res;
      },
      [doc]
    );
    const remove = useCallback3(
      async (existingDoc) => {
        const id = existingDoc?._id ?? doc._id;
        if (!id) throw database.logger.Error().Msg(`Document must have an _id to be removed`).AsError();
        const gotDoc = await database.get(id).catch(() => void 0);
        if (!gotDoc) throw database.logger.Error().Str("id", id).Msg(`Document not found`).AsError();
        const res = await database.del(id);
        setDoc(initialDoc);
        return res;
      },
      [doc, initialDoc]
    );
    const merge3 = useCallback3((newDoc) => {
      updateHappenedRef.current = true;
      setDoc((prev) => ({ ...prev, ...newDoc }));
    }, []);
    const replace = useCallback3((newDoc) => {
      updateHappenedRef.current = true;
      setDoc(newDoc);
    }, []);
    const reset = useCallback3(() => {
      updateHappenedRef.current = true;
      setDoc({ ...originalInitialDoc });
    }, [originalInitialDoc]);
    const updateDoc = useCallback3(
      (newDoc, opts = { replace: false, reset: false }) => {
        if (!newDoc) {
          return opts.reset ? reset() : refresh();
        }
        return opts.replace ? replace(newDoc) : merge3(newDoc);
      },
      [refresh, reset, replace, merge3]
    );
    useEffect4(() => {
      if (!doc._id) return;
      return database.subscribe((changes) => {
        if (updateHappenedRef.current) {
          return;
        }
        if (changes.find((c) => c._id === doc._id)) {
          void refresh();
        }
      }, true);
    }, [doc._id, refresh]);
    useEffect4(() => {
      void refresh();
    }, [refresh]);
    const submit = useCallback3(
      async (e) => {
        if (e?.preventDefault) e.preventDefault();
        await save();
        reset();
      },
      [save, reset]
    );
    const apiObject = {
      doc: { ...doc },
      hydrated,
      merge: merge3,
      replace,
      reset,
      refresh,
      save,
      remove,
      submit
    };
    const tuple2 = [{ ...doc }, updateDoc, save, remove, reset, refresh];
    Object.assign(apiObject, tuple2);
    Object.defineProperty(apiObject, Symbol.iterator, {
      enumerable: false,
      value: function* () {
        yield* tuple2;
      }
    });
    return apiObject;
  };
}

// use-fireproof/base/react/use-live-query.ts
import { useCallback as useCallback4, useEffect as useEffect5, useMemo as useMemo4, useState as useState5 } from "react";
function createUseLiveQuery(database) {
  return function useLiveQuery(mapFn, query = {}, initialRows = []) {
    const [hydrated, setHydrated] = useState5(false);
    const [result, setResult] = useState5(() => ({
      docs: initialRows.map((r) => r.doc).filter((r) => !!r),
      rows: initialRows
    }));
    const queryString = useMemo4(() => JSON.stringify(query), [query]);
    const mapFnString = useMemo4(() => mapFn.toString(), [mapFn]);
    useEffect5(() => {
      setHydrated(false);
    }, [mapFnString, queryString]);
    const refreshRows = useCallback4(async () => {
      const res = await database.query(mapFn, { ...query, includeDocs: true });
      database.logger.Debug().Str("dbname", database.name).Uint64("rows", res.rows.length).Msg("Refreshing live query");
      setResult(res);
      setHydrated(true);
    }, [database, mapFnString, queryString]);
    useEffect5(() => {
      database.logger.Debug().Str("dbname", database.name).Msg("Initializing live query subscription");
      const unsubscribe = database.subscribe(refreshRows);
      return () => {
        unsubscribe();
      };
    }, [database, refreshRows]);
    useEffect5(() => {
      refreshRows();
    }, [database, queryString, mapFnString]);
    return { ...result, hydrated };
  };
}

// use-fireproof/base/react/use-fireproof.ts
init_runtime2();
function useFireproof(name2 = "useFireproof", config2 = {}) {
  const strConfig = hashObjectSync(config2);
  const database = useMemo5(() => typeof name2 === "string" ? fireproof(name2, config2) : name2, [name2, strConfig]);
  const attach = createAttach(database, config2);
  const useDocument = useMemo5(() => createUseDocument(database), [database.name, strConfig]);
  const useLiveQuery = useMemo5(() => createUseLiveQuery(database), [database.name, strConfig]);
  const useAllDocs = useMemo5(() => createUseAllDocs(database), [database.name, strConfig]);
  const useChanges = useMemo5(() => createUseChanges(database), [database.name, strConfig]);
  return { database, useLiveQuery, useDocument, useAllDocs, useChanges, attach };
}

// use-fireproof/base/react/img-file.ts
init_esm();
import React, { useState as useState6, useEffect as useEffect6, useLayoutEffect, useRef as useRef4, useMemo as useMemo6 } from "react";
var objectUrlCache = new LRUMap({
  maxEntries: 50
  // Limit to 50 cached object URLs to manage memory
});

// use-fireproof/base/index.ts
init_base2();

// use-fireproof/base/iframe-strategy.ts
init_esm();

// use-fireproof/base/redirect-strategy.ts
init_esm();
init_webapi();

// node_modules/.pnpm/dompurify@3.3.1/node_modules/dompurify/dist/purify.es.mjs
var {
  entries: entries3,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
var {
  freeze,
  seal,
  create: create9
} = Object;
var {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply2(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return func.apply(thisArg, args);
  };
}
if (!construct) {
  construct = function construct2(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return new Func(...args);
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var arraySplice = unapply(Array.prototype.splice);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(Func) {
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return construct(Func, args);
  };
}
function addToSet(set3, array2) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set3, null);
  }
  let l = array2.length;
  while (l--) {
    let element = array2[l];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array2)) {
          array2[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set3[element] = true;
  }
  return set3;
}
function cleanArray(array2) {
  for (let index2 = 0; index2 < array2.length; index2++) {
    const isPropertyExist = objectHasOwnProperty(array2, index2);
    if (!isPropertyExist) {
      array2[index2] = null;
    }
  }
  return array2;
}
function clone2(object2) {
  const newObject = create9(null);
  for (const [property, value] of entries3(object2)) {
    const isPropertyExist = objectHasOwnProperty(object2, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone2(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object2, prop) {
  while (object2 !== null) {
    const desc = getOwnPropertyDescriptor(object2, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object2 = getPrototypeOf(object2);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
var NODE_TYPE2 = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
var _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root2) => createDOMPurify(root2);
  DOMPurify.version = "3.3.1";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE2.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node3,
    Element,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries3 === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create9(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  const EXTRA_ELEMENT_HANDLING = Object.seal(create9(null, {
    tagCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    }
  }));
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone2(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone2(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone2(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone2({});
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone2({});
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (typeof cfg.ADD_TAGS === "function") {
        EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
      } else {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone2(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
    }
    if (cfg.ADD_ATTR) {
      if (typeof cfg.ADD_ATTR === "function") {
        EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
      } else {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone2(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone2(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (cfg.ADD_FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone2(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name2),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name2);
    if (name2 === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {
        }
      } else {
        try {
          element.setAttribute(name2, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root2) {
    return createNodeIterator.call(
      root2.ownerDocument || root2,
      root2,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node3 === "function" && value instanceof Node3;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE2.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE2.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE2.text) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l = attributes.length;
    while (l--) {
      const attr = attributes[l];
      const {
        name: name2,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name2);
      const initValue = attrValue;
      let value = name2 === "value" ? initValue : stringTrim(initValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (lcName === "attributename" && stringMatch(value, "href")) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      if (!hookEvent.keepAttr) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name2, value);
          } else {
            currentNode.setAttribute(name2, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_) {
          _removeAttribute(name2, currentNode);
        }
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node3) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE2.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag2, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag2);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// core/protocols/dashboard/index.ts
init_v4();

// core/protocols/dashboard/msg-is.ts
function hasType(jso, t) {
  return typeof jso === "object" && jso !== null && jso.type === t;
}
var FAPIMsgImpl = class {
  isDeleteTenant(jso) {
    return hasType(jso, "reqDeleteTenant");
  }
  isUpdateTenant(jso) {
    return hasType(jso, "reqUpdateTenant");
  }
  isCreateTenant(jso) {
    return hasType(jso, "reqCreateTenant");
  }
  isDeleteInvite(jso) {
    return hasType(jso, "reqDeleteInvite");
  }
  isListInvites(jso) {
    return hasType(jso, "reqListInvites");
  }
  isInviteUser(jso) {
    return hasType(jso, "reqInviteUser");
  }
  isFindUser(jso) {
    return hasType(jso, "reqFindUser");
  }
  isRedeemInvite(jso) {
    return hasType(jso, "reqRedeemInvite");
  }
  isEnsureUser(jso) {
    return hasType(jso, "reqEnsureUser");
  }
  isListTenantsByUser(jso) {
    return hasType(jso, "reqListTenantsByUser");
  }
  isUpdateUserTenant(jso) {
    return hasType(jso, "reqUpdateUserTenant");
  }
  isListLedgersByUser(jso) {
    return hasType(jso, "reqListLedgersByUser");
  }
  isCreateLedger(jso) {
    return hasType(jso, "reqCreateLedger");
  }
  isUpdateLedger(jso) {
    return hasType(jso, "reqUpdateLedger");
  }
  isDeleteLedger(jso) {
    return hasType(jso, "reqDeleteLedger");
  }
  isCloudSessionToken(jso) {
    return hasType(jso, "reqCloudSessionToken");
  }
  isReqTokenByResultId(jso) {
    return hasType(jso, "reqTokenByResultId");
  }
  isResTokenByResultId(jso) {
    return hasType(jso, "resTokenByResultId");
  }
  isReqExtendToken(jso) {
    return hasType(jso, "reqExtendToken");
  }
  isReqCertFromCsr(jso) {
    return hasType(jso, "reqCertFromCsr");
  }
  isEnsureCloudToken(jso) {
    return hasType(jso, "reqEnsureCloudToken");
  }
};

// core/protocols/dashboard/msg-api.ts
init_esm();
var Api = class {
  apiUrl;
  isser = new FAPIMsgImpl();
  constructor(apiUrl) {
    this.apiUrl = apiUrl;
  }
  async request(req) {
    return exception2Result(async () => {
      const res = await fetch(this.apiUrl.toString(), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify(req)
      });
      if (res.ok) {
        const json2 = await res.json();
        return json2;
      }
      throw new Error(`Request failed: ${res.status} ${res.statusText} ${this.apiUrl}`);
    });
  }
  async waitForToken(req, logger) {
    const rTokenByResultId = await this.request({
      ...req,
      type: "reqTokenByResultId"
    });
    if (rTokenByResultId.isErr()) {
      return logger.Error().Err(rTokenByResultId).Msg("Error fetching token").ResultError();
    }
    const tokenByResultId = rTokenByResultId.unwrap();
    if (this.isser.isResTokenByResultId(tokenByResultId)) {
      if (tokenByResultId.status === "found") {
        const token = tokenByResultId.token;
        return Result.Ok({
          type: "resTokenByResultId",
          status: "found",
          resultId: req.resultId,
          token
        });
      }
    } else {
      logger.Warn().Any({ returned: tokenByResultId }).Msg("fetching token failed");
    }
    return Result.Ok({
      type: "resTokenByResultId",
      status: "not-found",
      resultId: req.resultId
    });
  }
};

// core/protocols/dashboard/dashboard-api.ts
init_esm();
var DashboardApiImpl = class {
  cfg;
  constructor(cfg) {
    this.cfg = {
      ...cfg
    };
  }
  async request(req) {
    const rAuth = await this.cfg.getToken(this.cfg.getTokenCtx);
    if (rAuth.isErr()) {
      return Result.Err(rAuth.Err());
    }
    const reqBody = JSON.stringify({
      ...req,
      auth: rAuth.Ok()
    });
    const res = await this.cfg.fetch(this.cfg.apiUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: reqBody
    });
    if (res.ok) {
      const jso = await res.json();
      return Result.Ok(jso);
    }
    const body = await res.text();
    return Result.Err(`HTTP: ${res.status} ${res.statusText}: ${body}`);
  }
  ensureUser(req) {
    return this.request({ ...req, type: "reqEnsureUser" });
  }
  findUser(req) {
    return this.request({ ...req, type: "reqFindUser" });
  }
  createTenant(req) {
    return this.request({ ...req, type: "reqCreateTenant" });
  }
  updateTenant(req) {
    return this.request({ ...req, type: "reqUpdateTenant" });
  }
  deleteTenant(req) {
    return this.request({ ...req, type: "reqDeleteTenant" });
  }
  connectUserToTenant(req) {
    return this.request({ ...req, type: "reqRedeemInvite" });
  }
  listTenantsByUser(req) {
    return this.request({ ...req, type: "reqListTenantsByUser" });
  }
  inviteUser(req) {
    return this.request({ ...req, type: "reqInviteUser" });
  }
  listInvites(req) {
    return this.request({ ...req, type: "reqListInvites" });
  }
  deleteInvite(req) {
    return this.request({ ...req, type: "reqDeleteInvite" });
  }
  updateUserTenant(req) {
    return this.request({ ...req, type: "reqUpdateUserTenant" });
  }
  createLedger(req) {
    return this.request({ ...req, type: "reqCreateLedger" });
  }
  updateLedger(req) {
    return this.request({ ...req, type: "reqUpdateLedger" });
  }
  deleteLedger(req) {
    return this.request({ ...req, type: "reqDeleteLedger" });
  }
  listLedgersByUser(req) {
    return this.request({ ...req, type: "reqListLedgersByUser" });
  }
  getCloudSessionToken(req) {
    return this.request({ ...req, type: "reqCloudSessionToken" });
  }
  getCertFromCsr(req) {
    return this.request({ ...req, type: "reqCertFromCsr" });
  }
  redeemInvite(req) {
    return this.request({ ...req, type: "reqRedeemInvite" });
  }
  getTokenByResultId(req) {
    return this.request({ ...req, type: "reqTokenByResultId" });
  }
  extendToken(req) {
    return this.request({ ...req, type: "reqExtendToken" });
  }
  #ensureCloudToken = new KeyedResolvOnce();
  ensureCloudToken(req) {
    return this.#ensureCloudToken.get(
      JSON.stringify({
        appId: req.appId,
        env: req.env ?? "prod",
        tenant: req.tenant ?? void 0,
        ledger: req.ledger ?? void 0
      })
    ).once(async (my) => {
      const rRes = await this.request({ ...req, type: "reqEnsureCloudToken" });
      if (rRes.isErr()) {
        return Result.Err(rRes);
      }
      const res = rRes.Ok();
      const resetAfter = res.expiresInSec * 1e3 - this.cfg.gracePeriodMs;
      my.self.setResetAfter(resetAfter < 0 ? 6e4 : resetAfter);
      return rRes;
    });
  }
};
var keyedDashApis = new KeyedResolvOnce();
function clerkDashApi(clerk, iopts) {
  return keyedDashApis.get(iopts.apiUrl).once(() => {
    const waitForToken = new WaitingForValue();
    const dashApi = new DashboardApiImpl({
      ...iopts,
      getTokenCtx: iopts.getTokenCtx ?? { template: iopts.template ?? "with-email" },
      gracePeriodMs: iopts.gracePeriodMs && iopts.gracePeriodMs > 0 ? iopts.gracePeriodMs : 5e3,
      getToken: () => waitForToken.waitValue().then((token) => Result.Ok({ type: "clerk", token })).catch((err) => Result.Err(err)),
      fetch: iopts.fetch ?? fetch.bind(globalThis)
    });
    clerk.addListener(({ session }) => {
      const preValue = waitForToken.value();
      waitForToken.setValue(Option.None());
      if (!(session && typeof session.getToken == "function")) {
        return;
      }
      exception2Result(() => session.getToken(dashApi.cfg.getTokenCtx)).then((rGetToken) => {
        if (rGetToken.isErr()) {
          waitForToken.setError(rGetToken.Err());
          waitForToken.setValue(preValue);
          return;
        }
        const token = rGetToken.Ok();
        waitForToken.setValue(Option.From(token));
      });
    });
    return dashApi;
  });
}

// core/protocols/dashboard/index.ts
var FPClerkClaimSchema = external_exports.object({
  payload: external_exports.object({
    // ...JWTPayloadSchema.shape,
    azp: external_exports.string().optional(),
    // authorized party
    exp: external_exports.number().int().optional(),
    // expiration time
    iat: external_exports.number().int().optional(),
    // issued at
    iss: external_exports.string().optional(),
    // issuer
    jti: external_exports.string().optional(),
    // JWT ID
    nbf: external_exports.number().int().optional(),
    // not before
    params: external_exports.object({
      email: external_exports.string(),
      email_verified: external_exports.boolean(),
      first: external_exports.string(),
      image_url: external_exports.string(),
      last: external_exports.string(),
      name: external_exports.string().nullable(),
      public_meta: external_exports.unknown()
    }).partial(),
    role: external_exports.string(),
    sub: external_exports.string(),
    userId: external_exports.string(),
    aud: external_exports.union([external_exports.string(), external_exports.array(external_exports.string())]).optional(),
    // audience
    app_metadata: external_exports.unknown().optional()
  }),
  protectedHeader: external_exports.object({
    alg: external_exports.string(),
    cat: external_exports.string(),
    kid: external_exports.string(),
    typ: external_exports.string()
  }).partial()
});

// use-fireproof/base/redirect-strategy.ts
init_runtime2();
function defaultOverlayHtml(redirectLink) {
  return `
    <div class="fpOverlayContent">
      <div class="fpCloseButton">&times;</div>
      Fireproof Dashboard
      Sign in to Fireproof Dashboard
      <a href="${redirectLink}" target="_blank">Redirect to Fireproof</a>
    </div>
  `;
}
var defaultOverlayCss = `
.fpContainer {
  position: relative; /* Needed for absolute positioning of the overlay */
}

.fpOverlay {
  display: none; /* Initially hidden */
  position: fixed; /* Covers the whole viewport */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  z-index: 1; /* Ensure it's on top of other content */
}

.fpOverlayContent {
  position: absolute;
  // width: calc(100vw - 50px);
  // height: calc(100vh - 50px);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* Center the content */
  // transform: translate(0%, 0%); /* Center the content */
  background-color: white;
  color: black;
  // margin: 10px;
  padding: 20px;
  border-radius: 5px;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
}

.fpCloseButton {
  position: absolute;
  top: 10px;
  right: 15px;
  font-size: 20px;
  cursor: pointer;
}
`;
var RedirectStrategy = class {
  resultId;
  overlayNode;
  waitState = "stopped";
  overlayCss;
  overlayHtml;
  constructor(opts = {}) {
    this.overlayCss = opts.overlayCss ?? defaultOverlayCss;
    this.overlayHtml = opts.overlayHtml ?? defaultOverlayHtml;
  }
  hash = Lazy(
    () => hashObjectSync({
      overlayCss: this.overlayCss,
      overlayHtml: this.overlayHtml("X").toString()
    })
  );
  open(sthis, logger, deviceId, opts) {
    const redirectCtx = opts.context.get(WebCtx);
    logger.Debug().Url(redirectCtx.dashboardURI).Msg("open redirect");
    this.resultId = sthis.nextId().str;
    const url2 = BuildURI.from(redirectCtx.dashboardURI).setParam("back_url", window.location.href).setParam("result_id", this.resultId).setParam("local_ledger_name", deviceId);
    if (opts.ledger) {
      url2.setParam("ledger", opts.ledger);
    }
    if (opts.tenant) {
      url2.setParam("tenant", opts.tenant);
    }
    let overlayNode = document.body.querySelector("#fpOverlay");
    if (!overlayNode) {
      const styleNode = document.createElement("style");
      styleNode.innerHTML = purify.sanitize(this.overlayCss);
      document.head.appendChild(styleNode);
      overlayNode = document.createElement("div");
      overlayNode.id = "fpOverlay";
      overlayNode.className = "fpOverlay";
      overlayNode.innerHTML = purify.sanitize(this.overlayHtml(url2.toString()));
      document.body.appendChild(overlayNode);
      overlayNode.querySelector(".fpCloseButton")?.addEventListener("click", () => {
        if (overlayNode) {
          if (overlayNode.style.display === "block") {
            overlayNode.style.display = "none";
            this.stop();
          } else {
            overlayNode.style.display = "block";
          }
        }
      });
    }
    overlayNode.style.display = "block";
    this.overlayNode = overlayNode;
    const width = 800;
    const height = 600;
    const parentScreenX = window.screenX || window.screenLeft;
    const parentScreenY = window.screenY || window.screenTop;
    const parentOuterWidth = window.outerWidth;
    const parentOuterHeight = window.outerHeight;
    const left = parentScreenX + parentOuterWidth / 2 - width / 2;
    const top = parentScreenY + parentOuterHeight / 2 - height / 2;
    window.open(
      url2.asURL(),
      "Fireproof Login",
      `left=${left},top=${top},width=${width},height=${height},scrollbars=yes,resizable=yes,popup=yes`
    );
  }
  currentToken;
  waiting;
  stop() {
    if (this.waiting) {
      clearTimeout(this.waiting);
      this.waiting = void 0;
    }
    this.waitState = "stopped";
  }
  async tryToken(sthis, logger, opts) {
    if (!this.currentToken) {
      const webCtx = opts.context.get(WebCtx);
      this.currentToken = await webCtx.token();
    }
    return this.currentToken;
  }
  async getTokenAndClaimsByResultId(logger, dashApi, resultId, opts, resolve, attempts = 0) {
    if (!resultId) {
      return logger.Error().Msg("No resultId");
    }
    if (this.waitState !== "started") {
      return;
    }
    if (attempts * opts.intervalSec > opts.tokenWaitTimeSec) {
      logger.Error().Uint64("attempts", attempts).Msg("Token polling timed out");
      this.stop();
      return;
    }
    const rWaitForToken = await dashApi.waitForToken({ resultId }, logger);
    if (rWaitForToken.isErr()) {
      return logger.Error().Err(rWaitForToken).Msg("Error fetching token").ResultError();
    }
    const waitedTokenByResultId = rWaitForToken.unwrap();
    if (waitedTokenByResultId.status === "found" && waitedTokenByResultId.token) {
      const token = waitedTokenByResultId.token;
      const claims = decodeJwt(token);
      this.overlayNode?.style.setProperty("display", "none");
      resolve({ token, claims });
      return;
    }
    this.waiting = setTimeout(() => this.getTokenAndClaimsByResultId(logger, dashApi, resultId, opts, resolve), opts.intervalSec);
  }
  async waitForToken(sthis, logger, deviceId, opts) {
    if (!this.resultId) {
      throw new Error("waitForToken not working on redirect strategy");
    }
    const webCtx = opts.context.get(WebCtx);
    const dashApi = new Api(webCtx.tokenApiURI);
    this.waitState = "started";
    return new Promise((resolve) => {
      this.getTokenAndClaimsByResultId(logger, dashApi, this.resultId, opts, (tokenAndClaims) => {
        this.currentToken = tokenAndClaims;
        resolve(tokenAndClaims);
      });
    });
  }
};

// use-fireproof/base/index.ts
init_runtime2();
var defaultRedirectStrategy = new RedirectStrategy();

// use-fireproof/clerk/dist/npm/clerk-token-strategy.js
var ClerkTokenStrategy = class {
  dashApi;
  apiUrl;
  lastExpiryMs = null;
  constructor(dashApi, apiUrl) {
    this.dashApi = dashApi;
    this.apiUrl = apiUrl;
  }
  getLastTokenExpiry() {
    return this.lastExpiryMs;
  }
  hash() {
    return this.apiUrl;
  }
  open() {
  }
  tryToken() {
    return Promise.resolve(void 0);
  }
  async waitForToken(_sthis, logger, deviceId, opts) {
    const rUser = await this.dashApi.ensureUser({});
    if (rUser.isErr()) {
      logger.Error().Err(rUser).Msg("Failed to ensure user");
      return void 0;
    }
    const appId = opts.context.get("appId") || `clerk-${deviceId}`;
    const rRes = await this.dashApi.ensureCloudToken({ appId });
    if (rRes.isErr()) {
      logger.Error().Err(rRes).Msg("Failed to get cloud token");
      return void 0;
    }
    const res = rRes.Ok();
    if (res.expiresDate) {
      this.lastExpiryMs = new Date(res.expiresDate).getTime();
    }
    return {
      token: res.cloudToken,
      ...res
    };
  }
  stop() {
  }
};

// use-fireproof/clerk/dist/npm/clerk-provider.js
import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useContext, useMemo as useMemo7 } from "react";
import { ClerkProvider as BaseClerkProvider, useClerk } from "@clerk/clerk-react";
var ClerkFireproofContext = createContext(null);
function InnerClerkFireproofProvider({ config: config2, children }) {
  const clerk = useClerk();
  const isSessionReady = clerk.session?.status === "active";
  const dashApi = useMemo7(() => {
    if (isSessionReady) {
      return clerkDashApi(clerk, { apiUrl: config2.apiUrl });
    }
    return null;
  }, [isSessionReady, clerk, config2.apiUrl]);
  const value = useMemo7(() => ({
    config: config2,
    isSessionReady,
    dashApi
  }), [config2, isSessionReady, dashApi]);
  return _jsx(ClerkFireproofContext.Provider, { value, children });
}
function ClerkFireproofProvider({ publishableKey, config: config2, children }) {
  return _jsx(BaseClerkProvider, { publishableKey, children: _jsx(InnerClerkFireproofProvider, { config: config2, children }) });
}
function useClerkFireproofContext() {
  const context = useContext(ClerkFireproofContext);
  if (!context) {
    throw new Error("useClerkFireproofContext must be used within a ClerkFireproofProvider");
  }
  return context;
}

// use-fireproof/clerk/dist/npm/use-fireproof-clerk.js
var REFRESH_BEFORE_EXPIRY_MS = 5 * 60 * 1e3;
var MIN_REFRESH_DELAY_MS = 30 * 1e3;
var AUTH_ERROR_RETRY_DELAY_MS = 2 * 1e3;
var DETACH_CLEANUP_DELAY_MS = 100;
function useFireproofClerk(name2) {
  const { config: config2, isSessionReady, dashApi } = useClerkFireproofContext();
  const [attachState, setAttachState] = useState7({ status: "detached" });
  const [syncStatus, setSyncStatus] = useState7("idle");
  const [lastSyncError, setLastSyncError] = useState7(void 0);
  const attachingRef = useRef5(false);
  const refreshTimerRef = useRef5(null);
  const strategyRef = useRef5(null);
  const fpResult = useFireproof(name2);
  const { database } = fpResult;
  const clearRefreshTimer = useCallback5(() => {
    if (refreshTimerRef.current) {
      clearTimeout(refreshTimerRef.current);
      refreshTimerRef.current = null;
    }
  }, []);
  const scheduleTokenRefresh = useCallback5((expiryMs, doRefresh) => {
    clearRefreshTimer();
    const now = Date.now();
    const refreshAt = expiryMs - REFRESH_BEFORE_EXPIRY_MS;
    const delay = Math.max(refreshAt - now, MIN_REFRESH_DELAY_MS);
    refreshTimerRef.current = setTimeout(doRefresh, delay);
  }, [clearRefreshTimer]);
  const performRefreshCycle = useCallback5(async () => {
    if (attachState.status !== "attached" || !attachState.attached || !dashApi) {
      return;
    }
    setSyncStatus("reconnecting");
    clearRefreshTimer();
    try {
      await attachState.attached.detach();
      await new Promise((resolve) => setTimeout(resolve, DETACH_CLEANUP_DELAY_MS));
      const strategy = new ClerkTokenStrategy(dashApi, config2.apiUrl);
      strategyRef.current = strategy;
      const appId = config2.appIdPrefix ? `${config2.appIdPrefix}-${typeof name2 === "string" ? name2 : name2.name}` : `clerk-${typeof window !== "undefined" ? window.location.host : "app"}-${typeof name2 === "string" ? name2 : name2.name}`;
      database.ledger.ctx.set("appId", appId);
      const cloud = toCloud({
        strategy,
        urls: { base: config2.cloudUrl }
      });
      const attached = await database.attach(cloud);
      const expiry = strategy.getLastTokenExpiry();
      if (expiry) {
        scheduleTokenRefresh(expiry, () => performRefreshCycle());
      }
      setAttachState({ status: "attached", attached });
      setSyncStatus("synced");
      setLastSyncError(void 0);
    } catch (err) {
      const error48 = err instanceof Error ? err : new Error(String(err));
      setSyncStatus("error");
      setLastSyncError(error48);
      setAttachState({ status: "error", error: error48 });
    }
  }, [attachState, dashApi, config2, name2, database, clearRefreshTimer, scheduleTokenRefresh]);
  const doAttach = useCallback5(async () => {
    if (!dashApi || attachingRef.current || attachState.status === "attached") {
      return;
    }
    attachingRef.current = true;
    setAttachState({ status: "attaching" });
    setSyncStatus("connecting");
    try {
      const strategy = new ClerkTokenStrategy(dashApi, config2.apiUrl);
      strategyRef.current = strategy;
      const appId = config2.appIdPrefix ? `${config2.appIdPrefix}-${typeof name2 === "string" ? name2 : name2.name}` : `clerk-${typeof window !== "undefined" ? window.location.host : "app"}-${typeof name2 === "string" ? name2 : name2.name}`;
      database.ledger.ctx.set("appId", appId);
      const cloud = toCloud({
        strategy,
        urls: { base: config2.cloudUrl }
      });
      const attached = await database.attach(cloud);
      const expiry = strategy.getLastTokenExpiry();
      if (expiry) {
        scheduleTokenRefresh(expiry, () => performRefreshCycle());
      }
      setAttachState({ status: "attached", attached });
      setSyncStatus("synced");
      setLastSyncError(void 0);
    } catch (err) {
      const error48 = err instanceof Error ? err : new Error(String(err));
      setSyncStatus("error");
      setLastSyncError(error48);
      setAttachState({ status: "error", error: error48 });
    } finally {
      attachingRef.current = false;
    }
  }, [dashApi, database, config2, name2, attachState.status, scheduleTokenRefresh, performRefreshCycle]);
  const doDetach = useCallback5(async () => {
    if (attachState.status !== "attached" || !attachState.attached) {
      return;
    }
    clearRefreshTimer();
    try {
      await attachState.attached.detach();
      setAttachState({ status: "detached" });
      setSyncStatus("idle");
    } catch (err) {
      setAttachState({
        status: "error",
        error: err instanceof Error ? err : new Error(String(err))
      });
      setSyncStatus("error");
    }
  }, [attachState, clearRefreshTimer]);
  useEffect7(() => {
    if (isSessionReady && dashApi && attachState.status === "detached") {
      doAttach();
    }
  }, [isSessionReady, dashApi, attachState.status, doAttach]);
  useEffect7(() => {
    if (!isSessionReady && attachState.status === "attached") {
      doDetach();
    }
  }, [isSessionReady, attachState.status, doDetach]);
  useEffect7(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && attachState.status === "attached" && strategyRef.current) {
        const expiry = strategyRef.current.getLastTokenExpiry();
        if (expiry && Date.now() > expiry - REFRESH_BEFORE_EXPIRY_MS) {
          performRefreshCycle();
        }
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => document.removeEventListener("visibilitychange", handleVisibilityChange);
  }, [attachState.status, performRefreshCycle]);
  useEffect7(() => {
    if (attachState.status === "error" && attachState.error && isSessionReady) {
      const msg = attachState.error.message.toLowerCase();
      const isAuthError = msg.includes("timeout") || msg.includes("auth") || msg.includes("token") || msg.includes("expired") || msg.includes("unauthorized");
      if (isAuthError) {
        const timer = setTimeout(() => {
          setAttachState({ status: "detached" });
          setSyncStatus("idle");
        }, AUTH_ERROR_RETRY_DELAY_MS);
        return () => clearTimeout(timer);
      }
    }
  }, [attachState, isSessionReady]);
  useEffect7(() => {
    return () => {
      clearRefreshTimer();
    };
  }, [clearRefreshTimer]);
  return {
    ...fpResult,
    attachState,
    doAttach,
    doDetach,
    isSyncing: attachState.status === "attached",
    syncStatus,
    lastSyncError
  };
}

// use-fireproof/clerk/dist/npm/index.js
import { SignInButton, SignedIn, SignedOut, UserButton, useUser, useClerk as useClerk2 } from "@clerk/clerk-react";
export {
  ClerkFireproofProvider,
  ClerkTokenStrategy,
  SignInButton,
  SignedIn,
  SignedOut,
  UserButton,
  useClerk2 as useClerk,
  useClerkFireproofContext,
  useFireproofClerk,
  useUser
};
/*! Bundled license information:

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE *)
*/
//# sourceMappingURL=fireproof-clerk-bundle.js.map
