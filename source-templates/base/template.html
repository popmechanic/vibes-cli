<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>__TITLE__</title>
    <link rel="icon" type="image/svg+xml" href="/assets/vibes-favicon/favicon.svg" />
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/vibes-favicon/favicon-96x96.png" />
    <link rel="icon" type="image/x-icon" href="/assets/vibes-favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/vibes-favicon/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/vibes-favicon/site.webmanifest" />
    <script>globalThis.process = { env: { NODE_ENV: "production" } };</script>
    <script src="https://unpkg.com/@babel/standalone@7.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      /* === DESIGN_TOKENS_PLACEHOLDER === */

      @media (prefers-color-scheme: dark) {
        :root {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
        }
      }

      /* Admin menu overrides - scoped to VibesPanel in HiddenMenuWrapper */
      #hidden-menu {
        /* Gray scale needed by components */
        --vibes-gray-lighter: #cccccc;
        --vibes-gray-pale: #e5e5e5;
        --vibes-gray-dark: #333333;

        /* Variant colors (fix yellow being red) */
        --vibes-variant-blue: #3b82f6;
        --vibes-variant-red: #ef4444;
        --vibes-variant-yellow: #eab308;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #2a2a2a;
        --vibes-button-icon-fill: var(--vibes-white);

        /* Dark-aware variants (used when ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card styling */
        --vibes-card-bg: var(--vibes-gray-pale);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Text */
        --vibes-text-primary: var(--vibes-gray-dark);

        /* Shadows */
        --vibes-shadow-color: var(--vibes-near-black);
      }

      @media (prefers-color-scheme: dark) {
        #hidden-menu {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
          --vibes-card-bg: var(--vibes-near-black);
          --vibes-card-text: var(--vibes-white);
          --vibes-card-border: var(--vibes-gray-mid);
        }
      }

      /* VibesSwitch toggle button - override app-level button styling */
      button[aria-controls="hidden-menu"] {
        background: transparent !important;
        background-color: transparent !important;
        padding: 0 !important;
        border: none !important;
      }

      /* Sync status indicator animations */
      @keyframes vibes-sync-pulse {
        0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
        100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
      }
      @keyframes vibesDelayedFadeIn { to { opacity: 1 } }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/stable/react@19.2.4",
          "react/jsx-runtime": "https://esm.sh/stable/react@19.2.4/jsx-runtime",
          "react/jsx-dev-runtime": "https://esm.sh/stable/react@19.2.4/jsx-dev-runtime",
          "react-dom": "https://esm.sh/stable/react-dom@19.2.4",
          "react-dom/client": "https://esm.sh/stable/react-dom@19.2.4/client",
          "multiformats": "https://esm.sh/stable/multiformats@13.3.1",
          "multiformats/": "https://esm.sh/stable/multiformats@13.3.1/",
          "@ipld/dag-cbor": "https://esm.sh/stable/@ipld/dag-cbor@9.2.2?external=multiformats",
          "@ipld/dag-json": "https://esm.sh/stable/@ipld/dag-json@10.2.3?external=multiformats",
          "@clerk/clerk-react": "https://esm.sh/stable/@clerk/clerk-react@5.59.2?external=react,react-dom",
          "use-fireproof": "/fireproof-vibes-bridge.js",
          "@fireproof/clerk": "/fireproof-vibes-bridge.js"
        }
      }
    </script>
    <!-- Connect configuration - populated by assemble.js from .env -->
    <script>
      window.__VIBES_CONFIG__ = {
        tokenApiUri: "__VITE_API_URL__",
        cloudBackendUrl: "__VITE_CLOUD_URL__",
        clerkPublishableKey: "__VITE_CLERK_PUBLISHABLE_KEY__"
      };
      // Default: single theme hides the Design button in VibesPanel.
      // Apps with multiple themes override this before menu loads.
      window.__VIBES_THEMES__ = [{ id: "default", name: "Default" }];
    </script>
    <!-- Load React globally for menu components -->
    <script type="module">
      import * as React from "react";
      window.React = React;

      // === COMPONENTS_PLACEHOLDER ===

      // === useAI Hook ===
      // AI hook for proxied OpenRouter calls with metering
      function useAI() {
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);

        const callAI = React.useCallback(async (options) => {
          setLoading(true);
          setError(null);

          try {
            // Get auth token if Clerk is available (sell apps)
            let authHeader = {};
            if (typeof window !== 'undefined' && window.Clerk?.session) {
              const token = await window.Clerk.session.getToken();
              if (token) {
                authHeader = { 'Authorization': 'Bearer ' + token };
              }
            }

            const response = await fetch('/api/ai/chat', {
              method: 'POST',
              headers: Object.assign({ 'Content-Type': 'application/json' }, authHeader),
              body: JSON.stringify(Object.assign({
                model: options.model || (window.__VIBES_CONFIG__ && window.__VIBES_CONFIG__.defaultModel) || 'anthropic/claude-sonnet-4',
                messages: options.messages
              }, options))
            });

            // Handle limit exceeded (402 from OpenRouter)
            if (response.status === 402) {
              const err = { code: 'LIMIT_EXCEEDED', message: 'AI usage limit reached for this month.' };
              setError(err);
              throw err;
            }

            // Handle other errors
            if (!response.ok) {
              const errorData = await response.json().catch(function() { return {}; });
              const err = {
                code: 'API_ERROR',
                message: (errorData.error && errorData.error.message) || ('API error: ' + response.status),
                status: response.status
              };
              setError(err);
              throw err;
            }

            return await response.json();

          } catch (err) {
            setError({ code: 'NETWORK_ERROR', message: err.message || 'Network error' });
            throw err;
          } finally {
            setLoading(false);
          }
        }, []);

        return { callAI: callAI, loading: loading, error: error, clearError: function() { setError(null); } };
      }
      window.useAI = useAI;

      // === Shared Error Components ===
      function ConfigError({ message }) {
        // Use AuthScreen if available, fallback to simple div
        if (window.AuthScreen) {
          return React.createElement(window.AuthScreen, {
            title: 'Configuration Error',
            message: message,
            showCard: false,
            isError: true,
            errorDetails: 'Run Connect setup to configure Clerk credentials.'
          },
            React.createElement('p', { style: { color: '#7f1d1d', fontSize: '0.875rem' } },
              'Check your .env file for missing credentials.'
            )
          );
        }
        // Fallback for when AuthScreen hasn't loaded
        return React.createElement('div', { className: 'min-h-screen flex items-center justify-center bg-gray-50' },
          React.createElement('div', { className: 'text-center p-8 bg-white rounded-xl shadow-lg max-w-md border border-red-200' },
            React.createElement('div', { className: 'text-red-500 text-4xl mb-4' }, '⚠️'),
            React.createElement('h1', { className: 'text-xl font-bold text-red-700 mb-4' }, 'Configuration Error'),
            React.createElement('p', { className: 'text-gray-600 mb-4' }, message),
            React.createElement('p', { className: 'text-sm text-gray-500' }, 'Run Connect setup to configure Clerk credentials.')
          )
        );
      }
      window.ConfigError = ConfigError;

      function LoadingError({ error }) {
        // Use AuthScreen if available, fallback to simple div
        if (window.AuthScreen) {
          return React.createElement(window.AuthScreen, {
            title: 'Loading Failed',
            message: 'Failed to load authentication components. Check your network connection and try refreshing the page.',
            showCard: false,
            isError: true,
            errorDetails: error
          },
            React.createElement('button', {
              onClick: function() { window.location.reload(); },
              style: {
                padding: '0.75rem 1.5rem',
                backgroundColor: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: '500'
              }
            }, 'Retry')
          );
        }
        // Fallback for when AuthScreen hasn't loaded
        return React.createElement('div', { className: 'min-h-screen flex items-center justify-center bg-gray-50' },
          React.createElement('div', { className: 'text-center p-8 bg-white rounded-xl shadow-lg max-w-md border border-amber-200' },
            React.createElement('div', { className: 'text-amber-500 text-4xl mb-4' }, '⚡'),
            React.createElement('h1', { className: 'text-xl font-bold text-amber-700 mb-4' }, 'Loading Failed'),
            React.createElement('p', { className: 'text-gray-600 mb-4' }, 'Failed to load authentication components.'),
            React.createElement('p', { className: 'text-sm text-gray-500 mb-4' }, 'Check your network connection and try refreshing the page.'),
            React.createElement('details', { className: 'text-left text-xs text-gray-400' },
              React.createElement('summary', { className: 'cursor-pointer' }, 'Technical details'),
              React.createElement('pre', { className: 'mt-2 p-2 bg-gray-100 rounded overflow-auto' }, error)
            )
          )
        );
      }
      window.LoadingError = LoadingError;

      // === SyncStatusDot ===
      // Renders a fixed-position sync status indicator in the top-right corner.
      // Reads status from window.__VIBES_SYNC_STATUS__ via a custom event bridge.
      // Activates automatically when the app calls useFireproofClerk().
      var SYNC_STATUS_COLORS = {
        idle: '#94a3b8',
        connecting: '#eab308',
        synced: '#22c55e',
        reconnecting: '#eab308',
        error: '#ef4444'
      };
      var SYNC_STATUS_LABELS = {
        idle: '',
        connecting: 'connecting',
        synced: 'synced',
        reconnecting: 'reconnecting',
        error: 'offline'
      };

      function SyncStatusDot() {
        var statusRef = React.useRef(window.__VIBES_SYNC_STATUS__ || 'idle');
        var _s = React.useState(0);
        var forceUpdate = _s[1];

        React.useEffect(function() {
          function onStatusChange() {
            var next = window.__VIBES_SYNC_STATUS__ || 'idle';
            statusRef.current = next;
            forceUpdate(function(n) { return n + 1; });
          }
          window.addEventListener('vibes-sync-status-change', onStatusChange);
          return function() {
            window.removeEventListener('vibes-sync-status-change', onStatusChange);
          };
        }, []);

        var status = statusRef.current;
        var color = SYNC_STATUS_COLORS[status] || '#94a3b8';
        var label = SYNC_STATUS_LABELS[status] || '';
        var isIdle = status === 'idle';
        var isSynced = status === 'synced';

        // Pill container — fixed top-right, frosted glass
        var containerStyle = {
          position: 'fixed',
          top: '12px',
          right: '12px',
          zIndex: 50,
          pointerEvents: 'none',
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          background: 'rgba(245, 245, 244, 0.6)',
          backdropFilter: 'blur(8px)',
          WebkitBackdropFilter: 'blur(8px)',
          padding: '6px 12px',
          borderRadius: '100px',
          border: '1px solid rgba(0, 0, 0, 0.03)',
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
          fontSize: '12px',
          fontWeight: '500',
          letterSpacing: '0.01em',
          userSelect: 'none',
          opacity: isIdle ? 0 : 1,
          transition: 'opacity 0.3s ease'
        };

        // Status light wrapper — relative for positioning pulse ring
        var lightWrapperStyle = {
          position: 'relative',
          width: '8px',
          height: '8px'
        };

        // Pulse ring — only rendered when synced
        var pulseRingStyle = {
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: color,
          animation: 'vibes-sync-pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1)'
        };

        // Status light — 8px solid dot
        var dotStyle = {
          width: '8px',
          height: '8px',
          borderRadius: '50%',
          backgroundColor: color,
          position: 'relative',
          transition: 'background-color 0.4s ease'
        };

        // Label text
        var labelStyle = {
          color: '#111111',
          paddingTop: '1px',
          letterSpacing: '0.01em'
        };

        return React.createElement('div', {
          style: containerStyle,
          'aria-hidden': 'true',
          title: 'Sync: ' + status
        },
          React.createElement('div', { style: lightWrapperStyle },
            isSynced ? React.createElement('div', { style: pulseRingStyle }) : null,
            React.createElement('div', { style: dotStyle })
          ),
          label ? React.createElement('span', { style: labelStyle }, label) : null
        );
      }
      window.SyncStatusDot = SyncStatusDot;

      // === SharingBridge ===
      // Must be rendered inside ClerkFireproofProvider > SignedIn.
      // Bridges vibes-share-request DOM events to the dashApi.
      function SharingBridge() {
        var ctx = window.useClerkFireproofContext();
        var dashApi = ctx.dashApi;
        var dashApiRef = React.useRef(null);
        var ledgerCacheRef = React.useRef(null);
        dashApiRef.current = dashApi;

        React.useEffect(function() {
          function handleShareRequest(e) {
            var detail = e.detail;
            var email = detail.email;
            var api = dashApiRef.current;

            if (!api) {
              document.dispatchEvent(new CustomEvent('vibes-share-error', {
                detail: { error: { message: 'Sharing not ready. Please try again.' } }
              }));
              return;
            }

            (async function() {
              try {
                // Discover ledger for this app — check cached sources first
                var appHost = window.location.hostname;
                var qpSub = new URLSearchParams(window.location.search).get('subdomain');
                var cachedLedgerId = null;
                var ledgerMap = window.__VIBES_LEDGER_MAP__ || {};
                if (qpSub) {
                  // Sell template: find map entry matching '-' + subdomain
                  var mapKeys = Object.keys(ledgerMap);
                  for (var mk = 0; mk < mapKeys.length; mk++) {
                    if (mapKeys[mk].endsWith('-' + qpSub)) {
                      cachedLedgerId = ledgerMap[mapKeys[mk]];
                      break;
                    }
                  }
                }
                // Fallback: single entry in map (vibes apps with ?subdomain= param)
                if (!cachedLedgerId) {
                  var mapVals = Object.values(ledgerMap);
                  if (mapVals.length === 1) cachedLedgerId = mapVals[0];
                }
                if (!cachedLedgerId) cachedLedgerId = window.__VIBES_SHARED_LEDGER__ || null;

                var matchedLedger;
                if (cachedLedgerId) {
                  matchedLedger = { ledgerId: cachedLedgerId };
                } else {
                  // Fall back to listLedgersByUser
                  if (!ledgerCacheRef.current) {
                    var rLedgers = await api.listLedgersByUser({});
                    if (rLedgers.isErr()) throw new Error('Could not load ledger list');
                    ledgerCacheRef.current = rLedgers.Ok().ledgers;
                  }
                  var ledgers = ledgerCacheRef.current;
                  matchedLedger = ledgers.find(function(l) {
                    if (!l.name) return false;
                    if (l.name.includes(appHost)) return true;
                    // Workers.dev fallback: match by worker-name + subdomain
                    if (qpSub) {
                      var workerName = appHost.split('.')[0];
                      if (l.name.includes(workerName + '-' + qpSub)) return true;
                    }
                    return false;
                  });
                  // NO || ledgers[0] fallback — error out instead of guessing
                }

                if (!matchedLedger) {
                  throw new Error('No synced database found. Please wait for sync to complete.');
                }

                var rInvite = await api.inviteUser({
                  ticket: {
                    query: { byEmail: email },
                    invitedParams: {
                      ledger: {
                        id: matchedLedger.ledgerId,
                        role: 'member',
                        right: detail.right || 'write'
                      }
                    }
                  }
                });
                if (rInvite.isErr()) throw rInvite.Err();

                var inviteData = rInvite.Ok();
                console.debug('[vibes-sharing] inviteUser response:', inviteData);

                // Extract invite ticket ID for auto-redemption
                var inviteId = inviteData.inviteId || (inviteData.ticket && inviteData.ticket.id) || '';

                // Construct invite URL pointing to this subdomain, including ledger ID for sync
                var ledgerId = matchedLedger.ledgerId;
                var inviteParam = inviteId ? '&invite=' + encodeURIComponent(inviteId) : '';
                var inviteUrl = qpSub
                  ? window.location.origin + '?subdomain=' + encodeURIComponent(qpSub) + '&ledger=' + encodeURIComponent(ledgerId) + inviteParam
                  : window.location.origin + '?ledger=' + encodeURIComponent(ledgerId) + inviteParam;

                // Dual-write to KV registry (awaited, non-fatal)
                try {
                  var kvRegistryUrl = window.__VIBES_REGISTRY_URL__;
                  if (kvRegistryUrl && !kvRegistryUrl.startsWith('__')) {
                    var token = await window.Clerk?.session?.getToken();
                    if (token) {
                      var hostname = window.location.hostname;
                      var parts = hostname.split('.');
                      var kvSubdomain = qpSub || (parts.length > 2 ? parts[0] : hostname);
                      var kvRes = await fetch(kvRegistryUrl.replace(/\/$/, '') + '/invite', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                        body: JSON.stringify({ subdomain: kvSubdomain, email: email, right: detail.right || 'write', ledgerId: matchedLedger.ledgerId, inviteId: inviteId || '' })
                      });
                      if (!kvRes.ok) {
                        var kvBody = await kvRes.text();
                        console.error('[vibes-sharing] KV invite failed:', kvRes.status, kvRes.statusText, '| body:', kvBody, '| subdomain:', kvSubdomain, '| email:', email);
                      } else {
                        console.log('[vibes-sharing] KV invite written successfully for', email, 'on', kvSubdomain);
                      }
                    } else {
                      console.warn('[vibes-sharing] KV invite skipped: no Clerk session token available');
                    }
                  }
                } catch (kvErr) {
                  console.error('[vibes-sharing] KV dual-write error:', kvErr, '| email:', email);
                }

                document.dispatchEvent(new CustomEvent('vibes-share-success', {
                  detail: {
                    email: email,
                    message: 'Invited ' + email + '!',
                    link: inviteUrl
                  }
                }));
              } catch (err) {
                document.dispatchEvent(new CustomEvent('vibes-share-error', {
                  detail: { error: { message: err.message || 'Failed to send invitation.' } }
                }));
              }
            })();
          }

          document.addEventListener('vibes-share-request', handleShareRequest);
          return function() {
            document.removeEventListener('vibes-share-request', handleShareRequest);
          };
        }, []);

        return null;
      }
      window.SharingBridge = SharingBridge;

      // === VibesPanel Event Handler Hook ===
      function useVibesPanelEvents(logPrefix) {
        React.useEffect(() => {
          const handleLogout = () => {
            if (window.Clerk) window.Clerk.signOut();
          };
          const handleSyncDisable = () => {
            console.log('[' + logPrefix + '] Sync disabled');
          };

          document.addEventListener('vibes-logout-request', handleLogout);
          document.addEventListener('vibes-sync-disable', handleSyncDisable);
          return () => {
            document.removeEventListener('vibes-logout-request', handleLogout);
            document.removeEventListener('vibes-sync-disable', handleSyncDisable);
          };
        }, []);
      }
      window.useVibesPanelEvents = useVibesPanelEvents;

      // === Theme Switching ===
      // Listens for vibes-design-request events from VibesPanel theme buttons.
      // Overrides --comp-* CSS variables on :root to retheme all components.
      var VIBES_THEME_PRESETS = {
        default: {
          '--comp-bg': 'var(--vibes-cream)',
          '--comp-text': 'var(--vibes-near-black)',
          '--comp-border': 'var(--vibes-near-black)',
          '--comp-accent': 'var(--vibes-variant-blue)',
          '--comp-accent-text': 'var(--vibes-white)',
          '--comp-muted': 'var(--vibes-gray-mid)',
          '--color-background': '#1a1a1a',
          '--grid-color': 'rgba(255, 255, 240, 0.08)',
        },
        archive: {
          '--comp-bg': 'oklch(0.95 0.03 80)',
          '--comp-text': 'oklch(0.20 0.02 50)',
          '--comp-border': 'oklch(0.35 0.04 60)',
          '--comp-accent': 'oklch(0.55 0.12 50)',
          '--comp-accent-text': 'oklch(0.97 0.01 90)',
          '--comp-muted': 'oklch(0.50 0.03 60)',
          '--color-background': 'oklch(0.92 0.03 80)',
          '--grid-color': 'oklch(0.35 0.04 60 / 0.06)',
        },
        industrial: {
          '--comp-bg': 'oklch(0.88 0.01 90)',
          '--comp-text': 'oklch(0.05 0.01 0)',
          '--comp-border': 'oklch(0.05 0.01 0)',
          '--comp-accent': 'oklch(0.90 0.20 110)',
          '--comp-accent-text': 'oklch(0.05 0.01 0)',
          '--comp-muted': 'oklch(0.40 0.01 0)',
          '--color-background': 'oklch(0.85 0.01 90)',
          '--grid-color': 'oklch(0.05 0.01 0 / 0.05)',
        }
      };

      function applyVibesTheme(themeId) {
        var preset = VIBES_THEME_PRESETS[themeId];
        if (!preset) return;
        var root = document.documentElement;
        Object.keys(preset).forEach(function(key) {
          root.style.setProperty(key, preset[key]);
        });
        try { localStorage.setItem('vibes-theme', themeId); } catch(e) {}
      }

      // Apply saved theme on load
      try {
        var savedTheme = localStorage.getItem('vibes-theme');
        if (savedTheme && VIBES_THEME_PRESETS[savedTheme]) {
          applyVibesTheme(savedTheme);
        }
      } catch(e) {}

      // Listen for theme change events from VibesPanel
      document.addEventListener('vibes-design-request', function(e) {
        var themeId = e.detail && e.detail.theme;
        if (themeId) applyVibesTheme(themeId);
      });

      // Also expose for apps that want to set themes programmatically
      window.__VIBES_THEME_PRESETS__ = VIBES_THEME_PRESETS;
      window.applyVibesTheme = applyVibesTheme;
    </script>
    <!-- === DELTA_PLACEHOLDER === -->
  </body>
</html>
