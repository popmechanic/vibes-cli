<script type="text/babel" data-type="module">
      import React, { createContext, useContext, useState, useEffect, useRef, useCallback, useMemo } from "react";
      import ReactDOMClient from "react-dom/client";

      // === Menu Components from window (defined in module script above) ===
      const HiddenMenuWrapper = window.HiddenMenuWrapper;
      const VibesPanel = window.VibesPanel;
      // Shared error components from base template
      const ConfigError = window.ConfigError;
      const LoadingError = window.LoadingError;
      // AuthScreen and VibesButton for styled auth views
      const AuthScreen = window.AuthScreen;
      const VibesButton = window.VibesButton;
      const RED = window.RED;
      const YELLOW = window.YELLOW;

      // === Configuration ===
      const CONFIG = {
        clerkPublishableKey: "__CLERK_PUBLISHABLE_KEY__",
        appName: "__APP_NAME__",
        appTitle: "__APP_TITLE__",
        domain: "__APP_DOMAIN__",
        billingMode: "__BILLING_MODE__",
        features: __FEATURES__,
        tagline: "__APP_TAGLINE__",
        subtitle: "__APP_SUBTITLE__",
        adminUserIds: __ADMIN_USER_IDS__,
        reservedSubdomains: __RESERVED_SUBDOMAINS__
      };

      // Convenience aliases
      const CLERK_PUBLISHABLE_KEY = CONFIG.clerkPublishableKey;
      const APP_NAME = CONFIG.appName;
      const APP_DOMAIN = CONFIG.domain;
      const BILLING_MODE = CONFIG.billingMode;
      const FEATURES = CONFIG.features;
      const APP_TAGLINE = CONFIG.tagline;
      const APP_SUBTITLE = CONFIG.subtitle;
      const ADMIN_USER_IDS = CONFIG.adminUserIds;
      const RESERVED_SUBDOMAINS = CONFIG.reservedSubdomains;

      // Also use window config for Clerk (same pattern as vibes)
      const vibesConfig = window.__VIBES_CONFIG__ || {};

      // === Registry API Helpers ===
      const registryCache = { data: null, fetchedAt: 0 };
      const REGISTRY_CACHE_TTL = 5000;
      let registryServerAvailable = null;

      async function fetchRegistry() {
        const now = Date.now();
        if (registryCache.data && (now - registryCache.fetchedAt) < REGISTRY_CACHE_TTL) {
          return registryCache.data;
        }
        try {
          const res = await fetch('/registry.json');
          if (!res.ok) throw new Error('Failed to fetch registry');
          registryCache.data = await res.json();
          registryCache.fetchedAt = now;
          registryServerAvailable = true;
          return registryCache.data;
        } catch (e) {
          console.warn('Registry fetch failed, using empty defaults:', e);
          registryServerAvailable = false;
          return { claims: {}, reserved: RESERVED_SUBDOMAINS, preallocated: {} };
        }
      }

      function isRegistryAvailable() {
        return registryServerAvailable === true;
      }

      async function checkSubdomainAvailability(subdomain) {
        if (!subdomain || subdomain.length < 3) {
          return { available: false, reason: 'too_short' };
        }
        const normalized = subdomain.toLowerCase().trim();
        if (RESERVED_SUBDOMAINS.includes(normalized)) {
          return { available: false, reason: 'reserved' };
        }
        try {
          const res = await fetch(`/check/${normalized}`);
          if (!res.ok) throw new Error('Check failed');
          return await res.json();
        } catch (e) {
          const registry = await fetchRegistry();
          if (registry.reserved?.includes(normalized)) {
            return { available: false, reason: 'reserved' };
          }
          if (normalized in (registry.preallocated || {})) {
            return { available: false, reason: 'preallocated', ownerId: registry.preallocated[normalized] };
          }
          if (normalized in (registry.claims || {})) {
            return { available: false, reason: 'claimed', ownerId: registry.claims[normalized].userId };
          }
          return { available: true };
        }
      }

      async function claimSubdomain(subdomain, token) {
        if (registryServerAvailable === false) {
          return {
            success: false,
            error: 'Subdomain claiming is not available. The app can be used directly via URL.',
            status: 503
          };
        }
        try {
          const res = await fetch('/claim', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ subdomain: subdomain.toLowerCase().trim() })
          });
          const data = await res.json();
          return { ...data, status: res.status };
        } catch (e) {
          return {
            success: false,
            error: 'Subdomain claiming is not available.',
            status: 503
          };
        }
      }

      async function getSubdomainOwner(subdomain) {
        const registry = await fetchRegistry();
        const normalized = subdomain.toLowerCase().trim();
        return registry.claims?.[normalized]?.userId || registry.preallocated?.[normalized] || null;
      }

      // === Route Detection ===
      function getRouteInfo() {
        const hostname = window.location.hostname;
        const params = new URLSearchParams(window.location.search);
        const testSubdomain = params.get('subdomain');

        // Handle localhost for testing
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
          if (testSubdomain === 'admin') return { route: 'admin', subdomain: null };
          if (testSubdomain) return { route: 'tenant', subdomain: testSubdomain };
          return { route: 'landing', subdomain: null };
        }

        // Handle workers.dev (use ?subdomain= param, no wildcard SSL)
        if (hostname.endsWith('.workers.dev')) {
          if (testSubdomain === 'admin') return { route: 'admin', subdomain: null };
          if (testSubdomain) return { route: 'tenant', subdomain: testSubdomain };
          return { route: 'landing', subdomain: null };
        }

        // Production: detect subdomain from hostname using APP_DOMAIN
        if (hostname === APP_DOMAIN || hostname === `www.${APP_DOMAIN}`) {
          return { route: 'landing', subdomain: null };
        }
        if (hostname === `admin.${APP_DOMAIN}`) {
          return { route: 'admin', subdomain: null };
        }
        if (hostname.endsWith(`.${APP_DOMAIN}`)) {
          const subdomain = hostname.slice(0, -(APP_DOMAIN.length + 1));
          return { route: 'tenant', subdomain };
        }

        // Fallback for unrecognized domains (direct worker URL, etc.)
        if (testSubdomain === 'admin') return { route: 'admin', subdomain: null };
        if (testSubdomain) return { route: 'tenant', subdomain: testSubdomain };
        return { route: 'landing', subdomain: null };
      }

      function needsQueryParamRouting() {
        const hostname = window.location.hostname;
        return hostname === 'localhost'
          || hostname === '127.0.0.1'
          || hostname.endsWith('.workers.dev');
      }

      const routeInfo = getRouteInfo();

      // === Tenant Context ===
      const TenantContext = createContext(null);

      function useTenant() {
        const context = useContext(TenantContext);
        if (!context) throw new Error("useTenant must be used within TenantProvider");
        return context;
      }
      window.useTenant = useTenant;

      function TenantProvider({ children, subdomain }) {
        const dbName = `${APP_NAME}-${subdomain}`;
        return (
          <TenantContext.Provider value={{ subdomain, dbName, appName: APP_NAME, domain: APP_DOMAIN }}>
            {children}
          </TenantContext.Provider>
        );
      }

      // === Subdomain Checker Hook ===
      function useSubdomainChecker(subdomain) {
        const [state, setState] = useState({ available: false, checking: false, error: null });

        useEffect(() => {
          if (!subdomain || subdomain.length < 3) {
            setState({ available: false, checking: false, error: null });
            return;
          }

          setState(prev => ({ ...prev, checking: true, error: null }));
          const timer = setTimeout(async () => {
            try {
              const result = await checkSubdomainAvailability(subdomain);
              setState({ available: result.available, checking: false, error: null });
            } catch (e) {
              setState({ available: false, checking: false, error: 'Check failed' });
            }
          }, 300);

          return () => clearTimeout(timer);
        }, [subdomain]);

        return state;
      }

      // __VIBES_APP_CODE__

      // === Auth Gate (for signed-out users) ===
      function AuthGate({ onSignUp }) {
        const { SignInButton, SignUpButton } = window.ClerkComponents || {};
        const appDisplayName = APP_NAME.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

        // Guard against undefined components
        if (!SignInButton || !SignUpButton) {
          return <LoadingError error="Clerk auth buttons not loaded. Please refresh." />;
        }

        return (
          <AuthScreen
            title={`Welcome to ${appDisplayName}`}
            message="Sign in to access your space."
            showCard={true}
          >
            <SignInButton mode="modal">
              <VibesButton variant={RED} buttonType="form">
                Sign In
              </VibesButton>
            </SignInButton>
            <SignUpButton mode="modal">
              <VibesButton variant={YELLOW} buttonType="form">
                Create Account
              </VibesButton>
            </SignUpButton>
          </AuthScreen>
        );
      }

      // === Claim Prompt (for signed-in users on unclaimed subdomains) ===
      function ClaimPrompt({ subdomain, onClaim, onCancel, postPayment }) {
        const [claiming, setClaiming] = useState(false);
        const [isShredding, setIsShredding] = useState(false);
        const [error, setError] = useState(null);
        const [quotaExceeded, setQuotaExceeded] = useState(false);
        const [retryStatus, setRetryStatus] = useState(null); // null | 'retrying'

        const handleClaim = async () => {
          setClaiming(true);
          setError(null);
          setQuotaExceeded(false);
          setRetryStatus(null);
          try {
            const token = await window.Clerk?.session?.getToken();
            if (!token) throw new Error('Not authenticated');
            const result = await claimSubdomain(subdomain, token);
            if (result.success) {
              setIsShredding(true);
              setTimeout(() => { onClaim?.(); }, 1200);
              return;
            }
            if (result.status === 402) {
              // Post-payment: retry with delays for webhook propagation
              if (postPayment) {
                setRetryStatus('retrying');
                for (let i = 0; i < 4; i++) {
                  await new Promise(r => setTimeout(r, 3000));
                  try {
                    const freshToken = await window.Clerk?.session?.getToken({ skipCache: true });
                    if (!freshToken) continue;
                    const retryResult = await claimSubdomain(subdomain, freshToken);
                    if (retryResult.success) {
                      setRetryStatus(null);
                      setIsShredding(true);
                      setTimeout(() => { onClaim?.(); }, 1200);
                      return;
                    }
                    if (retryResult.status !== 402) {
                      setRetryStatus(null);
                      setError(retryResult.error || 'Failed to claim subdomain');
                      return;
                    }
                  } catch (_) { /* continue retrying */ }
                }
                setRetryStatus(null);
                setQuotaExceeded(true);
                return;
              }
              // Non-post-payment: existing single fresh-token retry for stale pla
              const parts = token.split('.');
              const payload = JSON.parse(atob(parts[1]));
              if (!payload.pla) {
                try {
                  const freshToken = await window.Clerk?.session?.getToken({ skipCache: true });
                  if (freshToken) {
                    const retryResult = await claimSubdomain(subdomain, freshToken);
                    if (retryResult.success) {
                      setIsShredding(true);
                      setTimeout(() => { onClaim?.(); }, 1200);
                      return;
                    }
                  }
                } catch (_) { /* fall through to upgrade prompt */ }
              }
              setQuotaExceeded(true);
            } else {
              setError(result.error || 'Failed to claim subdomain');
            }
          } catch (e) {
            setError(e.message);
          } finally {
            setClaiming(false);
          }
        };

        if (quotaExceeded) {
          return <UpgradePrompt redirectUrl={window.location.href} />;
        }

        return (
          <AuthScreen
            title={`Claim ${subdomain}.${needsQueryParamRouting() ? APP_NAME : APP_DOMAIN}`}
            message={retryStatus === 'retrying' ? 'Processing your payment... this may take a moment.' : error || "This subdomain is available! Would you like to claim it?"}
            showCard={true}
            isShredding={isShredding}
            isError={!!error}
          >
            <div onClick={handleClaim}>
              <VibesButton variant={RED} buttonType="form" disabled={claiming}>
                {retryStatus === 'retrying' ? 'Processing payment...' : claiming ? 'Claiming...' : 'Claim This Subdomain'}
              </VibesButton>
            </div>
            {onCancel && retryStatus !== 'retrying' && (
              <div onClick={onCancel} style={{ cursor: 'pointer', textAlign: 'center', color: '#666', fontSize: '0.875rem' }}>
                Cancel
              </div>
            )}
          </AuthScreen>
        );
      }

      // === Subscription Paywall (shown when user needs to subscribe) ===
      function SubscriptionPaywall({ redirectUrl }) {
        const { PricingTable } = window.ClerkComponents || {};

        // Persist subdomain for post-payment redirect recovery
        useEffect(() => {
          if (routeInfo.subdomain) {
            sessionStorage.setItem('vibes_pending_subdomain', routeInfo.subdomain);
          }
        }, []);

        if (PricingTable) {
          return (
            <div style={{
              minHeight: '100vh',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              padding: '2rem',
              background: '#ECECEC',
              fontFamily: "'Space Grotesk', 'Inter', sans-serif",
            }}>
              <h2 style={{
                fontSize: 'clamp(1.5rem, 4vw, 2.5rem)',
                fontWeight: 700,
                letterSpacing: '-0.04em',
                marginBottom: '0.5rem',
                textAlign: 'center',
              }}>Subscribe to Continue</h2>
              <p style={{
                color: '#666',
                marginBottom: '2rem',
                textAlign: 'center',
                fontSize: '1.1rem',
              }}>Choose a plan to get started.</p>
              <div style={{ width: '100%', maxWidth: '600px' }}>
                <PricingTable
                  newSubscriptionRedirectUrl={redirectUrl || window.location.href}
                />
              </div>
            </div>
          );
        }

        // Fallback when PricingTable is not available
        return (
          <AuthScreen
            title="Subscription Required"
            message="A subscription is required to use this app."
            showCard={true}
          >
            <a
              href={`https://accounts.clerk.dev/user/billing`}
              target="_blank"
              rel="noopener noreferrer"
              style={{ textDecoration: 'none' }}
            >
              <VibesButton variant={RED} buttonType="form">
                Manage Subscription
              </VibesButton>
            </a>
          </AuthScreen>
        );
      }

      // === Existing Subdomain Redirect (shown when quota full but user has a space) ===
      function ExistingSubdomainRedirect({ userSubdomains }) {
        const [showPricing, setShowPricing] = useState(false);
        const ownedSub = userSubdomains[0];
        const targetUrl = needsQueryParamRouting()
          ? `${window.location.origin}?subdomain=${ownedSub}`
          : `https://${ownedSub}.${APP_DOMAIN}`;

        if (showPricing) {
          return <UpgradePrompt redirectUrl={window.location.href} />;
        }

        return (
          <AuthScreen
            title="You Already Have a Space"
            message={`Your subdomain is ${ownedSub}.${needsQueryParamRouting() ? APP_NAME : APP_DOMAIN} — purchase another subscription to claim more.`}
            showCard={true}
          >
            <a href={targetUrl} style={{ textDecoration: 'none' }}>
              <VibesButton variant={RED} buttonType="form">
                Go to My App
              </VibesButton>
            </a>
            <div onClick={() => setShowPricing(true)} style={{ cursor: 'pointer' }}>
              <VibesButton variant={YELLOW} buttonType="form">
                Claim This Domain
              </VibesButton>
            </div>
          </AuthScreen>
        );
      }

      // === Upgrade Prompt (shown when claim returns 402 — quota exceeded) ===
      function UpgradePrompt({ redirectUrl }) {
        const { PricingTable } = window.ClerkComponents || {};

        // Persist subdomain for post-payment redirect recovery
        useEffect(() => {
          if (routeInfo.subdomain) {
            sessionStorage.setItem('vibes_pending_subdomain', routeInfo.subdomain);
          }
        }, []);

        if (PricingTable) {
          return (
            <div style={{
              minHeight: '100vh',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center',
              alignItems: 'center',
              padding: '2rem',
              background: '#ECECEC',
              fontFamily: "'Space Grotesk', 'Inter', sans-serif",
            }}>
              <h2 style={{
                fontSize: 'clamp(1.5rem, 4vw, 2.5rem)',
                fontWeight: 700,
                letterSpacing: '-0.04em',
                marginBottom: '0.5rem',
                textAlign: 'center',
              }}>Upgrade Your Plan</h2>
              <p style={{
                color: '#666',
                marginBottom: '2rem',
                textAlign: 'center',
                fontSize: '1.1rem',
              }}>You've reached your subdomain limit. Upgrade to claim more.</p>
              <div style={{ width: '100%', maxWidth: '600px' }}>
                <PricingTable
                  newSubscriptionRedirectUrl={redirectUrl || window.location.href}
                />
              </div>
            </div>
          );
        }

        return (
          <AuthScreen
            title="Upgrade Your Plan"
            message="You've reached your subdomain limit. Upgrade your plan to claim more."
            showCard={true}
          >
            <a
              href={`https://accounts.clerk.dev/user/billing`}
              target="_blank"
              rel="noopener noreferrer"
              style={{ textDecoration: 'none' }}
            >
              <VibesButton variant={RED} buttonType="form">
                Upgrade Plan
              </VibesButton>
            </a>
          </AuthScreen>
        );
      }

      // === Subscription Gate (wraps tenant content, checks billing) ===
      function SubscriptionGate({ children }) {
        const [registryAllowed, setRegistryAllowed] = useState(null); // null=loading, true/false
        const { sessionClaims, isLoaded } = window.useAuth();
        const { user } = window.useUser();

        // Registry fallback (runs once per user)
        useEffect(() => {
          if (BILLING_MODE !== 'required' || !user?.id) return;
          if (ADMIN_USER_IDS.includes(user.id)) return;
          // Skip registry if JWT already has plan claim
          if (sessionClaims?.pla) return;
          fetchRegistry().then(registry => {
            const userQuota = (registry.quotas || {})[user.id];
            setRegistryAllowed(userQuota !== undefined && userQuota > 0);
          }).catch(() => setRegistryAllowed(false)); // fail closed — show paywall on error
        }, [user?.id, sessionClaims?.pla]);

        // Fast-pass checks (no loading state needed)
        if (BILLING_MODE !== 'required') return children;
        if (!isLoaded) {
          return (
            <div className="min-h-screen flex items-center justify-center">
              <div className="text-gray-500">Checking subscription...</div>
            </div>
          );
        }
        if (user?.id && ADMIN_USER_IDS.includes(user.id)) return children;

        // Primary: JWT pla claim (instant, no API call)
        if (sessionClaims?.pla) return children;

        // Fallback: Registry quota
        if (registryAllowed === true) return children;
        if (registryAllowed === false) return <SubscriptionPaywall redirectUrl={window.location.href} />;

        // Still loading registry — show spinner
        return (
          <div className="min-h-screen flex items-center justify-center">
            <div className="text-gray-500">Checking subscription...</div>
          </div>
        );
      }

      // === Not Owner Redirect ===
      function NotOwnerRedirect({ subdomain }) {
        return (
          <AuthScreen
            title="Access Denied"
            message={`${subdomain}.${needsQueryParamRouting() ? APP_NAME : APP_DOMAIN} belongs to another user.`}
            showCard={true}
            isError={true}
          >
            <a href={needsQueryParamRouting() ? window.location.origin : `https://${APP_DOMAIN}`} style={{ textDecoration: 'none' }}>
              <VibesButton variant={YELLOW} buttonType="form">
                Get Your Own
              </VibesButton>
            </a>
          </AuthScreen>
        );
      }

      // === Wrapper Components (use useUser hook instead of render props) ===
      // Clerk's SignedIn doesn't support render props - must use hooks inside child components

      function ClaimPromptWrapper({ subdomain, onClaimSuccess }) {
        const { user } = window.useUser();
        const { sessionClaims } = window.useAuth();
        const [quotaCheck, setQuotaCheck] = useState({ loading: true, exceeded: false, userSubdomains: [] });

        // If returning from payment flow, skip client-side quota check — let server decide
        const pendingSub = sessionStorage.getItem('vibes_pending_subdomain');
        const skipQuotaCheck = pendingSub === subdomain;

        useEffect(() => {
          if (skipQuotaCheck) {
            sessionStorage.removeItem('vibes_pending_subdomain');
            setQuotaCheck({ loading: false, exceeded: false, userSubdomains: [] });
            return;
          }
          if (!user?.id) return;
          fetchRegistry().then(registry => {
            const userClaimEntries = Object.entries(registry.claims || {}).filter(([, c]) => c.userId === user.id);
            const userSubdomains = userClaimEntries.map(([sub]) => sub);
            const webhookQuota = registry.quotas?.[user.id];
            const jwtQuota = (BILLING_MODE === 'required') ? (sessionClaims?.pla ? 1 : 0) : 999;
            const quota = webhookQuota ?? jwtQuota;
            setQuotaCheck({ loading: false, exceeded: userSubdomains.length >= quota, userSubdomains });
          }).catch(() => setQuotaCheck({ loading: false, exceeded: false, userSubdomains: [] }));
        }, [user?.id]);

        if (quotaCheck.loading) {
          return (
            <div className="min-h-screen flex items-center justify-center">
              <div className="text-gray-500">Checking availability...</div>
            </div>
          );
        }
        if (quotaCheck.exceeded) {
          // If user has existing subdomains, redirect them there instead of dead-end PricingTable
          if (quotaCheck.userSubdomains.length > 0) {
            return <ExistingSubdomainRedirect userSubdomains={quotaCheck.userSubdomains} />;
          }
          // No subdomains but quota full (edge case) — show upgrade prompt
          return <UpgradePrompt redirectUrl={window.location.href} />;
        }
        return (
          <ClaimPrompt
            subdomain={subdomain}
            onClaim={() => onClaimSuccess(user?.id)}
            postPayment={skipQuotaCheck}
          />
        );
      }

      function TenantOwnerCheck({ subdomain, ownerId }) {
        const { user } = window.useUser();

        if (user?.id === ownerId) {
          // Owner - show app with admin panel
          return (
            <TenantProvider subdomain={subdomain}>
              <HiddenMenuWrapper menuContent={<VibesPanel />}>
                <App />
              </HiddenMenuWrapper>
            </TenantProvider>
          );
        }
        // Not owner
        return <NotOwnerRedirect subdomain={subdomain} />;
      }

      // === Tenant App Wrapper ===
      function TenantApp({ subdomain }) {
        const [claimState, setClaimState] = useState({ loading: true, owner: null });
        const { SignedIn, SignedOut } = window.ClerkComponents || {};

        // Hook must be called unconditionally at top of component (Rules of Hooks)
        window.useVibesPanelEvents('Sell');

        useEffect(() => {
          getSubdomainOwner(subdomain).then(owner => {
            setClaimState({ loading: false, owner });
          });
        }, [subdomain]);

        // Guard against undefined Clerk components (after all hooks)
        if (!SignedIn || !SignedOut) {
          return <LoadingError error="Clerk components not loaded. Please refresh the page." />;
        }

        if (claimState.loading) {
          return (
            <div className="min-h-screen flex items-center justify-center">
              <div className="text-gray-500">Loading...</div>
            </div>
          );
        }

        const onClaimSuccess = (userId) => {
          setClaimState({ loading: false, owner: userId });
        };

        // Subdomain is unclaimed
        if (!claimState.owner) {
          return (
            <>
              <SignedIn>
                <SubscriptionGate>
                  <ClaimPromptWrapper subdomain={subdomain} onClaimSuccess={onClaimSuccess} />
                </SubscriptionGate>
              </SignedIn>
              <SignedOut>
                <AuthGate />
              </SignedOut>
            </>
          );
        }

        // Subdomain is claimed - check if user is owner
        return (
          <>
            <SignedIn>
              <SubscriptionGate>
                <TenantOwnerCheck subdomain={subdomain} ownerId={claimState.owner} />
              </SubscriptionGate>
            </SignedIn>
            <SignedOut>
              <AuthGate />
            </SignedOut>
          </>
        );
      }

      // === Admin Dashboard Content (uses useUser hook) ===
      function AdminDashboardContent() {
        const { user } = window.useUser();
        const { UserButton } = window.ClerkComponents;
        const [registry, setRegistry] = useState(null);
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);

        useEffect(() => {
          fetchRegistry()
            .then(data => { setRegistry(data); setLoading(false); })
            .catch(e => { setError(e.message); setLoading(false); });
        }, []);

        if (!ADMIN_USER_IDS.includes(user?.id)) {
          return (
            <div className="min-h-screen flex items-center justify-center bg-gray-50">
              <div className="text-center p-8">
                <h1 className="text-2xl font-bold mb-4">Admin Access Required</h1>
                <p className="text-gray-600">You don't have admin privileges.</p>
              </div>
            </div>
          );
        }

        const claims = registry?.claims || {};
        const quotas = registry?.quotas || {};
        const claimEntries = Object.entries(claims);
        const uniqueUsers = new Set(claimEntries.map(([, c]) => c.userId));
        const subscribedUsers = Object.keys(quotas).length;

        return (
          <div style={{ minHeight: '100vh', background: 'var(--admin-bg)', padding: '2rem', fontFamily: "'Inter', sans-serif" }}>
            <div style={{ maxWidth: '960px', margin: '0 auto' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                <h1 style={{ fontSize: '1.75rem', fontWeight: 700, color: 'var(--admin-text)', letterSpacing: '-0.02em' }}>Admin Dashboard</h1>
                <UserButton />
              </div>

              {loading ? (
                <div style={{ textAlign: 'center', padding: '3rem', color: 'var(--admin-text-muted)' }}>Loading registry data...</div>
              ) : error ? (
                <div style={{ textAlign: 'center', padding: '3rem', color: '#ef4444' }}>Failed to load registry: {error}</div>
              ) : (
                <>
                  {/* Stats cards */}
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
                    {[
                      { label: 'Claimed Subdomains', value: claimEntries.length },
                      { label: 'Unique Users', value: uniqueUsers.size },
                      { label: 'Subscribed Users', value: subscribedUsers },
                      { label: 'Billing Mode', value: BILLING_MODE || 'none' }
                    ].map((stat, i) => (
                      <div key={i} style={{
                        background: 'var(--admin-card-bg)',
                        borderRadius: '12px',
                        padding: '1.25rem',
                        border: '2px solid var(--admin-border)',
                        boxShadow: '4px 4px 0 var(--admin-shadow)'
                      }}>
                        <div style={{ fontSize: '0.75rem', textTransform: 'uppercase', letterSpacing: '0.05em', color: 'var(--admin-text-muted)', marginBottom: '0.5rem' }}>{stat.label}</div>
                        <div style={{ fontSize: '1.5rem', fontWeight: 700, color: 'var(--admin-text)' }}>{stat.value}</div>
                      </div>
                    ))}
                  </div>

                  {/* Claims table */}
                  <div style={{
                    background: 'var(--admin-card-bg)',
                    borderRadius: '12px',
                    border: '2px solid var(--admin-border)',
                    boxShadow: '4px 4px 0 var(--admin-shadow)',
                    overflow: 'hidden',
                    marginBottom: '2rem'
                  }}>
                    <div style={{ padding: '1rem 1.25rem', borderBottom: '1px solid rgba(0,0,0,0.08)' }}>
                      <h2 style={{ fontSize: '1rem', fontWeight: 600, color: 'var(--admin-text)' }}>Claimed Subdomains</h2>
                    </div>
                    {claimEntries.length === 0 ? (
                      <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--admin-text-muted)' }}>No subdomains claimed yet.</div>
                    ) : (
                      <div style={{ overflowX: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.875rem' }}>
                          <thead>
                            <tr style={{ borderBottom: '1px solid rgba(0,0,0,0.08)' }}>
                              <th style={{ textAlign: 'left', padding: '0.75rem 1.25rem', fontWeight: 600, color: 'var(--admin-text-muted)', fontSize: '0.75rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Subdomain</th>
                              <th style={{ textAlign: 'left', padding: '0.75rem 1.25rem', fontWeight: 600, color: 'var(--admin-text-muted)', fontSize: '0.75rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>User ID</th>
                              <th style={{ textAlign: 'left', padding: '0.75rem 1.25rem', fontWeight: 600, color: 'var(--admin-text-muted)', fontSize: '0.75rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Claimed</th>
                              <th style={{ textAlign: 'left', padding: '0.75rem 1.25rem', fontWeight: 600, color: 'var(--admin-text-muted)', fontSize: '0.75rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Quota</th>
                            </tr>
                          </thead>
                          <tbody>
                            {claimEntries.map(([sub, claim]) => (
                              <tr key={sub} style={{ borderBottom: '1px solid rgba(0,0,0,0.04)' }}>
                                <td style={{ padding: '0.75rem 1.25rem', fontWeight: 500, color: 'var(--admin-text)' }}>
                                  {sub}.{APP_DOMAIN}
                                </td>
                                <td style={{ padding: '0.75rem 1.25rem', color: 'var(--admin-text-muted)', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                                  {claim.userId}
                                </td>
                                <td style={{ padding: '0.75rem 1.25rem', color: 'var(--admin-text-muted)' }}>
                                  {claim.claimedAt ? new Date(claim.claimedAt).toLocaleDateString() : '—'}
                                </td>
                                <td style={{ padding: '0.75rem 1.25rem', color: 'var(--admin-text-muted)' }}>
                                  {quotas[claim.userId] !== undefined ? quotas[claim.userId] : '—'}
                                </td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    )}
                  </div>

                  {/* Links */}
                  <div style={{ textAlign: 'center' }}>
                    <a
                      href="https://dashboard.clerk.com"
                      target="_blank"
                      rel="noopener noreferrer"
                      style={{ color: 'var(--admin-text-muted)', fontSize: '0.875rem', textDecoration: 'underline' }}
                    >
                      Open Clerk Dashboard
                    </a>
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      // === Admin Dashboard (placeholder) ===
      function AdminApp() {
        const { SignedIn, SignedOut } = window.ClerkComponents || {};

        // Guard against undefined Clerk components
        if (!SignedIn || !SignedOut) {
          return <LoadingError error="Clerk components not loaded. Please refresh the page." />;
        }

        return (
          <>
            <SignedIn>
              <AdminDashboardContent />
            </SignedIn>
            <SignedOut>
              <AuthGate />
            </SignedOut>
          </>
        );
      }

      // === Landing Page Styles (from design reference) ===
      const landingPageStyles = `
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=Space+Grotesk:wght@300;500;700&display=swap');

        :root {
            --bg-color: #ECECEC;
            --text-main: #111111;
            --accent-pants: #3B282A;
            --accent-shoe-green: #203A2E;
            --swosh-white: #FFFFFF;
            --easing: cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        html, body {
            background-color: #ECECEC;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }

        .landing-page * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        .landing-page {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            overflow-x: hidden;
            min-height: 100vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
        }

        .landing-page nav {
            position: fixed;
            top: 0;
            width: 100%;
            padding: 2rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            mix-blend-mode: difference;
            color: white;
        }

        .landing-page .logo {
            font-family: 'Space Grotesk', sans-serif;
            font-weight: 700;
            font-size: 1.2rem;
            letter-spacing: -0.04em;
            text-transform: uppercase;
        }

        .landing-page main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .landing-page .hero-container {
            z-index: 10;
            text-align: center;
            max-width: 1200px;
            width: 100%;
            padding: 6rem 2rem 0;
        }

        .landing-page h1 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: clamp(3rem, 8vw, 9rem);
            line-height: 0.85;
            font-weight: 700;
            letter-spacing: -0.06em;
            margin-bottom: 2rem;
            color: var(--text-main);
            transform: translateY(20px);
            opacity: 0;
            animation: fadeUp 1s var(--easing) forwards 0.2s;
        }

        .landing-page p.subhead {
            font-family: 'Inter', sans-serif;
            font-size: clamp(1rem, 1.5vw, 1.5rem);
            max-width: 600px;
            margin: 0 auto 4rem auto;
            color: #666;
            line-height: 1.4;
            transform: translateY(20px);
            opacity: 0;
            animation: fadeUp 1s var(--easing) forwards 0.4s;
        }

        .landing-page .claim-bar {
            display: inline-flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.9);
            border-radius: 100px;
            padding: 8px;
            box-shadow:
                0 20px 40px -10px rgba(0,0,0,0.1),
                0 0 0 1px rgba(0,0,0,0.02);
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            animation: fadeUp 1s var(--easing) forwards 0.6s;
            transition: transform 0.3s var(--easing), box-shadow 0.3s var(--easing);
            max-width: 100%;
        }

        .landing-page .claim-bar:hover {
            transform: translateY(18px) scale(1.01);
            box-shadow:
                0 30px 60px -15px rgba(0,0,0,0.15),
                0 0 0 1px rgba(0,0,0,0.02);
        }

        .landing-page .input-group {
            display: flex;
            align-items: baseline;
            padding: 0 1.5rem;
            position: relative;
        }

        .landing-page input[type="text"] {
            background: transparent;
            border: none;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            color: var(--text-main);
            outline: none;
            width: 200px;
            font-weight: 500;
            letter-spacing: -0.03em;
            padding: 1rem 0;
        }

        .landing-page input[type="text"]::placeholder {
            color: #CCC;
            font-weight: 300;
        }

        .landing-page .domain-suffix {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            color: #999;
            font-weight: 400;
            letter-spacing: -0.03em;
            pointer-events: none;
            margin-right: 1rem;
            user-select: none;
        }

        .landing-page .btn-start {
            background-color: var(--text-main);
            color: var(--swosh-white);
            border: none;
            border-radius: 50px;
            padding: 1rem 2.5rem;
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            letter-spacing: -0.01em;
            cursor: pointer;
            transition: all 0.4s var(--easing);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .landing-page .btn-start::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s ease;
        }

        .landing-page .btn-start:hover {
            background-color: var(--accent-pants);
            transform: scale(1.02);
            padding-right: 3rem;
        }

        .landing-page .btn-start:hover::before {
            left: 100%;
        }

        .landing-page .btn-start:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .landing-page .btn-start:disabled:hover {
            background-color: var(--text-main);
            transform: none;
            padding-right: 2.5rem;
        }

        .landing-page .arrow-icon {
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.4s var(--easing);
            position: absolute;
            right: 1.5rem;
        }

        .landing-page .btn-start:hover .arrow-icon {
            opacity: 1;
            transform: translateX(0);
        }

        .landing-page .btn-start:disabled:hover .arrow-icon {
            opacity: 0;
        }

        .landing-page .footer-strip {
            width: 100%;
            padding: 4rem 0 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
            opacity: 0;
            animation: fadein 2s ease forwards 1s;
        }

        .landing-page .footer-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .landing-page .footer-item a {
            color: inherit;
            text-decoration: underline;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes fadein {
            to { opacity: 1; }
        }

        .landing-page ::selection {
            background: var(--accent-pants);
            color: white;
        }

        .landing-page .status-indicator {
            margin-top: 1rem;
            font-size: 0.875rem;
            min-height: 1.5rem;
            opacity: 0;
            animation: fadeUp 1s var(--easing) forwards 0.8s;
        }

        .landing-page .status-checking { color: #999; }
        .landing-page .status-available { color: #10b981; }
        .landing-page .status-taken { color: #ef4444; }
        .landing-page .status-error { color: #ef4444; }

        .landing-page .pricing-section {
            padding: 6rem 2rem 4rem;
            text-align: center;
            max-width: 700px;
            margin: 0 auto;
            opacity: 0;
            animation: fadeUp 1s var(--easing) forwards 1s;
        }

        .landing-page .pricing-section h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: clamp(2rem, 4vw, 3rem);
            font-weight: 700;
            letter-spacing: -0.04em;
            margin-bottom: 3rem;
            color: var(--text-main);
        }

        .landing-page .features-list {
            list-style: none;
            padding: 0;
            margin: 0 auto 3rem;
            max-width: 400px;
            text-align: left;
        }

        .landing-page .features-list li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0;
            font-size: 1.1rem;
            color: var(--text-main);
            border-bottom: 1px solid rgba(0,0,0,0.06);
        }

        .landing-page .features-list li:last-child {
            border-bottom: none;
        }

        .landing-page .check-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            background: var(--text-main);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .landing-page .pricing-cta {
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            color: #666;
            margin-bottom: 0.75rem;
        }

        .landing-page .pricing-trust {
            display: flex;
            justify-content: center;
            gap: 2rem;
            font-size: 0.8rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            .landing-page h1 {
                font-size: 3.5rem;
            }
            .landing-page .claim-bar {
                flex-direction: column;
                border-radius: 20px;
                width: 100%;
                padding: 1rem;
                gap: 1rem;
            }
            .landing-page .input-group {
                width: 100%;
                justify-content: center;
                border-bottom: 1px solid #eee;
                padding-bottom: 1rem;
            }
            .landing-page .btn-start {
                width: 100%;
                justify-content: center;
            }
            .landing-page input[type="text"] {
                width: auto;
                max-width: 120px;
                text-align: right;
            }
            .landing-page .pricing-trust {
                flex-direction: column;
                gap: 0.5rem;
                align-items: center;
            }
        }
      `;

      // === Pricing Section (shown on landing page when billing is required) ===
      function PricingSection() {
        if (BILLING_MODE !== 'required' || !FEATURES || FEATURES.length === 0) return null;

        return (
          <div className="pricing-section">
            <h2>What You Get</h2>
            <ul className="features-list">
              {FEATURES.map((feature, i) => (
                <li key={i}>
                  <span className="check-icon">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round">
                      <polyline points="20 6 9 17 4 12" />
                    </svg>
                  </span>
                  {feature}
                </li>
              ))}
            </ul>
            <p className="pricing-cta">Get started — plans start after signup</p>
            <div className="pricing-trust">
              <span>Cancel anytime</span>
              <span>No credit card to try</span>
            </div>
          </div>
        );
      }

      // === Landing Page Component (design reference transformation) ===
      function SellLandingPage() {
        const [subdomain, setSubdomain] = useState('');
        const [registryStatus, setRegistryStatus] = useState('checking');
        const { available, checking, error } = useSubdomainChecker(subdomain);
        const copyrightRef = useRef(null);

        // Post-payment redirect recovery: if user was on a subdomain before
        // Clerk payment redirect, restore it and navigate back
        useEffect(() => {
          const pending = sessionStorage.getItem('vibes_pending_subdomain');
          if (pending) {
            sessionStorage.removeItem('vibes_pending_subdomain');
            const url = new URL(window.location.href);
            if (needsQueryParamRouting()) {
              url.searchParams.set('subdomain', pending);
            } else {
              url.hostname = `${pending}.${APP_DOMAIN}`;
            }
            window.location.href = url.toString();
          }
        }, []);

        // Check registry availability on mount
        useEffect(() => {
          fetchRegistry().then(() => {
            setRegistryStatus(isRegistryAvailable() ? 'available' : 'unavailable');
          });
        }, []);

        // Set copyright year
        useEffect(() => {
          if (copyrightRef.current) {
            copyrightRef.current.textContent = '© ' + new Date().getFullYear();
          }
        }, []);

        const handleGetStarted = () => {
          if (!subdomain || !available) return;
          // Navigate to subdomain
          const url = new URL(window.location.href);
          if (needsQueryParamRouting()) {
            url.searchParams.set('subdomain', subdomain);
          } else {
            url.hostname = `${subdomain}.${APP_DOMAIN}`;
          }
          window.location.href = url.toString();
        };

        const handleInputChange = (e) => {
          setSubdomain(e.target.value.toLowerCase().replace(/[^a-z0-9-]/g, ''));
        };

        const handleKeyDown = (e) => {
          if (e.key === 'Enter') {
            handleGetStarted();
          }
        };

        const getStatusIndicator = () => {
          if (!subdomain || subdomain.length < 3) return null;
          if (checking) return <span className="status-checking">Checking...</span>;
          if (error) return <span className="status-error">{error}</span>;
          if (available) return <span className="status-available">Available!</span>;
          return <span className="status-taken">Taken</span>;
        };

        // Humanize app name for display (e.g., "cosmic-garden" → "Cosmic Garden")
        const displayName = APP_NAME.replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

        const isDisabled = !subdomain || !available || checking || registryStatus === 'unavailable';

        return (
          <>
            <style>{landingPageStyles}</style>

            <div className="landing-page">
              {/* Nav - logo only */}
              <nav>
                <div className="logo">{displayName}</div>
              </nav>

              <main>
                <div className="hero-container">
                  <h1 dangerouslySetInnerHTML={{ __html: APP_TAGLINE }} />
                  <p className="subhead">{APP_SUBTITLE}</p>

                  {/* Claim bar with subdomain input */}
                  <div className="claim-bar">
                    <div className="input-group">
                      <input
                        type="text"
                        placeholder="yourname"
                        spellCheck="false"
                        autoFocus
                        value={subdomain}
                        onChange={handleInputChange}
                        onKeyDown={handleKeyDown}
                        disabled={registryStatus === 'unavailable'}
                      />
                      <span className="domain-suffix">.{needsQueryParamRouting() ? APP_NAME : APP_DOMAIN}</span>
                    </div>
                    <button
                      className="btn-start"
                      onClick={handleGetStarted}
                      disabled={isDisabled}
                    >
                      Get Started
                      <svg className="arrow-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <line x1="5" y1="12" x2="19" y2="12" />
                        <polyline points="12 5 19 12 12 19" />
                      </svg>
                    </button>
                  </div>

                  {/* Status indicator */}
                  <div className="status-indicator">
                    {registryStatus !== 'unavailable' && getStatusIndicator()}
                  </div>
                </div>
              </main>

              {/* Pricing section (only when billing is required) */}
              <PricingSection />

              {/* Footer with attribution */}
              <div className="footer-strip">
                <div className="footer-item">
                  Made with ❤️ using <a href="https://github.com/popmechanic/vibes-cli">Vibes CLI</a>
                </div>
                <div className="footer-item"><span ref={copyrightRef} /></div>
              </div>
            </div>
          </>
        );
      }

      // === Main Router ===
      function AppRouter() {
        if (routeInfo.route === 'admin') {
          return <AdminApp />;
        }
        if (routeInfo.route === 'tenant') {
          return <TenantApp subdomain={routeInfo.subdomain} />;
        }
        return <SellLandingPage />;
      }

      // === App Wrapper with Clerk ===
      function AppWrapper() {
        // Check for configuration errors
        const publishableKey = CLERK_PUBLISHABLE_KEY || vibesConfig.clerkPublishableKey;
        if (!publishableKey || publishableKey.startsWith('__')) {
          return <ConfigError message="Missing Clerk publishable key." />;
        }

        if (!window.ClerkFireproofProvider) {
          return <LoadingError error={window.__CLERK_LOAD_ERROR__ || 'Clerk components not available'} />;
        }

        const { ClerkFireproofProvider } = window.ClerkComponents;

        return (
          <>
            <SyncStatusDot />
            <ClerkFireproofProvider
              publishableKey={publishableKey}
              config={{
                apiUrl: vibesConfig.tokenApiUri,
                cloudUrl: vibesConfig.cloudBackendUrl
              }}
            >
              <AppRouter />
            </ClerkFireproofProvider>
          </>
        );
      }

      // === Initialize App ===
      async function initApp() {
        try {
          const clerkModule = await import("@fireproof/clerk");
          // SignUpButton is not exported by fireproof-clerk bundle, import from @clerk/clerk-react directly
          const clerkReact = await import("@clerk/clerk-react");
          const { SignUpButton } = clerkReact;

          window.ClerkFireproofProvider = clerkModule.ClerkFireproofProvider;
          window.ClerkComponents = {
            ClerkFireproofProvider: clerkModule.ClerkFireproofProvider,
            SignedIn: clerkModule.SignedIn,
            SignedOut: clerkModule.SignedOut,
            SignInButton: clerkModule.SignInButton,
            SignUpButton: SignUpButton,  // From @clerk/clerk-react
            UserButton: clerkModule.UserButton
          };
          window.SignedIn = clerkModule.SignedIn;
          window.SignedOut = clerkModule.SignedOut;
          window.SignInButton = clerkModule.SignInButton;
          window.SignUpButton = SignUpButton;  // From @clerk/clerk-react
          window.UserButton = clerkModule.UserButton;

          // Billing components (beta — gracefully handle missing exports)
          if (clerkReact.PricingTable) window.ClerkComponents.PricingTable = clerkReact.PricingTable;
          if (clerkReact.useAuth) window.useAuth = clerkReact.useAuth;
          if (clerkReact.Protect) window.ClerkComponents.Protect = clerkReact.Protect;

          // Export useUser hook for wrapper components that need user info
          window.useUser = clerkModule.useUser;
          window.ClerkComponents.useUser = clerkModule.useUser;

          // Export Fireproof hook for user's App code, with sync status bridge
          var _originalUseFireproofClerk = clerkModule.useFireproofClerk;
          window.useFireproofClerk = function(name, opts) {
            var result = _originalUseFireproofClerk(name, opts);
            var syncVal = result.syncStatus || 'idle';
            React.useEffect(function() {
              if (window.__VIBES_SYNC_STATUS__ !== syncVal) {
                window.__VIBES_SYNC_STATUS__ = syncVal;
                window.dispatchEvent(new CustomEvent('vibes-sync-status-change'));
              }
            }, [syncVal]);
            return result;
          };
        } catch (err) {
          console.error('Failed to load Clerk components:', err);
          window.__CLERK_LOAD_ERROR__ = err.message || String(err);
        }

        const rootElement = document.getElementById("container");
        ReactDOMClient.createRoot(rootElement).render(<AppWrapper />);
      }

      initApp();
    </script>
