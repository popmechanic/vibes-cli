<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>__TITLE__</title>
    <link rel="icon" type="image/svg+xml" href="/assets/vibes-favicon/favicon.svg" />
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/vibes-favicon/favicon-96x96.png" />
    <link rel="icon" type="image/x-icon" href="/assets/vibes-favicon/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/vibes-favicon/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/vibes-favicon/site.webmanifest" />
    <script>globalThis.process = { env: { NODE_ENV: "production" } };</script>
    <script src="https://unpkg.com/@babel/standalone@7.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      :root {
        /* Core colors */
        --vibes-black: #0f172a;
        --vibes-white: #ffffff;
        --vibes-near-black: #1a1a1a;
        --vibes-cream: #fffff0;

        /* Gray scale */
        --vibes-gray-lightest: #f1f5f9;
        --vibes-gray-ultralight: #f8fafc;
        --vibes-gray-mid: #555555;

        /* Menu colors */
        --vibes-menu-bg: #CCCDC8;
        --vibes-menu-grid: rgba(255, 255, 255, 0.5);

        /* Button variant colors */
        --vibes-variant-blue: #009ACE;
        --vibes-variant-red: #DA291C;
        --vibes-variant-yellow: #eab308;
        --vibes-variant-gray: #6b7280;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #fff;
        --vibes-button-icon-fill: #2a2a2a;

        /* Dark-aware button variants (for components using ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card colors */
        --vibes-card-bg: var(--vibes-cream);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Status colors */
        --vibes-green: #22c55e;
        --vibes-red-accent: #ef4444;
        --vibes-yellow-accent: #eab308;
        --vibes-shadow-color: rgba(0, 0, 0, 0.2);

        /* Text colors */
        --vibes-text-primary: var(--vibes-near-black);

        /* Landing page theming (customize these for brand) */
        --landing-accent: #0f172a;
        --landing-accent-hover: #1e293b;

        /* Admin dashboard theming */
        --admin-bg: oklch(0.97 0.01 250);
        --admin-card-bg: white;
        --admin-text: #0f172a;
        --admin-text-muted: #64748b;
        --admin-accent: oklch(0.6 0.2 145);
        --admin-border: #0f172a;
        --admin-shadow: #0f172a;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
        }
      }

      /* Admin menu overrides - scoped to VibesPanel in HiddenMenuWrapper */
      #hidden-menu {
        /* Gray scale needed by components */
        --vibes-gray-lighter: #cccccc;
        --vibes-gray-pale: #e5e5e5;
        --vibes-gray-dark: #333333;

        /* Variant colors (fix yellow being red) */
        --vibes-variant-blue: #3b82f6;
        --vibes-variant-red: #ef4444;
        --vibes-variant-yellow: #eab308;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #2a2a2a;
        --vibes-button-icon-fill: var(--vibes-white);

        /* Dark-aware variants (used when ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card styling */
        --vibes-card-bg: var(--vibes-gray-pale);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Text */
        --vibes-text-primary: var(--vibes-gray-dark);

        /* Shadows */
        --vibes-shadow-color: var(--vibes-near-black);
      }

      @media (prefers-color-scheme: dark) {
        #hidden-menu {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
          --vibes-card-bg: var(--vibes-near-black);
          --vibes-card-text: var(--vibes-white);
          --vibes-card-border: var(--vibes-gray-mid);
        }
      }

      /* VibesSwitch toggle button - override app-level button styling */
      button[aria-controls="hidden-menu"] {
        background: transparent !important;
        background-color: transparent !important;
        padding: 0 !important;
        border: none !important;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }

      /* Sync status indicator animations */
      @keyframes vibes-sync-pulse {
        0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
        100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/stable/react@19.2.4",
          "react/jsx-runtime": "https://esm.sh/stable/react@19.2.4/jsx-runtime",
          "react/jsx-dev-runtime": "https://esm.sh/stable/react@19.2.4/jsx-dev-runtime",
          "react-dom": "https://esm.sh/stable/react-dom@19.2.4",
          "react-dom/client": "https://esm.sh/stable/react-dom@19.2.4/client",
          "multiformats": "https://esm.sh/stable/multiformats@13.3.1",
          "multiformats/": "https://esm.sh/stable/multiformats@13.3.1/",
          "@ipld/dag-cbor": "https://esm.sh/stable/@ipld/dag-cbor@9.2.2?external=multiformats",
          "@ipld/dag-json": "https://esm.sh/stable/@ipld/dag-json@10.2.3?external=multiformats",
          "@clerk/clerk-react": "https://esm.sh/stable/@clerk/clerk-react@5.59.2?external=react,react-dom",
          "use-fireproof": "/fireproof-vibes-bridge.js",
          "@fireproof/clerk": "/fireproof-vibes-bridge.js"
        }
      }
    </script>
    <!-- Connect configuration - populated by assemble.js from .env -->
    <script>
      window.__VIBES_CONFIG__ = {
        tokenApiUri: "__VITE_API_URL__",
        cloudBackendUrl: "__VITE_CLOUD_URL__",
        clerkPublishableKey: "__VITE_CLERK_PUBLISHABLE_KEY__"
      };
    </script>
    <!-- Load React globally for menu components -->
    <script type="module">
      import * as React from "react";
      window.React = React;

      // === COMPONENTS_PLACEHOLDER ===

      // === useAI Hook ===
      // AI hook for proxied OpenRouter calls with metering
      function useAI() {
        const [loading, setLoading] = React.useState(false);
        const [error, setError] = React.useState(null);

        const callAI = React.useCallback(async (options) => {
          setLoading(true);
          setError(null);

          try {
            // Get auth token if Clerk is available (sell apps)
            let authHeader = {};
            if (typeof window !== 'undefined' && window.Clerk?.session) {
              const token = await window.Clerk.session.getToken();
              if (token) {
                authHeader = { 'Authorization': 'Bearer ' + token };
              }
            }

            const response = await fetch('/api/ai/chat', {
              method: 'POST',
              headers: Object.assign({ 'Content-Type': 'application/json' }, authHeader),
              body: JSON.stringify(Object.assign({
                model: options.model || (window.__VIBES_CONFIG__ && window.__VIBES_CONFIG__.defaultModel) || 'anthropic/claude-sonnet-4',
                messages: options.messages
              }, options))
            });

            // Handle limit exceeded (402 from OpenRouter)
            if (response.status === 402) {
              const err = { code: 'LIMIT_EXCEEDED', message: 'AI usage limit reached for this month.' };
              setError(err);
              throw err;
            }

            // Handle other errors
            if (!response.ok) {
              const errorData = await response.json().catch(function() { return {}; });
              const err = {
                code: 'API_ERROR',
                message: (errorData.error && errorData.error.message) || ('API error: ' + response.status),
                status: response.status
              };
              setError(err);
              throw err;
            }

            return await response.json();

          } catch (err) {
            setError({ code: 'NETWORK_ERROR', message: err.message || 'Network error' });
            throw err;
          } finally {
            setLoading(false);
          }
        }, []);

        return { callAI: callAI, loading: loading, error: error, clearError: function() { setError(null); } };
      }
      window.useAI = useAI;

      // === Shared Error Components ===
      function ConfigError({ message }) {
        // Use AuthScreen if available, fallback to simple div
        if (window.AuthScreen) {
          return React.createElement(window.AuthScreen, {
            title: 'Configuration Error',
            message: message,
            showCard: false,
            isError: true,
            errorDetails: 'Run Connect setup to configure Clerk credentials.'
          },
            React.createElement('p', { style: { color: '#7f1d1d', fontSize: '0.875rem' } },
              'Check your .env file for missing credentials.'
            )
          );
        }
        // Fallback for when AuthScreen hasn't loaded
        return React.createElement('div', { className: 'min-h-screen flex items-center justify-center bg-gray-50' },
          React.createElement('div', { className: 'text-center p-8 bg-white rounded-xl shadow-lg max-w-md border border-red-200' },
            React.createElement('div', { className: 'text-red-500 text-4xl mb-4' }, '⚠️'),
            React.createElement('h1', { className: 'text-xl font-bold text-red-700 mb-4' }, 'Configuration Error'),
            React.createElement('p', { className: 'text-gray-600 mb-4' }, message),
            React.createElement('p', { className: 'text-sm text-gray-500' }, 'Run Connect setup to configure Clerk credentials.')
          )
        );
      }
      window.ConfigError = ConfigError;

      function LoadingError({ error }) {
        // Use AuthScreen if available, fallback to simple div
        if (window.AuthScreen) {
          return React.createElement(window.AuthScreen, {
            title: 'Loading Failed',
            message: 'Failed to load authentication components. Check your network connection and try refreshing the page.',
            showCard: false,
            isError: true,
            errorDetails: error
          },
            React.createElement('button', {
              onClick: function() { window.location.reload(); },
              style: {
                padding: '0.75rem 1.5rem',
                backgroundColor: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: '8px',
                cursor: 'pointer',
                fontWeight: '500'
              }
            }, 'Retry')
          );
        }
        // Fallback for when AuthScreen hasn't loaded
        return React.createElement('div', { className: 'min-h-screen flex items-center justify-center bg-gray-50' },
          React.createElement('div', { className: 'text-center p-8 bg-white rounded-xl shadow-lg max-w-md border border-amber-200' },
            React.createElement('div', { className: 'text-amber-500 text-4xl mb-4' }, '⚡'),
            React.createElement('h1', { className: 'text-xl font-bold text-amber-700 mb-4' }, 'Loading Failed'),
            React.createElement('p', { className: 'text-gray-600 mb-4' }, 'Failed to load authentication components.'),
            React.createElement('p', { className: 'text-sm text-gray-500 mb-4' }, 'Check your network connection and try refreshing the page.'),
            React.createElement('details', { className: 'text-left text-xs text-gray-400' },
              React.createElement('summary', { className: 'cursor-pointer' }, 'Technical details'),
              React.createElement('pre', { className: 'mt-2 p-2 bg-gray-100 rounded overflow-auto' }, error)
            )
          )
        );
      }
      window.LoadingError = LoadingError;

      // === SyncStatusDot ===
      // Renders a fixed-position sync status indicator in the top-right corner.
      // Reads status from window.__VIBES_SYNC_STATUS__ via a custom event bridge.
      // Activates automatically when the app calls useFireproofClerk().
      var SYNC_STATUS_COLORS = {
        idle: '#94a3b8',
        connecting: '#eab308',
        synced: '#22c55e',
        reconnecting: '#eab308',
        error: '#ef4444'
      };
      var SYNC_STATUS_LABELS = {
        idle: '',
        connecting: 'connecting',
        synced: 'synced',
        reconnecting: 'reconnecting',
        error: 'offline'
      };

      function SyncStatusDot() {
        var statusRef = React.useRef(window.__VIBES_SYNC_STATUS__ || 'idle');
        var _s = React.useState(0);
        var forceUpdate = _s[1];

        React.useEffect(function() {
          function onStatusChange() {
            var next = window.__VIBES_SYNC_STATUS__ || 'idle';
            statusRef.current = next;
            forceUpdate(function(n) { return n + 1; });
          }
          window.addEventListener('vibes-sync-status-change', onStatusChange);
          return function() {
            window.removeEventListener('vibes-sync-status-change', onStatusChange);
          };
        }, []);

        var status = statusRef.current;
        var color = SYNC_STATUS_COLORS[status] || '#94a3b8';
        var label = SYNC_STATUS_LABELS[status] || '';
        var isIdle = status === 'idle';
        var isSynced = status === 'synced';

        // Pill container — fixed top-right, frosted glass
        var containerStyle = {
          position: 'fixed',
          top: '12px',
          right: '12px',
          zIndex: 50,
          pointerEvents: 'none',
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          background: 'rgba(245, 245, 244, 0.6)',
          backdropFilter: 'blur(8px)',
          WebkitBackdropFilter: 'blur(8px)',
          padding: '6px 12px',
          borderRadius: '100px',
          border: '1px solid rgba(0, 0, 0, 0.03)',
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
          fontSize: '12px',
          fontWeight: '500',
          letterSpacing: '0.01em',
          userSelect: 'none',
          opacity: isIdle ? 0 : 1,
          transition: 'opacity 0.3s ease'
        };

        // Status light wrapper — relative for positioning pulse ring
        var lightWrapperStyle = {
          position: 'relative',
          width: '8px',
          height: '8px'
        };

        // Pulse ring — only rendered when synced
        var pulseRingStyle = {
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          width: '100%',
          height: '100%',
          borderRadius: '50%',
          backgroundColor: color,
          animation: 'vibes-sync-pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1)'
        };

        // Status light — 8px solid dot
        var dotStyle = {
          width: '8px',
          height: '8px',
          borderRadius: '50%',
          backgroundColor: color,
          position: 'relative',
          transition: 'background-color 0.4s ease'
        };

        // Label text
        var labelStyle = {
          color: '#111111',
          paddingTop: '1px',
          letterSpacing: '0.01em'
        };

        return React.createElement('div', {
          style: containerStyle,
          'aria-hidden': 'true',
          title: 'Sync: ' + status
        },
          React.createElement('div', { style: lightWrapperStyle },
            isSynced ? React.createElement('div', { style: pulseRingStyle }) : null,
            React.createElement('div', { style: dotStyle })
          ),
          label ? React.createElement('span', { style: labelStyle }, label) : null
        );
      }
      window.SyncStatusDot = SyncStatusDot;

      // === SharingBridge ===
      // Must be rendered inside ClerkFireproofProvider > SignedIn.
      // Bridges vibes-share-request DOM events to the dashApi.
      function SharingBridge() {
        var ctx = window.useClerkFireproofContext();
        var dashApi = ctx.dashApi;
        var dashApiRef = React.useRef(null);
        var ledgerCacheRef = React.useRef(null);
        dashApiRef.current = dashApi;

        React.useEffect(function() {
          function handleShareRequest(e) {
            var detail = e.detail;
            var email = detail.email;
            var api = dashApiRef.current;

            if (!api) {
              document.dispatchEvent(new CustomEvent('vibes-share-error', {
                detail: { error: { message: 'Sharing not ready. Please try again.' } }
              }));
              return;
            }

            (async function() {
              try {
                // Discover ledger for this app
                if (!ledgerCacheRef.current) {
                  var rLedgers = await api.listLedgersByUser({});
                  if (rLedgers.isErr()) throw new Error('Could not load ledger list');
                  ledgerCacheRef.current = rLedgers.Ok().ledgers;
                }
                var ledgers = ledgerCacheRef.current;
                var appHost = window.location.hostname;
                var matchedLedger = ledgers.find(function(l) {
                  return l.name && l.name.includes(appHost);
                }) || ledgers[0];

                if (!matchedLedger) {
                  throw new Error('No synced database found. Please wait for sync to complete.');
                }

                var rInvite = await api.inviteUser({
                  ticket: {
                    query: { byEmail: email },
                    invitedParams: {
                      ledger: {
                        id: matchedLedger.ledgerId,
                        role: 'member',
                        right: detail.right || 'write'
                      }
                    }
                  }
                });
                if (rInvite.isErr()) throw rInvite.Err();

                var inviteData = rInvite.Ok();
                console.debug('[vibes-sharing] inviteUser response:', inviteData);
                document.dispatchEvent(new CustomEvent('vibes-share-success', {
                  detail: {
                    email: email,
                    message: 'Invited ' + email + '! They can now sign in to access this app.'
                  }
                }));

                // Dual-write to KV registry (non-fatal)
                try {
                  var kvRegistryUrl = window.__VIBES_REGISTRY_URL__;
                  if (kvRegistryUrl && !kvRegistryUrl.startsWith('__')) {
                    var token = await window.Clerk?.session?.getToken();
                    if (token) {
                      var qp = new URLSearchParams(window.location.search).get('subdomain');
                      var hostname = window.location.hostname;
                      var parts = hostname.split('.');
                      var kvSubdomain = qp || (parts.length > 2 ? parts[0] : hostname);
                      fetch(kvRegistryUrl.replace(/\/$/, '') + '/invite', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                        body: JSON.stringify({ subdomain: kvSubdomain, email: email, right: detail.right || 'write' })
                      }).catch(function(e) { console.warn('[vibes-sharing] KV invite dual-write failed:', e); });
                    }
                  }
                } catch (kvErr) {
                  console.warn('[vibes-sharing] KV dual-write error:', kvErr);
                }
              } catch (err) {
                document.dispatchEvent(new CustomEvent('vibes-share-error', {
                  detail: { error: { message: err.message || 'Failed to send invitation.' } }
                }));
              }
            })();
          }

          document.addEventListener('vibes-share-request', handleShareRequest);
          return function() {
            document.removeEventListener('vibes-share-request', handleShareRequest);
          };
        }, []);

        return null;
      }
      window.SharingBridge = SharingBridge;

      // === VibesPanel Event Handler Hook ===
      function useVibesPanelEvents(logPrefix) {
        React.useEffect(() => {
          const handleLogout = () => {
            if (window.Clerk) window.Clerk.signOut();
          };
          const handleSyncDisable = () => {
            console.log('[' + logPrefix + '] Sync disabled');
          };

          document.addEventListener('vibes-logout-request', handleLogout);
          document.addEventListener('vibes-sync-disable', handleSyncDisable);
          return () => {
            document.removeEventListener('vibes-logout-request', handleLogout);
            document.removeEventListener('vibes-sync-disable', handleSyncDisable);
          };
        }, []);
      }
      window.useVibesPanelEvents = useVibesPanelEvents;
    </script>
    <!-- === DELTA_PLACEHOLDER === -->
  </body>
</html>
